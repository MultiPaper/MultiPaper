From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 17 Jan 2021 15:56:33 +1000
Subject: [PATCH] MultiPaper initial import commit


diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index f421e6a2e43e0a673dbb8a9a2b4331387e523e02..07669c5282de7668aa5bb74f1ba88d780781331a 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -380,9 +380,9 @@ public class PaperConfig {
         maxBookTotalSizeMultiplier = getDouble("settings.book-size.total-multiplier", maxBookTotalSizeMultiplier);
     }
 
-    public static boolean useOptimizedTickList = true;
+    public static boolean useOptimizedTickList = false; // MultiPaper - Don't used optimized tick list
     private static void useOptimizedTickList() {
-        if (config.contains("settings.use-optimized-ticklist")) { // don't add default, hopefully temporary config
+        if (config.contains("settings.use-optimized-ticklist") && false) { // don't add default, hopefully temporary config // MultiPaper - Don't used optimized tick list
             useOptimizedTickList = config.getBoolean("settings.use-optimized-ticklist");
         }
     }
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 78024e0b05fd24a0c3340f052fe8eb40191afdd6..3213ae9ea641cc2327881d5b9dca2b5399c9f5cb 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -738,7 +738,7 @@ public class PaperWorldConfig {
 
     public long delayChunkUnloadsBy;
     private void delayChunkUnloadsBy() {
-        delayChunkUnloadsBy = PaperConfig.getSeconds(getString("delay-chunk-unloads-by", "10s"));
+        delayChunkUnloadsBy = 0; // PaperConfig.getSeconds(getString("delay-chunk-unloads-by", "10s")); // MultiPaper disable delay
         if (delayChunkUnloadsBy > 0) {
             log("Delaying chunk unloads by " + delayChunkUnloadsBy + " seconds");
             delayChunkUnloadsBy *= 20;
diff --git a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
index eb0053850f53ceb60eb1ae3ac0e34034648fe1eb..d7ffacd252564332b2aa8facef42040cae3f71d8 100644
--- a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
+++ b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
@@ -30,6 +30,7 @@ import org.bukkit.event.Event;
 import org.bukkit.event.HandlerList;
 import org.bukkit.event.player.AsyncPlayerChatEvent;
 import org.bukkit.event.player.PlayerChatEvent;
+import puregero.multipaper.MultiPaper;
 
 public final class ChatProcessor {
     // <-- copied from adventure-text-serializer-legacy
@@ -181,6 +182,8 @@ public final class ChatProcessor {
                 viewer.sendMessage(player, renderer.render(player, displayName, message, viewer), MessageType.CHAT);
             }
         }
+
+        MultiPaper.broadcastPacket(event.getPlayer().getUniqueId(), renderer.render(player, displayName, message, player)); // MultiPaper broadcast chat message
     }
 
     private AsyncChatEvent createAsync(final ChatRenderer renderer, final Set<Audience> viewers, final Component message) {
diff --git a/src/main/java/net/minecraft/advancements/CriterionProgress.java b/src/main/java/net/minecraft/advancements/CriterionProgress.java
index 322f0fd9eff00085c2e9765395c7dcdef8bc9e12..6503e0c6007174d983ab69149230d2a1910421d2 100644
--- a/src/main/java/net/minecraft/advancements/CriterionProgress.java
+++ b/src/main/java/net/minecraft/advancements/CriterionProgress.java
@@ -43,7 +43,11 @@ public class CriterionProgress {
     }
 
     public JsonElement serializeToJson() {
-        return (JsonElement)(this.obtained != null ? new JsonPrimitive(DATE_FORMAT.format(this.obtained)) : JsonNull.INSTANCE);
+        try {
+            return (JsonElement)(this.obtained != null ? new JsonPrimitive(DATE_FORMAT.format(this.obtained)) : JsonNull.INSTANCE);
+        } catch (Exception e) {
+            return JsonNull.INSTANCE;
+        }
     }
 
     public static CriterionProgress fromNetwork(FriendlyByteBuf buf) {
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundPlayerInfoPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundPlayerInfoPacket.java
index 420cc7ab5f7245f31dd5b333eacf4e306fc6e7c1..fb9a0cb7852056f22c6cbee5e197da484f15fdc4 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundPlayerInfoPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundPlayerInfoPacket.java
@@ -5,7 +5,10 @@ import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.properties.Property;
 import com.mojang.authlib.properties.PropertyMap;
+
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Iterator;
 import java.util.List;
 import javax.annotation.Nullable;
 import net.minecraft.network.FriendlyByteBuf;
@@ -62,6 +65,23 @@ public class ClientboundPlayerInfoPacket implements Packet<ClientGamePacketListe
         return this.action;
     }
 
+    // MultiPaper start
+    public ClientboundPlayerInfoPacket(Iterable<PlayerUpdate> iterable) {
+        this.action = Action.ADD_PLAYER;
+        this.entries = new ArrayList<>();
+
+        Iterator<PlayerUpdate> iterator = iterable.iterator();
+
+        while (iterator.hasNext()) {
+            this.entries.add(iterator.next());
+        }
+    }
+
+    public List<ClientboundPlayerInfoPacket.PlayerUpdate> getPlayerUpdates() {
+        return entries;
+    }
+    // MultiPaper end
+
     @Nullable
     static Component readDisplayName(FriendlyByteBuf buf) {
         return buf.readBoolean() ? buf.readComponent() : null;
@@ -186,11 +206,13 @@ public class ClientboundPlayerInfoPacket implements Packet<ClientGamePacketListe
     }
 
     public static class PlayerUpdate {
-        private final int latency;
-        private final GameType gameMode;
-        private final GameProfile profile;
+        // MultiPaper start - make not final and public
+        public int latency;
+        public GameType gameMode;
+        public GameProfile profile;
         @Nullable
-        private final Component displayName;
+        public Component displayName;
+        // MultiPaper end
 
         public PlayerUpdate(GameProfile profile, int latency, @Nullable GameType gameMode, @Nullable Component displayName) {
             this.profile = profile;
diff --git a/src/main/java/net/minecraft/network/protocol/game/ServerboundTeleportToEntityPacket.java b/src/main/java/net/minecraft/network/protocol/game/ServerboundTeleportToEntityPacket.java
index 4d36dcce588a503ba879528d98241ee86f70d48c..aefff51e2832cc0842dfb62534c23953009c919a 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ServerboundTeleportToEntityPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ServerboundTeleportToEntityPacket.java
@@ -32,4 +32,10 @@ public class ServerboundTeleportToEntityPacket implements Packet<ServerGamePacke
     public Entity getEntity(ServerLevel world) {
         return world.getEntity(this.uuid);
     }
+    
+    // MultiPaper start - Expose uuid
+    public UUID getUUID() {
+        return uuid;
+    }
+    // MultiPaper end
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index a12a3546c62f72edf15975ce91a65af5b7fe56a7..e05e5c2b11a7fc5b9a5b35b28f8bc6a3787e5231 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -189,6 +189,9 @@ import org.bukkit.event.server.ServerLoadEvent;
 import co.aikar.timings.MinecraftTimings; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
 
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.ShutdownHandler;
+
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements SnooperPopulator, CommandSource, AutoCloseable {
 
     private static MinecraftServer SERVER; // Paper
@@ -1040,6 +1043,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // CraftBukkit end
         MinecraftServer.LOGGER.info("Stopping server");
         MinecraftTimings.stopServer(); // Paper
+        ShutdownHandler.onStop(); // MultiPaper
         // CraftBukkit start
         if (this.server != null) {
             this.server.disablePlugins();
@@ -1547,6 +1551,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         tickTimes60s.add(this.tickCount, l);
         // Paper end
 
+        MultiPaper.sendTickTime(i1 - i); // MultiPaper
         this.frameTimer.logFrameDuration(i1 - i);
         this.profiler.pop();
         org.spigotmc.WatchdogThread.tick(); // Spigot
diff --git a/src/main/java/net/minecraft/server/PlayerAdvancements.java b/src/main/java/net/minecraft/server/PlayerAdvancements.java
index 7d6dc0a8ee35274052b122bbc446bc54750de0a6..0144878e85fffe96a6ad707c2eafb841bda99a70 100644
--- a/src/main/java/net/minecraft/server/PlayerAdvancements.java
+++ b/src/main/java/net/minecraft/server/PlayerAdvancements.java
@@ -52,6 +52,8 @@ import net.minecraft.world.level.GameRules;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+import puregero.multipaper.MultiPaper;
+
 public class PlayerAdvancements {
 
     private static final Logger LOGGER = LogManager.getLogger();
@@ -156,9 +158,15 @@ public class PlayerAdvancements {
     }
 
     private void load(ServerAdvancementManager advancementLoader) {
-        if (this.file.isFile()) {
+        String json = null;
+        try {
+            json = MultiPaper.readAdvancements(player.getStringUUID());
+        } catch (IOException e1) {
+            e1.printStackTrace();
+        }
+        if ((json != null && !json.isEmpty()) || this.file.isFile()) {
             try {
-                JsonReader jsonreader = new JsonReader(new StringReader(Files.toString(this.file, StandardCharsets.UTF_8)));
+                JsonReader jsonreader = new JsonReader(new StringReader(json));
 
                 try {
                     jsonreader.setLenient(false);
@@ -239,6 +247,12 @@ public class PlayerAdvancements {
         jsonelement.getAsJsonObject().addProperty("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
 
         try {
+            // MultiPaper start
+            if (true) {
+                MultiPaper.writeAdvancements(player.getStringUUID(), PlayerAdvancements.GSON.toJson(jsonelement));
+                return;
+            }
+            // MultiPaper end
             FileOutputStream fileoutputstream = new FileOutputStream(this.file);
 
             try {
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 1bf19965d12514dee34545235bfbadc0b74ddc8b..e92191d00526a60e3bec2171daca8ab144b77c8f 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -71,6 +71,7 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class DedicatedServer extends MinecraftServer implements ServerInterface {
@@ -277,6 +278,8 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.STARTUP);
         // CraftBukkit end
 
+        MultiPaper.onStart(); // MultiPaper
+        
         if (!this.usesAuthentication()) {
             DedicatedServer.LOGGER.warn("**** SERVER IS RUNNING IN OFFLINE/INSECURE MODE!");
             DedicatedServer.LOGGER.warn("The server will make no attempt to authenticate usernames. Beware.");
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 4386402e5e55438475c48b023c61bfb2dbe71a8f..0c9552552d07f5dcd57050596355041d822347f5 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -105,6 +105,11 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.entity.Player; // CraftBukkit
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
 
+// MultiPaper start
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.Zone;
+// MultiPaper end
+
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
     private static final byte CHUNK_TYPE_REPLACEABLE = -1;
@@ -956,6 +961,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
             do {
                 boolean isShuttingDown = level.getServer().hasStopped(); // Paper
+
+                if (!isShuttingDown) new Exception("ChunkMap.saveAllChunks has been called even though the server isn't shutting down!").printStackTrace(); // MultiPaper
+                
                 mutableboolean.setFalse();
                 list.stream().map((playerchunk) -> {
                     CompletableFuture completablefuture;
@@ -1064,6 +1072,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             poiData, null, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
 
         if (!chunk.isUnsaved()) {
+            MultiPaper.notifyChunkNotSaving(chunk.getPos(), this.level);
             return;
         }
 
@@ -1505,6 +1514,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         try (co.aikar.timings.Timing ignored = this.level.timings.chunkSave.startTiming()) { // Paper
         this.poiManager.flush(chunk.getPos());
         if (!chunk.isUnsaved()) {
+            MultiPaper.notifyChunkNotSaving(chunk.getPos(), this.level);
             return false;
         } else {
             chunk.setLastSaved(this.level.getGameTime()); // Paper - track save time
@@ -1677,6 +1687,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
             return ret;
         }
+        if (true) return MultiPaper.readChunk(chunkcoordintpair, level); // MultiPaper
         return super.read(chunkcoordintpair);
     }
 
@@ -1688,6 +1699,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
+        // MultiPaper start
+        if (true) {
+            MultiPaper.writeChunk(chunkcoordintpair, level, nbttagcompound);
+            return;
+        }
+        // MultiPaper end
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
@@ -1731,6 +1748,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             return status;
         }
 
+        if (true) return null; // MultiPaper - Don't load chunk status from the disk
+
         this.readChunk(chunkPos);
 
         return regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 7470f3ba66c2e894b5a5b0ba392ecabf8b04aff9..1a5c16f7237df07bf70be2bcb8ba26f75c82ea89 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -45,12 +45,13 @@ import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
+import puregero.multipaper.MultiPaper;
 
 public class ServerChunkCache extends ChunkSource {
     public static final org.apache.logging.log4j.Logger LOGGER = org.apache.logging.log4j.LogManager.getLogger(); // Paper
 
     public static final List<ChunkStatus> CHUNK_STATUSES = ChunkStatus.getStatusList();
-    private final DistanceManager distanceManager;
+    public final DistanceManager distanceManager; // MultiPaper - make public
     public final ChunkGenerator generator;
     final ServerLevel level;
     public final Thread mainThread;
@@ -1038,6 +1039,8 @@ public class ServerChunkCache extends ChunkSource {
                     // Paper end
                     ChunkPos chunkcoordintpair = chunk.getPos();
 
+                    if (!MultiPaper.shouldTickChunk(this.level, chunk)) return; // MultiPaper - Should we tick this chunk?
+
                     if ((true || this.level.isPositionEntityTicking(chunkcoordintpair)) && !this.chunkMap.isOutsideOfRange(playerchunk, chunkcoordintpair, false)) { // Paper - optimise isOutsideOfRange // Paper - we only iterate entity ticking chunks
                         chunk.setInhabitedTime(chunk.getInhabitedTime() + j);
                         if (flag1 && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunk.getPos()) && !this.chunkMap.isOutsideOfRange(playerchunk, chunkcoordintpair, true)) { // Spigot // Paper - optimise isOutsideOfRange
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index cebaf0fb8187335ca303621a2cb412bb22584e23..9199ab980f7f453f9096802769aa33256308b14e 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -160,6 +160,7 @@ import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
 
@@ -754,6 +755,9 @@ public class ServerLevel extends Level implements WorldGenLevel {
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             timings.entityTick.startTiming(); // Spigot
             this.entityTickList.forEach((entity) -> {
+
+                if (!MultiPaper.shouldTickEntity(this, entity)) return; // MultiPaper - Should we tick this entity?
+
                 if (!entity.isRemoved()) {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
                         entity.discard();
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 6d2d2ba4a83d887f4d52188305a4a28c2ee2f014..9f6a00733237f785055b32ca95a3bd298b5be06c 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -240,6 +240,7 @@ public class ServerPlayer extends Player {
     public final int[] mobCounts = new int[MOBCATEGORY_TOTAL_ENUMS]; // Paper
     public final com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> cachedSingleMobDistanceMap;
     // Paper end
+    public boolean isBeingSentToAnotherServer = false; // MultiPaper
 
     // CraftBukkit start
     public String displayName;
@@ -251,6 +252,7 @@ public class ServerPlayer extends Player {
     public int newTotalExp = 0;
     public boolean keepLevel = false;
     public double maxHealthCache;
+    public boolean shouldTickEntities = true; // MultiPaper
     public boolean joining = true;
     public boolean sentListPacket = false;
     public boolean supressTrackerForLogin = false; // Paper
@@ -447,6 +449,8 @@ public class ServerPlayer extends Player {
             this.enteredNetherPosition = new Vec3(nbttagcompound1.getDouble("x"), nbttagcompound1.getDouble("y"), nbttagcompound1.getDouble("z"));
         }
 
+        this.isBeingSentToAnotherServer = nbt.getBoolean("isBeingSentToAnotherServer"); // MultiPaper
+        
         this.seenCredits = nbt.getBoolean("seenCredits");
         if (nbt.contains("recipeBook", 10)) {
             this.recipeBook.fromNbt(nbt.getCompound("recipeBook"), this.server.getRecipeManager());
@@ -509,6 +513,8 @@ public class ServerPlayer extends Player {
             }
         }
 
+        nbt.putBoolean("isBeingSentToAnotherServer", this.isBeingSentToAnotherServer); // MultiPaper
+        
         if (persistVehicle && entity1 != null && entity != this && entity.hasExactlyOnePlayerPassenger()) {
             // CraftBukkit end
             CompoundTag nbttagcompound2 = new CompoundTag();
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 559572d3ff37e016ed07d428cf5d73a00ef48d70..41990f344bd9de5b86253a2d8c6270db45c07db7 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -214,6 +214,7 @@ import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.SmithingInventory;
 import org.bukkit.util.NumberConversions;
 import co.aikar.timings.MinecraftTimings; // Paper
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class ServerGamePacketListenerImpl implements ServerPlayerConnection, ServerGamePacketListener {
@@ -1895,6 +1896,13 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
                     return;
                 }
             }
+
+            // MultiPaper start - Find player on another server
+            Location location = MultiPaper.getPlayerLocation(packet.getUUID());
+            if (location != null) {
+                this.player.getBukkitEntity().teleportAsync(location, PlayerTeleportEvent.TeleportCause.SPECTATE);
+            }
+            // MultiPaper end
         }
 
     }
@@ -2223,6 +2231,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
                         recipient.sendMessage(ServerGamePacketListenerImpl.this.player.getUUID(), s);
                     }
                 }
+                MultiPaper.broadcastPacket(ServerGamePacketListenerImpl.this.player.getUUID(), s); // MultiPaper
             }
         }
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index ad9fb50791779a5fe7d22268b71bd10d9c9ff3f0..16e4b1f6c781940abc173433515a99480a933c53 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -119,6 +119,9 @@ import org.bukkit.event.player.PlayerJoinEvent;
 import org.bukkit.event.player.PlayerLoginEvent;
 import org.bukkit.event.player.PlayerQuitEvent;
 import org.bukkit.event.player.PlayerRespawnEvent;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.PlayerInfoManager;
+import puregero.multipaper.Zone;
 // CraftBukkit end
 
 public abstract class PlayerList {
@@ -281,6 +284,13 @@ public abstract class PlayerList {
         player.getRecipeBook().sendInitialRecipeBook(player);
         this.updateEntireScoreboard(worldserver1.getScoreboard(), player);
         this.server.invalidateStatus();
+
+        // MultiPaper start - Check if player should move servers
+        if (Zone.checkIfShouldMerge(player.getBukkitEntity())) {
+            return;
+        }
+        // MultiPaper end
+
         // Paper start - async load spawn in chunk
         ServerLevel finalWorldserver = worldserver1;
         int chunkX = loc.getBlockX() >> 4;
@@ -336,13 +346,19 @@ public abstract class PlayerList {
         }
         // CraftBukkit start
         chatmessage.withStyle(ChatFormatting.YELLOW);
+        // MultiPaper start
+        if (player.isBeingSentToAnotherServer) {
+            player.isBeingSentToAnotherServer = false;
+            chatmessage = null;
+        }
+        // MultiPaper end
         Component joinMessage = chatmessage; // Paper - Adventure
 
         playerconnection.teleport(player.getX(), player.getY(), player.getZ(), player.getYRot(), player.getXRot());
         this.players.add(player);
         this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player); // Spigot
         this.playersByUUID.put(player.getUUID(), player);
-        // this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, new EntityPlayer[]{entityplayer})); // CraftBukkit - replaced with loop below
+        this.broadcastAll(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.ADD_PLAYER, new ServerPlayer[]{player})); // CraftBukkit - replaced with loop below // MultiPaper - Keep original sendAll
 
         // Paper start - correctly register player BEFORE PlayerJoinEvent, so the entity is valid and doesn't require tick delay hacks
         player.supressTrackerForLogin = true;
@@ -373,6 +389,11 @@ public abstract class PlayerList {
         }
         // CraftBukkit end
 
+        MultiPaper.lockPlayer(player.getStringUUID()); // MultiPaper
+        MultiPaper.lockAdvancements(player.getStringUUID()); // MultiPaper
+        MultiPaper.lockStats(player.getStringUUID()); // MultiPaper
+        PlayerInfoManager.send(player); // MultiPaper
+
         // CraftBukkit start - sendAll above replaced with this loop
         ClientboundPlayerInfoPacket packet = new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.ADD_PLAYER, player);
 
@@ -380,7 +401,7 @@ public abstract class PlayerList {
             ServerPlayer entityplayer1 = (ServerPlayer) this.players.get(i);
 
             if (entityplayer1.getBukkitEntity().canSee(bukkitPlayer)) {
-                entityplayer1.connection.send(packet);
+                // entityplayer1.connection.send(packet); // MultiPaper - Keep original sendAll
             }
 
             if (!bukkitPlayer.canSee(entityplayer1.getBukkitEntity())) {
@@ -604,6 +625,7 @@ public abstract class PlayerList {
         }
 
         PlayerQuitEvent playerQuitEvent = new PlayerQuitEvent(entityplayer.getBukkitEntity(), leaveMessage, entityplayer.quitReason); // Paper - quit reason
+        if (entityplayer.isBeingSentToAnotherServer) playerQuitEvent.setQuitMessage(null); // MultiPaper - No quit message if they're going to another server
         if (entityplayer.didPlayerJoinEvent) this.cserver.getPluginManager().callEvent(playerQuitEvent); // Paper - if we disconnected before join ever fired, don't fire quit
         entityplayer.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
 
@@ -629,6 +651,9 @@ public abstract class PlayerList {
         // Paper end
 
         this.save(entityplayer);
+        MultiPaper.releasePlayer(entityplayer.getStringUUID()); // MultiPaper
+        MultiPaper.releaseAdvancements(entityplayer.getStringUUID()); // MultiPaper
+        MultiPaper.releaseStats(entityplayer.getStringUUID()); // MultiPaper
         if (entityplayer.isPassenger()) {
             Entity entity = entityplayer.getRootVehicle();
 
@@ -675,13 +700,13 @@ public abstract class PlayerList {
         // Paper end
 
         // CraftBukkit start
-        // this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, new EntityPlayer[]{entityplayer}));
+        this.broadcastAll(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.REMOVE_PLAYER, new ServerPlayer[]{entityplayer})); // MultiPaper - Keep original sendAll
         ClientboundPlayerInfoPacket packet = new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.REMOVE_PLAYER, entityplayer);
         for (int i = 0; i < this.players.size(); i++) {
             ServerPlayer entityplayer2 = (ServerPlayer) this.players.get(i);
 
             if (entityplayer2.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
-                entityplayer2.connection.send(packet);
+                // entityplayer2.connection.send(packet); // MultiPaper - Keep original sendAll
             } else {
                 entityplayer2.getBukkitEntity().removeDisconnectingPlayer(entityplayer.getBukkitEntity());
             }
@@ -1028,6 +1053,17 @@ public abstract class PlayerList {
     }
 
     public void broadcastAll(Packet<?> packet) {
+        // MultiPaper start - Intercept ClientboundPlayerInfoPacket packet
+        if (packet instanceof ClientboundPlayerInfoPacket) {
+            MultiPaper.broadcastPacket(packet);
+        }
+
+        broadcastAllNoIntercept(packet);
+    }
+
+    public void broadcastAllNoIntercept(Packet<?> packet) {
+        // MultiPaper end
+
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
@@ -1397,6 +1433,7 @@ public abstract class PlayerList {
 
     public void broadcastMessage(Component message, ChatType type, UUID sender) {
         this.server.sendMessage(message, sender);
+        MultiPaper.broadcastPacket(new ClientboundChatPacket(CraftChatMessage.fixComponent(message), type, sender)); // MultiPaper
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/net/minecraft/server/players/StoredUserList.java b/src/main/java/net/minecraft/server/players/StoredUserList.java
index 9152c6c9e7e5c8fdb9183c2b4f088a810621b333..8d6f203d4caee6fc03f070aedd1864d80b20618c 100644
--- a/src/main/java/net/minecraft/server/players/StoredUserList.java
+++ b/src/main/java/net/minecraft/server/players/StoredUserList.java
@@ -26,6 +26,7 @@ import net.minecraft.Util;
 import net.minecraft.util.GsonHelper;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
 
@@ -162,7 +163,7 @@ public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
         BufferedWriter bufferedwriter = Files.newWriter(this.file, StandardCharsets.UTF_8);
 
         try {
-            StoredUserList.GSON.toJson(jsonarray, bufferedwriter);
+            MultiPaper.writeJson(this.file.getName(), StoredUserList.GSON.toJson(jsonarray)); // StoredUserList.GSON.toJson(jsonarray, bufferedwriter); // MultiPaper
         } catch (Throwable throwable) {
             if (bufferedwriter != null) {
                 try {
@@ -182,11 +183,18 @@ public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
     }
 
     public void load() throws IOException {
-        if (this.file.exists()) {
-            BufferedReader bufferedreader = Files.newReader(this.file, StandardCharsets.UTF_8);
+        if (true || this.file.exists()) {
+            BufferedReader bufferedreader = null; // Files.newReader(this.file, StandardCharsets.UTF_8); // MultiPaper
+            
+            // MultiPaper start
+            String json = MultiPaper.readJson(this.file.getName());
+            if (json == null || json.isEmpty()) {
+                return;
+            }
+            // MultiPaper end
 
             try {
-                JsonArray jsonarray = (JsonArray) StoredUserList.GSON.fromJson(bufferedreader, JsonArray.class);
+                JsonArray jsonarray = (JsonArray) StoredUserList.GSON.fromJson(json, JsonArray.class); // StoredUserList.GSON.fromJson(bufferedreader, JsonArray.class); // MultiPaper
                 com.google.common.base.Preconditions.checkState(jsonarray != null, "The file \"" + this.file.getName() + "\" is either empty or corrupt"); // Paper
 
                 this.map.clear();
diff --git a/src/main/java/net/minecraft/stats/ServerStatsCounter.java b/src/main/java/net/minecraft/stats/ServerStatsCounter.java
index 9f3355dbbbab1ab88cf2b7034130c2888e38d7a7..f561725d54249259fe05d144bd03ce421237bef7 100644
--- a/src/main/java/net/minecraft/stats/ServerStatsCounter.java
+++ b/src/main/java/net/minecraft/stats/ServerStatsCounter.java
@@ -36,6 +36,7 @@ import net.minecraft.world.entity.player.Player;
 import org.apache.commons.io.FileUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class ServerStatsCounter extends StatsCounter {
 
@@ -54,6 +55,21 @@ public class ServerStatsCounter extends StatsCounter {
             this.stats.put( wrapper, entry.getValue().intValue() );
         }
         // Spigot end
+        // MultiPaper start
+        if (true) {
+            try {
+                String json = MultiPaper.readStats(this.file.getName().split("\\.")[0]);
+                if (!json.isEmpty()) {
+                    this.parseLocal(server.getFixerUpper(), json);
+                }
+            } catch (IOException ioexception) {
+                ServerStatsCounter.LOGGER.error("Couldn't read statistics file {}", file, ioexception);
+            } catch (JsonParseException jsonparseexception) {
+                ServerStatsCounter.LOGGER.error("Couldn't parse statistics file {}", file, jsonparseexception);
+            }
+            return;
+        }
+        // MultiPaper end
         if (file.isFile()) {
             try {
                 this.parseLocal(server.getFixerUpper(), FileUtils.readFileToString(file));
@@ -69,6 +85,12 @@ public class ServerStatsCounter extends StatsCounter {
     public void save() {
         if ( org.spigotmc.SpigotConfig.disableStatSaving ) return; // Spigot
         try {
+            // MultiPaper start
+            if (true) {
+                MultiPaper.writeStats(this.file.getName().split("\\.")[0], this.toJson());
+                return;
+            }
+            // MultiPaper end
             FileUtils.writeStringToFile(this.file, this.toJson());
         } catch (IOException ioexception) {
             ServerStatsCounter.LOGGER.error("Couldn't save stats", ioexception);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 94857a736d2a16e8ade286c6f2ddf8bd798008eb..99dbd294a844ea1244bb8312bc3ff54be0e7197e 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -147,6 +147,7 @@ import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public abstract class Entity implements Nameable, EntityAccess, CommandSource, net.minecraft.server.KeyedObject { // Paper
@@ -3183,11 +3184,6 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, n
                 // CraftBukkit end
 
                 this.level.getProfiler().popPush("reloading");
-                // Paper start - Change lead drop timing to prevent dupe
-                if (this instanceof Mob) {
-                    ((Mob) this).dropLeash(true, true); // Paper drop lead
-                }
-                // Paper end
                 Entity entity = this.getType().create((Level) worldserver);
 
                 if (entity != null) {
@@ -3201,6 +3197,10 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, n
                     // CraftBukkit start - Forward the CraftEntity to the new entity
                     this.getBukkitEntity().setHandle(entity);
                     entity.bukkitEntity = this.getBukkitEntity();
+
+                    if (this instanceof Mob) {
+                        ((Mob) this).dropLeash(true, true); // Paper drop lead
+                    }
                     // CraftBukkit end
                 }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index 2b79ace854461b216dc4970d1cc4a3953a51dd50..34078ef54fe0b06fb165377a4314e02c49af0fa4 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -6,6 +6,8 @@ import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
+import puregero.multipaper.MultiPaper;
+
 import java.io.File;
 import java.util.Collections;
 import java.util.Comparator;
@@ -311,7 +313,10 @@ public class PoiManager extends SectionStorage<PoiSection> {
             }
             return ret;
         }
-        return super.read(chunkcoordintpair);
+        // MultiPaper start
+        return MultiPaper.readRegionFileNBT(world, "poi", chunkcoordintpair);
+        // return super.read(chunkcoordintpair);
+        // MultiPaper end
     }
 
     @Override
@@ -322,7 +327,10 @@ public class PoiManager extends SectionStorage<PoiSection> {
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
-        super.write(chunkcoordintpair, nbttagcompound);
+        // MultiPaper start
+        MultiPaper.writeRegionFileNBT(world, "poi", chunkcoordintpair, nbttagcompound);
+        //super.write(chunkcoordintpair, nbttagcompound);
+        // MultiPaper end
     }
     // Paper end
 
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index cea92f1dc663bf0648b2bd877d86ca380a517bc9..8534f01cd8ddf9143aafb7cf26c8ec0533a79a32 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -124,6 +124,7 @@ import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.entity.EntityExhaustionEvent;
 import org.bukkit.event.player.PlayerDropItemEvent;
 import org.bukkit.event.player.PlayerVelocityEvent;
+import org.bukkit.util.Vector;
 // CraftBukkit end
 
 public abstract class Player extends LivingEntity {
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index b93056b91e7ebd49e6ddb53ccb6c05c056088df9..f156b184a85dc3f1e21d729534199d0db2dfbe8d 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -100,6 +100,10 @@ import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
 // CraftBukkit end
 
+// MultiPaper start
+import puregero.multipaper.MultiPaper;
+// MultiPaper end
+
 public abstract class Level implements LevelAccessor, AutoCloseable {
 
     protected static final Logger LOGGER = LogManager.getLogger();
@@ -380,7 +384,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         });
         // CraftBukkit end
         timings = new co.aikar.timings.WorldTimingsHandler(this); // Paper - code below can generate new world and access timings
-        this.keepSpawnInMemory = this.paperConfig.keepSpawnInMemory; // Paper
+        this.keepSpawnInMemory = false; // this.paperConfig.keepSpawnInMemory; // Paper // MultiPaper - default to false
         this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
         this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
         this.chunkPacketBlockController = this.paperConfig.antiXray ?
@@ -969,6 +973,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 toRemove.add(tickingblockentity); // Paper - use removeAll
                 // Spigot end
             } else {
+                if (!MultiPaper.shouldTickChunk((ServerLevel) this, getChunkIfLoaded(tickingblockentity.getPos()))) continue; // MultiPaper - Don't tick this tile entity rn
                 tickingblockentity.tick();
             }
         }
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index e1b32b644bc976ff66258ed706f4d1e8de99420d..4e9312c831215bdd92f4dce081eda0dff17e849e 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -39,6 +39,7 @@ import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.Fluids;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class ProtoChunk implements ChunkAccess {
     private static final Logger LOGGER = LogManager.getLogger();
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index 4881e6ef4393a3d4fc1bd88e2574dcb6d7028e40..428fda5063d05d7b22d5c0e072fcd1c6bfdbd7a9 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -443,6 +443,9 @@ public class RegionFile implements AutoCloseable {
             ((java.nio.Buffer) this.offsets).limit(1024); // CraftBukkit - decompile error
             ((java.nio.Buffer) this.header).position(4096); // CraftBukkit - decompile error
             this.timestamps = this.header.asIntBuffer();
+            // MultiPaper start
+            this.file = null;
+            /*
             if (dsync) {
                 this.file = FileChannel.open(file, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.DSYNC);
             } else {
@@ -537,6 +540,8 @@ public class RegionFile implements AutoCloseable {
                 }
                 // Paper end
             }
+            */
+            // MultiPaper end
 
         }
     }
@@ -890,6 +895,7 @@ public class RegionFile implements AutoCloseable {
     }
 
     public boolean hasChunk(ChunkPos pos) {
+        if (true) return true; // MultiPaper - always return true
         return this.getOffset(pos) != 0;
     }
 
@@ -899,6 +905,12 @@ public class RegionFile implements AutoCloseable {
     }
 
     public void close() throws IOException {
+        // MultiPaper start
+        if (this.file == null) {
+            this.closed = true;
+            return;
+        }
+        // MultiPaper end
         // Paper start - Prevent regionfiles from being closed during use
         this.fileLock.lock();
         synchronized (this) {
diff --git a/src/main/java/net/minecraft/world/level/saveddata/SavedData.java b/src/main/java/net/minecraft/world/level/saveddata/SavedData.java
index 5d60a4ebbd039077c4d2458ac8d8110097eb74a3..9f1d30c55e3d59c879be9aaf69edfb6533af06e8 100644
--- a/src/main/java/net/minecraft/world/level/saveddata/SavedData.java
+++ b/src/main/java/net/minecraft/world/level/saveddata/SavedData.java
@@ -7,6 +7,7 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtIo;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public abstract class SavedData {
     private static final Logger LOGGER = LogManager.getLogger();
@@ -33,7 +34,7 @@ public abstract class SavedData {
             compoundTag.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
 
             try {
-                NbtIo.writeCompressed(compoundTag, file);
+                MultiPaper.writeData(file.getPath(), compoundTag); // NbtIo.writeCompressed(compoundTag, file); // MultiPaper
             } catch (IOException var4) {
                 LOGGER.error("Could not save data {}", this, var4);
             }
diff --git a/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java b/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
index c8ed0673ff819cb88d0ee6f53f2a2b9b46b203d4..998bedc9a09331a8d7b02a19578f969d52595a6d 100644
--- a/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
@@ -2,11 +2,9 @@ package net.minecraft.world.level.storage;
 
 import com.google.common.collect.Maps;
 import com.mojang.datafixers.DataFixer;
-import java.io.DataInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.PushbackInputStream;
+
+import java.io.*;
+import java.util.Iterator;
 import java.util.Map;
 import java.util.function.Function;
 import java.util.function.Supplier;
@@ -19,6 +17,7 @@ import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.level.saveddata.SavedData;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class DimensionDataStorage {
     private static final Logger LOGGER = LogManager.getLogger();
@@ -61,8 +60,11 @@ public class DimensionDataStorage {
     private <T extends SavedData> T readSavedData(Function<CompoundTag, T> function, String id) {
         try {
             File file = this.getDataFile(id);
-            if (file.exists()) {
+            if (true || file.exists()) { // MultiPaper - Always run
                 CompoundTag compoundTag = this.readTagFromDisk(id, SharedConstants.getCurrentVersion().getWorldVersion());
+
+                if (compoundTag == null) return null; // MultiPaper
+
                 return function.apply(compoundTag.getCompound("data"));
             }
         } catch (Exception var5) {
@@ -78,7 +80,14 @@ public class DimensionDataStorage {
 
     public CompoundTag readTagFromDisk(String id, int dataVersion) throws IOException {
         File file = this.getDataFile(id);
-        FileInputStream fileInputStream = new FileInputStream(file);
+        // MultiPaper start
+        byte[] data = MultiPaper.readData(file.getPath());
+        if (data == null || data.length == 0) {
+            return null;
+        }
+        // FileInputStream fileInputStream = new FileInputStream(file);
+        ByteArrayInputStream fileInputStream = new ByteArrayInputStream(data);
+        // MultiPaper end
 
         CompoundTag var8;
         try {
@@ -160,4 +169,10 @@ public class DimensionDataStorage {
 
         });
     }
+
+    // MultiPaper start - save a PersistentBase
+    public void save(String id, SavedData savedData) {
+        savedData.save(this.getDataFile(id));
+    }
+    // MultiPaper end
 }
diff --git a/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java b/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
index b794c02ea36bdc901b1f6a160095abb3fcfe9b60..aa8135c5fd9bc1466c7d1e4e46e09ceb2cd2db38 100644
--- a/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
+++ b/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
@@ -61,6 +61,7 @@ import net.minecraft.world.level.levelgen.NoiseGeneratorSettings;
 import net.minecraft.world.level.levelgen.WorldGenSettings;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class LevelStorageSource {
 
@@ -198,7 +199,7 @@ public class LevelStorageSource {
         } else {
             File file1 = new File(file, "level.dat");
 
-            if (file1.exists()) {
+            if (true || file1.exists()) { // MultiPaper
                 T t0 = levelDataParser.apply(file1, this.fixerUpper);
 
                 if (t0 != null) {
@@ -214,7 +215,7 @@ public class LevelStorageSource {
     @Nullable
     private static DataPackConfig getDataPacks(File file, DataFixer datafixer) {
         try {
-            CompoundTag nbttagcompound = NbtIo.readCompressed(file);
+            CompoundTag nbttagcompound = MultiPaper.readLevel(file.getParentFile().getName()); // NbtIo.readCompressed(file); // MultiPaper
             CompoundTag nbttagcompound1 = nbttagcompound.getCompound("Data");
 
             nbttagcompound1.remove("Player");
@@ -231,7 +232,7 @@ public class LevelStorageSource {
     static BiFunction<File, DataFixer, PrimaryLevelData> getLevelData(DynamicOps<Tag> dynamicops, DataPackConfig datapackconfiguration) {
         return (file, datafixer) -> {
             try {
-                CompoundTag nbttagcompound = NbtIo.readCompressed(file);
+                CompoundTag nbttagcompound = MultiPaper.readLevel(file.getParentFile().getName()); // NbtIo.readCompressed(file); // MultiPaper
                 CompoundTag nbttagcompound1 = nbttagcompound.getCompound("Data");
                 CompoundTag nbttagcompound2 = nbttagcompound1.contains("Player", 10) ? nbttagcompound1.getCompound("Player") : null;
 
@@ -253,7 +254,7 @@ public class LevelStorageSource {
     BiFunction<File, DataFixer, LevelSummary> levelSummaryReader(File file, boolean locked) {
         return (file1, datafixer) -> {
             try {
-                CompoundTag nbttagcompound = NbtIo.readCompressed(file1);
+                CompoundTag nbttagcompound = MultiPaper.readLevel(file.getName()); // NbtIo.readCompressed(file1); // MultiPaper
                 CompoundTag nbttagcompound1 = nbttagcompound.getCompound("Data");
 
                 nbttagcompound1.remove("Player");
@@ -410,6 +411,13 @@ public class LevelStorageSource {
             nbttagcompound2.put("Data", nbttagcompound1);
 
             try {
+                // MultiPaper start
+                if (true) {
+                    MultiPaper.writeLevel(file.getName(), nbttagcompound2);
+                    return;
+                }
+                // MultiPaper end
+
                 File file1 = File.createTempFile("level", ".dat", file);
 
                 NbtIo.writeCompressed(nbttagcompound2, file1);
diff --git a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
index 35c39aed9583275ef25d32c783715798b52bdb63..8fb5a062f2b0390a479b2db44a04f4a8da4837d8 100644
--- a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
@@ -17,6 +17,7 @@ import org.apache.logging.log4j.Logger;
 import java.io.FileInputStream;
 import java.io.InputStream;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class PlayerDataStorage {
@@ -35,6 +36,14 @@ public class PlayerDataStorage {
         if (org.spigotmc.SpigotConfig.disablePlayerDataSaving) return; // Spigot
         try {
             CompoundTag nbttagcompound = player.saveWithoutId(new CompoundTag());
+
+            // MultiPaper start
+            if (true) {
+                MultiPaper.writePlayer(player.getStringUUID(), nbttagcompound);
+                return;
+            }
+            // MultiPaper end
+
             File file = File.createTempFile(player.getStringUUID() + "-", ".dat", this.playerDir);
 
             NbtIo.writeCompressed(nbttagcompound, file);
@@ -53,6 +62,9 @@ public class PlayerDataStorage {
         CompoundTag nbttagcompound = null;
 
         try {
+            nbttagcompound = MultiPaper.readPlayer(player.getStringUUID()); // MultiPaper
+
+            if (false) { // MultiPaper
             File file = new File(this.playerDir, player.getStringUUID() + ".dat");
             // Spigot Start
             boolean usingWrongFile = false;
@@ -76,12 +88,14 @@ public class PlayerDataStorage {
                 file.renameTo( new File( file.getPath() + ".offline-read" ) );
             }
             // Spigot End
+            } // MultiPaper
         } catch (Exception exception) {
             PlayerDataStorage.LOGGER.warn("Failed to load player data for {}", player.getName().getString());
         }
 
         if (nbttagcompound != null) {
             // CraftBukkit start
+            /* // MultiPlayer
             if (player instanceof ServerPlayer) {
                 CraftPlayer player1 = (CraftPlayer) player.getBukkitEntity();
                 // Only update first played if it is older than the one we have
@@ -91,6 +105,7 @@ public class PlayerDataStorage {
                 }
             }
             // CraftBukkit end
+            */ // MultiPlayer
             int i = nbttagcompound.contains("DataVersion", 3) ? nbttagcompound.getInt("DataVersion") : -1;
 
             player.load(ca.spottedleaf.dataconverter.minecraft.MCDataConverter.convertTag(ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.PLAYER, nbttagcompound, i, net.minecraft.SharedConstants.getCurrentVersion().getWorldVersion())); // Paper - replace player converter
@@ -102,6 +117,8 @@ public class PlayerDataStorage {
     // CraftBukkit start
     public CompoundTag getPlayerData(String s) {
         try {
+            if (true) return MultiPaper.readPlayer(s); // MultiPaper
+
             File file1 = new File(this.playerDir, s + ".dat");
 
             if (file1.exists()) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 77d1c8e4efdc830cd5bc9af6bef9e3c3718c78e7..8b3a5c50ecd2e9262ba3a38d85475263b31fab08 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -242,6 +242,8 @@ import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 
+import puregero.multipaper.MultiPaper; // MultiPaper
+
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
 
@@ -972,6 +974,7 @@ public final class CraftServer implements Server {
         this.loadPlugins();
         this.enablePlugins(PluginLoadOrder.STARTUP);
         this.enablePlugins(PluginLoadOrder.POSTWORLD);
+        MultiPaper.serverReloaded(); // MultiPaper
         this.getPluginManager().callEvent(new ServerLoadEvent(ServerLoadEvent.LoadType.RELOAD));
         org.spigotmc.WatchdogThread.hasStarted = true; // Paper - Disable watchdog early timeout on reload
     }
@@ -1721,6 +1724,12 @@ public final class CraftServer implements Server {
 
         message = broadcastMessageEvent.message(); // Paper - Adventure
 
+        // MultiPaper start
+        if (permission.equals(BROADCAST_CHANNEL_USERS)) {
+            MultiPaper.broadcastPacket(null, message);
+        }
+        // MultiPaper end
+
         for (CommandSender recipient : recipients) {
             recipient.sendMessage(message);
         }
@@ -2520,6 +2529,8 @@ public final class CraftServer implements Server {
 
         @Override
         public void broadcast(BaseComponent component) {
+            MultiPaper.broadcastPacket(null, component); // MultiPaper
+            
             for (Player player : CraftServer.this.getOnlinePlayers()) {
                 player.spigot().sendMessage(component);
             }
@@ -2527,6 +2538,8 @@ public final class CraftServer implements Server {
 
         @Override
         public void broadcast(BaseComponent... components) {
+            MultiPaper.broadcastPacket(null, components); // MultiPaper
+
             for (Player player : CraftServer.this.getOnlinePlayers()) {
                 player.spigot().sendMessage(components);
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 7e56d6e60f1e1bd8dbf768afcbe06addcd5c5a60..5cdb15a8377ad8c76c72979167c3fd0ee70f81ea 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -381,6 +381,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         org.spigotmc.AsyncCatcher.catchOp("chunk unload"); // Spigot
         if (this.isChunkLoaded(x, z)) {
             this.world.getChunkSource().removeRegionTicket(TicketType.PLUGIN, new ChunkPos(x, z), 0, Unit.INSTANCE); // Paper
+            this.world.getChunkSource().removeRegionTicket(TicketType.PLAYER, new ChunkPos(x, z), 0, new ChunkPos(x, z)); // MultiPaper
         }
 
         return true;
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java b/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
index 2fd69c0f915f1c3cb1c410d5dab0498f05d5c888..9b803b658153d31b1b8f8a3e74570c77a6c262b7 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
@@ -4,13 +4,28 @@ import java.util.Map;
 import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.command.SimpleCommandMap;
+import puregero.multipaper.ServersCommand;
 
 public class CraftCommandMap extends SimpleCommandMap {
 
     public CraftCommandMap(Server server) {
         super(server);
+        setDefaultCommands(); // MultiPaper
     }
 
+    // MultiPaper start
+    @Override
+    public void clearCommands() {
+        super.clearCommands();
+
+        setDefaultCommands();
+    }
+
+    private void setDefaultCommands() {
+        register("multipaper", new ServersCommand("servers"));
+    }
+    // MultiPaper end
+
     public Map<String, Command> getKnownCommands() {
         return knownCommands;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 8c8698f6e17562651fe790dc19825e428d5d0352..cc1cf821758305efa03a55b305faabcaef44c757 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -428,11 +428,14 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             name = getName();
         }
         this.getHandle().listName = name.equals(getName()) ? null : CraftChatMessage.fromStringOrNull(name);
-        for (ServerPlayer player : (List<ServerPlayer>) server.getHandle().players) {
-            if (player.getBukkitEntity().canSee(this)) {
-                player.connection.send(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.UPDATE_DISPLAY_NAME, this.getHandle()));
-            }
-        }
+        // MultiPaper start - Use sendAll
+        getHandle().getServer().getPlayerList().broadcastAll(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.UPDATE_DISPLAY_NAME, this.getHandle()));
+        // for (ServerPlayer player : (List<ServerPlayer>) server.getHandle().players) {
+        //     if (player.getBukkitEntity().canSee(this)) {
+        //         player.connection.send(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.UPDATE_DISPLAY_NAME, this.getHandle()));
+        //     }
+        // }
+        // MultiPaper end
     }
 
     private net.kyori.adventure.text.Component playerListHeader; // Paper - Adventure
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 31bbf018e3b7cafb1e186c7d00b421fb133331a3..da8ededc9341397261823330ebaa69bddf5951e4 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -220,6 +220,7 @@ import org.bukkit.inventory.meta.BookMeta;
 import org.bukkit.potion.PotionEffect;
 
 import org.bukkit.event.entity.SpawnerSpawnEvent; // Spigot
+import puregero.multipaper.MultiPaper;
 
 public class CraftEventFactory {
     public static final DamageSource MELTING = CraftDamageSource.copyOf(DamageSource.ON_FIRE);
diff --git a/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java b/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java
index 738100ffa60647790f0921cf31d5bbc2714e27dd..9c33b240d4bb01ad9eed9e5ba17458fd1374e4bf 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java
@@ -1,14 +1,10 @@
 package org.bukkit.craftbukkit.util;
 
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
+import java.io.*;
 import java.util.UUID;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public final class WorldUUID {
 
@@ -18,6 +14,38 @@ public final class WorldUUID {
     }
 
     public static UUID getUUID(File baseDir) {
+    // MultiPaper start
+        DataInputStream dis = null;
+        try {
+            dis = MultiPaper.readUid(baseDir.getName());
+            return new UUID(dis.readLong(), dis.readLong());
+        } catch (IOException ex) {
+            LOGGER.warn("Failed to read " + baseDir.getName() + "'s uid.dat, generating new random UUID", ex);
+        } finally {
+            if (dis != null) {
+                try {
+                    dis.close();
+                } catch (IOException ex) {
+                    // NOOP
+                }
+            }
+        }
+
+        UUID uuid = UUID.randomUUID();
+        try {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            DataOutputStream dos = new DataOutputStream(baos);
+            dos.writeLong(uuid.getMostSignificantBits());
+            dos.writeLong(uuid.getLeastSignificantBits());
+            MultiPaper.writeUid(baseDir.getName(), baos.toByteArray());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return uuid;
+    }
+
+    public static UUID _getUUID(File baseDir) {
+    // MultiPaper end
         File file1 = new File(baseDir, "uid.dat");
         if (file1.exists()) {
             DataInputStream dis = null;
diff --git a/src/main/java/puregero/multipaper/ChunkKey.java b/src/main/java/puregero/multipaper/ChunkKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..a905eca60fccc47d9f6c9746e760d4322ca66766
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ChunkKey.java
@@ -0,0 +1,33 @@
+package puregero.multipaper;
+
+public class ChunkKey {
+    private final String name;
+    private final int x;
+    private final int z;
+
+    public ChunkKey(String name, int x, int z) {
+        this.name = name;
+        this.x = x;
+        this.z = z;
+    }
+    
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof ChunkKey) {
+            return ((ChunkKey) other).name.equals(name)
+                    && ((ChunkKey) other).x == x
+                    && ((ChunkKey) other).z == z;
+        }
+        
+        return super.equals(other);
+    }
+    
+    @Override
+    public int hashCode() {
+        // Taken from ChunkCoordIntPair
+        int i = 1664525 * this.x + 1013904223;
+        int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+        
+        return name.hashCode() ^ i ^ j;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/DataOutputSender.java b/src/main/java/puregero/multipaper/DataOutputSender.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b042efc6942050dc290001eafc0f97f0917ce82
--- /dev/null
+++ b/src/main/java/puregero/multipaper/DataOutputSender.java
@@ -0,0 +1,30 @@
+package puregero.multipaper;
+
+import javax.annotation.Nullable;
+import java.io.*;
+import java.util.function.Consumer;
+
+public class DataOutputSender extends DataOutputStream {
+    private final MultiPaperConnection connection;
+    private final int id;
+
+    public DataOutputSender(MultiPaperConnection connection) throws IOException {
+        this(connection, (int) (Math.random() * Integer.MAX_VALUE));
+    }
+
+    public DataOutputSender(MultiPaperConnection connection, int id) throws IOException {
+        super(new ByteArrayOutputStream());
+        this.connection = connection;
+        this.id = id;
+
+        writeInt(id);
+    }
+
+    public void send(@Nullable Consumer<DataInputStream> callback) throws IOException {
+        connection.send(((ByteArrayOutputStream) out).toByteArray(), id, callback);
+    }
+
+    public int getId() {
+        return id;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/ExternalServer.java b/src/main/java/puregero/multipaper/ExternalServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a35379f75384aaf7b31d74ecbd5c801179d980b
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ExternalServer.java
@@ -0,0 +1,58 @@
+package puregero.multipaper;
+
+import java.util.ArrayList;
+import java.util.UUID;
+
+public class ExternalServer {
+    private final String name;
+    private final boolean me;
+    private int averageTickTime;
+    private double tps;
+    private long lastAlive;
+    private ArrayList<UUID> players = new ArrayList<>();
+
+    public ExternalServer(String name, boolean me) {
+        this.name = name;
+        this.me = me;
+    }
+
+    public int getAverageTickTime() {
+        return averageTickTime;
+    }
+
+    public void setAverageTickTime(int averageTickTime) {
+        this.averageTickTime = averageTickTime;
+    }
+
+    public long getLastAlive() {
+        return lastAlive;
+    }
+
+    public void setLastAlive(long lastAlive) {
+        this.lastAlive = lastAlive;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public boolean isMe() {
+        return me;
+    }
+
+    public boolean isAlive() {
+        return getLastAlive() > System.currentTimeMillis() - 2500 && getTps() > 0;
+    }
+
+    public ArrayList<UUID> getPlayers() {
+        return players;
+    }
+
+    public double getTps() {
+        return tps;
+    }
+
+    public void setTps(double tps) {
+        this.tps = tps;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
new file mode 100644
index 0000000000000000000000000000000000000000..ed6b9488b05392805c9be9255ae8caa95a284c8d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -0,0 +1,402 @@
+package puregero.multipaper;
+
+import net.kyori.adventure.text.Component;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.minecraft.Util;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.network.chat.ChatType;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundChatPacket;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.saveddata.maps.MapIndex;
+import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
+import net.minecraft.world.level.storage.DimensionDataStorage;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.entity.Player;
+
+import java.io.*;
+import java.nio.file.Files;
+import java.util.UUID;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+public class MultiPaper {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static MultiPaperConnection multiPaperConnection = null;
+    private static long last10Seconds = System.currentTimeMillis();
+    private static MultiPaperPlugin plugin = null;
+
+    public static MultiPaperConnection getConnection() {
+        if (multiPaperConnection == null) {
+            multiPaperConnection = new MultiPaperConnection();
+        }
+
+        return multiPaperConnection;
+    }
+    
+    public static void serverReloaded() {
+        plugin = new MultiPaperPlugin();
+        new MultiPaperListener(plugin);
+    }
+
+    private static void tick() {
+        if (plugin == null) {
+            plugin = new MultiPaperPlugin();
+            new MultiPaperListener(plugin);
+        }
+        
+        boolean hasBeen10Seconds = last10Seconds < System.currentTimeMillis() - 10 * 1000;
+
+        if (hasBeen10Seconds) last10Seconds = System.currentTimeMillis();
+        
+        checkIfPlayersNeedToBeMoved();
+
+        Bukkit.getWorlds().forEach(world -> {
+            DimensionDataStorage persistentData = ((CraftWorld) world).getHandle().getDataStorage();
+            synchronized (persistentData.cache) {
+                persistentData.cache.forEach((key, value) -> {
+                    if (value instanceof MapIndex || (value instanceof MapItemSavedData && hasBeen10Seconds)) {
+                        persistentData.save(key, value);
+                    }
+                });
+            }
+        });
+    }
+
+    private static void checkIfPlayersNeedToBeMoved() {
+        for (Player player : Bukkit.getOnlinePlayers()) {
+            if (player.getLastLogin() < System.currentTimeMillis() - 5 * 1000L) {
+                String server = Zone.getServer(player.getLocation());
+
+                if (server != null) {
+                    Zone.doMerge(player, server);
+                }
+            }
+        }
+    }
+
+    public static CompoundTag readChunk(ChunkPos chunkPos, ServerLevel serverLevel) throws IOException {
+        return readRegionFileNBT(serverLevel, "region", chunkPos);
+    }
+
+    public static void writeChunk(ChunkPos chunkPos, ServerLevel serverLevel, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel, "region", chunkPos, compoundTag);
+    }
+
+    public static DataInput readRegionFile(String world, String path, int cx, int cz) throws IOException {
+        if (DedicatedServer.getServer().hasStopped()) {
+            LOGGER.info("Attempted to readRegionFile " + world + "," + path + "," + cx + "," + cz + ", but server has stopped, aborting operation.");
+            return null;
+        }
+        while (true) {
+            try {
+                return getConnection().readChunk(world, path, cx, cz).get(15, TimeUnit.SECONDS);
+            } catch (InterruptedException | ExecutionException e) {
+                throw new IOException(e);
+            } catch (TimeoutException e) {
+                if (DedicatedServer.getServer().hasStopped()) {
+                    LOGGER.info("No response for readRegionFile " + world + "," + path + "," + cx + "," + cz + ", but server has stopped, aborting operation.");
+                    return null;
+                }
+                LOGGER.info("No response for readRegionFile " + world + "," + path + "," + cx + "," + cz + ", resending...");
+            }
+        }
+    }
+
+    public static void writeRegionFile(String world, String path, int cx, int cz, byte[] bytes) throws IOException {
+        getConnection().writeChunk(world, path, cx, cz, bytes);
+    }
+
+    public static CompoundTag readRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos) throws IOException {
+        DataInput in = readRegionFile(serverLevel.convertable.getLevelId(), path, chunkPos.x, chunkPos.z);
+
+        return in == null ? null : NbtIo.read(in);
+    }
+
+    public static void writeRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFile(serverLevel.convertable.getLevelId(), path, chunkPos.x, chunkPos.z, nbtToBytes(compoundTag));
+    }
+
+    public static CompoundTag readLevel(String world) throws IOException {
+        DataInput in = getConnection().readLevel(world).join();
+
+        return in == null ? null : NbtIo.readCompressed((InputStream) in);
+    }
+
+    public static void writeLevel(String world, CompoundTag compoundTag) throws IOException {
+        getConnection().writeLevel(world, nbtCompressToBytes(compoundTag));
+    }
+
+    public static String readJson(String name) throws IOException {
+        return getConnection().readJson(name).join();
+    }
+
+    public static void writeJson(String name, String json) throws IOException {
+        getConnection().writeJson(name, json);
+    }
+
+    public static CompoundTag readPlayer(String uuid) throws IOException {
+        DataInput in = getConnection().readPlayer(uuid).join();
+
+        return in == null ? null : NbtIo.readCompressed((InputStream) in);
+    }
+
+    public static void writePlayer(String uuid, CompoundTag compoundTag) throws IOException {
+        getConnection().writePlayer(uuid, nbtCompressToBytes(compoundTag));
+    }
+
+    public static void lockPlayer(String uuid) {
+        try {
+            getConnection().lockPlayer(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void releasePlayer(String uuid) {
+        try {
+            getConnection().releasePlayer(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static DataInputStream readUid(String world) throws IOException {
+        return getConnection().readUid(world).join();
+    }
+
+    public static void writeUid(String world, byte[] data) throws IOException {
+        getConnection().writeUid(world, data);
+    }
+
+    public static void willSaveChunk(World world, int cx, int cz) {
+        try {
+            getConnection().willSaveChunk(world.getName(), cx, cz);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void willSaveChunk(org.bukkit.Chunk chunk) {
+        willSaveChunk(chunk.getWorld(), chunk.getX(), chunk.getZ());
+    }
+
+    public static void notifyChunkNotSaving(ChunkPos chunkPos, ServerLevel serverLevel) {
+        try {
+            getConnection().notifyChunkNotSaving(serverLevel.convertable.getLevelId(), chunkPos.x, chunkPos.z);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void sendTickTime(long time) {
+        tick();
+        try {
+            getConnection().writeTickTime(time);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static String readAdvancements(String uuid) throws IOException {
+        return getConnection().readAdvancements(uuid).join();
+    }
+
+    public static void writeAdvancements(String uuid, String json) throws IOException {
+        getConnection().writeAdvancements(uuid, json);
+    }
+
+    public static void lockAdvancements(String uuid) {
+        try {
+            getConnection().lockAdvancements(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void releaseAdvancements(String uuid) {
+        try {
+            getConnection().releaseAdvancements(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static String readStats(String uuid) throws IOException {
+        return getConnection().readStats(uuid).join();
+    }
+
+    public static void writeStats(String uuid, String json) throws IOException {
+        getConnection().writeStats(uuid, json);
+    }
+
+    public static void lockStats(String uuid) {
+        try {
+            getConnection().lockStats(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void releaseStats(String uuid) {
+        try {
+            getConnection().releaseStats(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void broadcastPacket(Packet<?> packet) {
+        try {
+            getConnection().broadcastPacket(packet);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void broadcastPacket(UUID from, String message) {
+        if (from == null) {
+            from = Util.NIL_UUID;
+        }
+
+        for (net.minecraft.network.chat.Component component : CraftChatMessage.fromString(message)) {
+            broadcastPacket(new ClientboundChatPacket(component, from.equals(Util.NIL_UUID) ? ChatType.SYSTEM : ChatType.CHAT, from));
+        }
+    }
+
+    public static void broadcastPacket(UUID from, BaseComponent... components) {
+        if (from == null) {
+            from = Util.NIL_UUID;
+        }
+
+        ClientboundChatPacket packet = new ClientboundChatPacket(null, from.equals(Util.NIL_UUID) ? ChatType.SYSTEM : ChatType.CHAT, Util.NIL_UUID);
+        packet.components = components;
+        broadcastPacket(packet);
+    }
+
+    public static void broadcastPacket(UUID from, Component message) {
+        if (from == null) {
+            from = Util.NIL_UUID;
+        }
+
+        ClientboundChatPacket packet = new ClientboundChatPacket(null, from.equals(Util.NIL_UUID) ? ChatType.SYSTEM : ChatType.CHAT, Util.NIL_UUID);
+        packet.adventure$message = message;
+        broadcastPacket(packet);
+    }
+
+    public static void onStart() {
+        try {
+            getConnection().sendStart();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static byte[] readData(String path) {
+        if (path.contains("raids.dat")) {
+            // Don't load raids from dist
+            return null;
+        }
+        
+        try {
+            return getConnection().readData(path).join();
+        } catch (IOException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    public static void writeData(String path, CompoundTag compoundTag) throws IOException {
+        getConnection().writeData(path, nbtCompressToBytes(compoundTag));
+    }
+
+    private static byte[] nbtToBytes(CompoundTag compoundTag) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        NbtIo.write(compoundTag, (DataOutput) new DataOutputStream(buffer));
+        return buffer.toByteArray();
+    }
+
+    private static byte[] nbtCompressToBytes(CompoundTag compoundTag) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        NbtIo.writeCompressed(compoundTag, buffer);
+        return buffer.toByteArray();
+    }
+
+    public static String getBungeeCordName() throws IOException {
+        File file = new File("bungeecordname.txt");
+        if (!file.isFile()) {
+            Files.write(file.toPath(), ("server" + Double.toString(Math.random()).substring(2, 7)).getBytes());
+        }
+        return new String(Files.readAllBytes(file.toPath())).trim();
+    }
+
+    public static ExternalServer getMe() {
+        return multiPaperConnection.getServersMap().get(multiPaperConnection.getBungeeCordName());
+    }
+
+    public static Iterable<ExternalServer> getServers() {
+        return multiPaperConnection.getServersMap().values();
+    }
+
+    public static Location getPlayerLocation(UUID uuid) {
+        return multiPaperConnection.playerLocations.get(uuid);
+    }
+
+    public static int chunkDistance(Entity entity1, Entity entity2) {
+        return chunkDistance(entity1.chunkPosition().x, entity1.chunkPosition().z, entity2.chunkPosition().x, entity2.chunkPosition().z);
+    }
+
+    public static int chunkDistance(Location loc1, Location loc2) {
+        return chunkDistance(loc1.getBlockX() >> 4, loc1.getBlockZ() >> 4, loc2.getBlockX() >> 4, loc2.getBlockZ() >> 4);
+    }
+
+    public static int chunkDistance(Entity entity, LevelChunk chunk) {
+        return chunkDistance(entity.chunkPosition().x, entity.chunkPosition().z, chunk.getPos().x, chunk.getPos().z);
+    }
+
+    public static int chunkDistance(int cx1, int cz1, int cx2, int cz2) {
+        return Math.max(Math.abs(cx1 - cx2), Math.abs(cz1 - cz2));
+    }
+
+    public static boolean shouldTickEntity(ServerLevel serverLevel, Entity entity) {
+        return shouldTickChunk(serverLevel, serverLevel.getChunkIfLoaded(entity.blockPosition()));
+    }
+
+    public static boolean shouldTickChunk(ServerLevel serverLevel, LevelChunk chunk) {
+        if (chunk == null) {
+            return false;
+        }
+
+        boolean playerNearby = false;
+        
+        for (ServerPlayer player : serverLevel.players) {
+            if (chunkDistance(player, chunk) <= Bukkit.getViewDistance() * 2) {
+                playerNearby = true;
+                if (player.shouldTickEntities) {
+                    return true;
+                }
+            }
+        }
+
+        return !playerNearby;
+    }
+
+    public static void setPlayerShouldTickEntities(Player player, boolean shouldTickEntities) {
+        ((CraftPlayer) player).getHandle().shouldTickEntities = shouldTickEntities;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..ce3b0ef0554681fb287c3b1fd8f92b5c32a62b75
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -0,0 +1,709 @@
+package puregero.multipaper;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoPacket;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.*;
+import org.bukkit.Chunk;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import org.bukkit.entity.Player;
+
+import javax.annotation.Nullable;
+import java.io.*;
+import java.net.Socket;
+import java.net.SocketException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
+
+public class MultiPaperConnection extends Thread {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private Socket socket;
+    private HashMap<Integer, Request> callbacks = new HashMap<>();
+    private HashMap<String, ExternalServer> serversMap = new HashMap<>();
+    private String myName = null;
+    private WriterWorkerThread writer = new WriterWorkerThread(() -> socket);
+    public HashMap<UUID, Location> playerLocations = new HashMap<>();
+
+    public MultiPaperConnection() {
+        super("MultiPaperConnection Thread");
+        start();
+    }
+
+    public void send(byte[] bytes, int id, @Nullable Consumer<DataInputStream> callback) {
+        Request request = new Request(bytes, callback);
+        if (callback != null) {
+            callbacks.put(id, request);
+        }
+        writer.write(request);
+    }
+
+    public DataOutputSender buffer(int id) throws IOException {
+        return new DataOutputSender(this, id);
+    }
+
+    private static String getServer() {
+        try {
+            File file = new File("multipaperserver.txt");
+            if (!file.isFile()) {
+                Files.write(file.toPath(), ("localhost:35353").getBytes());
+            }
+            return new String(Files.readAllBytes(file.toPath())).trim();
+        } catch (IOException e) {
+            e.printStackTrace();
+            return "localhost:35353";
+        }
+    }
+
+    @Override
+    public void run() {
+        while (true) {
+            String server = getServer();
+            LOGGER.info("Connecting to " + server + "...");
+            String[] serverParts = server.split(":");
+            try (Socket socket = new Socket(serverParts[0], Integer.parseInt(serverParts[1]))) {
+                DataOutputStream out = new DataOutputStream(socket.getOutputStream());
+                out.writeUTF(myName = MultiPaper.getBungeeCordName());
+                
+                this.socket = socket;
+                LOGGER.info("Connected to " + server);
+
+                synchronized (socket) {
+                    // Resend requests on this new socket
+                    for (Request request : callbacks.values()) {
+                        if (request.setLastSocket(socket)) {
+                            socket.getOutputStream().write(request.getData());
+                        }
+                    }
+                }
+
+                DataInputStream in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
+                while (!socket.isClosed()) {
+                    int id = in.readInt();
+                    String command = in.readUTF();
+
+                    Request request = callbacks.remove(id);
+
+                    if (request != null) {
+                        request.getCallback().accept(in);
+                        continue;
+                    }
+
+                    // Run command(DataInputStream in);
+                    this.getClass().getMethod(command, DataInputStream.class, DataOutputSender.class).invoke(this, in, buffer(id));
+                }
+            } catch (EOFException | SocketException e) {
+                // Ignored
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            try {
+                Thread.sleep(1000);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+                return;
+            }
+        }
+    }
+
+    public void loadJson(DataInputStream in, DataOutputSender out) throws IOException {
+        String file = in.readUTF();
+        LOGGER.info("Reloading json " + file);
+        new Thread(() -> {
+            try {
+                if (DedicatedServer.getServer() == null) {
+                    return;
+                }
+
+                switch (file) {
+                    case "banned-players.json":
+                        DedicatedServer.getServer().getPlayerList().getBans().load();
+                        checkBans();
+                        break;
+                    case "banned-ips.json":
+                        DedicatedServer.getServer().getPlayerList().getIpBans().load();
+                        break;
+                    case "ops.json":
+                        DedicatedServer.getServer().getPlayerList().getOps().load();
+                        break;
+                    case "whitelist.json":
+                        DedicatedServer.getServer().getPlayerList().getWhiteList().load();
+                        break;
+                    default:
+                        throw new IllegalArgumentException("Invalid json file to load " + file);
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }).start();
+    }
+
+    private String p(long n, String s){
+        if(n != 1)return n + " " + s + "s";
+        return n + " " + s;
+    }
+    public String prettyTime(long millis){
+        long seconds = millis/1000;
+        if(seconds >= 60*60*24)
+            return p(seconds/60/60/24,"day") + " and " + p((seconds/60/60)%24,"hour");
+        if(seconds >= 60*60)
+            return p(seconds/60/60,"hour") + " and " + p((seconds/60)%60,"minute");
+        if(seconds >= 60)
+            return p(seconds/60,"minute") + " and " + p((seconds)%60,"second");
+        return p(seconds,"second");
+    }
+    private void checkBans() {
+        for (Player player : Bukkit.getOnlinePlayers()) {
+            BanEntry b = Bukkit.getBanList(BanList.Type.NAME).getBanEntry(player.getName());
+            if (b != null) {
+                ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+                    Date expire = b.getExpiration();
+                    if (expire != null) {
+                        long t = (expire.getTime() - System.currentTimeMillis());
+                        if (t < 0) return; // Ban expired
+                        player.kickPlayer("You have been banned for:\n" + b.getReason() + "\nYour ban will end in " + prettyTime(t));
+                    } else {
+                        player.kickPlayer("You have been banned for:\n" + b.getReason());
+                    }
+                }, 0, "MultiPaper-KickPlayer");
+            }
+        }
+    }
+
+    public void savePlayer(DataInputStream in, DataOutputSender out) throws IOException {
+        UUID uuid = UUID.fromString(in.readUTF());
+        CraftPlayer player = (CraftPlayer) Bukkit.getPlayer(uuid);
+        if (player != null) {
+            player.saveData();
+        }
+        out.writeUTF("wrotePlayer");
+        out.send(null);
+    }
+
+    public void saveAdvancements(DataInputStream in, DataOutputSender out) throws IOException {
+        UUID uuid = UUID.fromString(in.readUTF());
+        CraftPlayer player = (CraftPlayer) Bukkit.getPlayer(uuid);
+        if (player != null) {
+            player.getHandle().getAdvancements().save(); // Saves world/advancements
+        }
+        out.writeUTF("wroteAdvancements");
+        out.send(null);
+    }
+
+    public void saveStats(DataInputStream in, DataOutputSender out) throws IOException {
+        UUID uuid = UUID.fromString(in.readUTF());
+        CraftPlayer player = (CraftPlayer) Bukkit.getPlayer(uuid);
+        if (player != null) {
+            player.getHandle().getStats().save(); // Saves world/stats
+        }
+        out.writeUTF("wroteStats");
+        out.send(null);
+    }
+
+    public void serverInfo(DataInputStream in, DataOutputSender out) throws IOException {
+        ExternalServer server = serversMap.computeIfAbsent(in.readUTF(), key -> new ExternalServer(key, key.equals(myName)));
+        server.setAverageTickTime(in.readInt());
+        server.setLastAlive(System.currentTimeMillis());
+    }
+
+    public void broadcastPacket(DataInputStream in, DataOutputSender out) throws IOException {
+        try {
+            String className = in.readUTF();
+            int length = in.readInt();
+            ByteBuf buf = Unpooled.buffer(length, length);
+            int i;
+            while ((i = buf.writeBytes(in, length)) < length) {
+                length -= i;
+            }
+            Packet<?> packet = (Packet<?>) Class.forName(className).getConstructor(FriendlyByteBuf.class).newInstance(new FriendlyByteBuf(buf));
+            if (DedicatedServer.getServer() != null && DedicatedServer.getServer().getPlayerList() != null) {
+                DedicatedServer.getServer().getPlayerList().broadcastAllNoIntercept(packet);
+            }
+
+            if (packet instanceof ClientboundPlayerInfoPacket) {
+                PlayerInfoManager.handle((ClientboundPlayerInfoPacket) packet);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void clearData(DataInputStream in, DataOutputSender out) throws IOException {
+        String pathStr = in.readUTF();
+        File path = new File(pathStr);
+        String file = path.getName().substring(0, path.getName().length() - 4); // Remove .dat suffix
+        while (!path.getParentFile().equals(new File(".")) && !path.getParentFile().equals(path)) {
+            path = path.getParentFile();
+        }
+
+        World world = Bukkit.getWorld(path.getName());
+        if (world == null) {
+            throw new IllegalArgumentException("Unknown world '" + path.getPath() + "' in path " + pathStr);
+        }
+
+        // Clear the data from the world's data cache
+        synchronized (((CraftWorld) world).getHandle().getDataStorage().cache) {
+            ((CraftWorld) world).getHandle().getDataStorage().cache.remove(file);
+        }
+    }
+
+    public void playerList(DataInputStream in, DataOutputSender out) throws IOException {
+        serversMap.values().forEach(server -> server.getPlayers().clear());
+        playerLocations.clear();
+
+        String server;
+        while (!(server = in.readUTF()).isEmpty()) {
+            ExternalServer externalServer = serversMap.get(server);
+
+            double tps = in.readDouble();
+            if (externalServer != null) {
+                externalServer.setTps(tps);
+            }
+
+            int count = in.readInt();
+            for (int i = 0; i < count; i++) {
+                UUID uuid = new UUID(in.readLong(), in.readLong());
+                String world = in.readUTF();
+                double x = in.readDouble();
+                double y = in.readDouble();
+                double z = in.readDouble();
+                float yaw = in.readFloat();
+                float pitch = in.readFloat();
+
+                if (Bukkit.getServer() != null) {
+                    playerLocations.put(uuid, new Location(Bukkit.getWorld(world), x, y, z, yaw, pitch));
+                }
+
+                if (externalServer != null) {
+                    externalServer.getPlayers().add(uuid);
+                }
+            }
+        }
+
+        if (Bukkit.getServer() == null || MinecraftServer.getServer() == null) {
+            out.writeUTF("playerList");
+            out.writeDouble(20);
+            out.writeInt(0);
+            out.send(null);
+        } else if (!MinecraftServer.getServer().isStopped()) {
+            Collection<? extends Player> players = Bukkit.getOnlinePlayers();
+            out.writeUTF("playerList");
+            out.writeDouble(MinecraftServer.getServer().recentTps[0]);
+            out.writeInt(players.size());
+            for (Player player : players) {
+                out.writeLong(player.getUniqueId().getMostSignificantBits());
+                out.writeLong(player.getUniqueId().getLeastSignificantBits());
+                out.writeUTF(player.getWorld().getName());
+                out.writeDouble(player.getLocation().getX());
+                out.writeDouble(player.getLocation().getY());
+                out.writeDouble(player.getLocation().getZ());
+                out.writeFloat(player.getLocation().getYaw());
+                out.writeFloat(player.getLocation().getPitch());
+            }
+            out.send(null);
+        }
+
+        sendLoadedChunkList();
+    }
+
+    public void chunkData(DataInputStream in, DataOutputSender out) throws IOException {
+        int length = in.readInt();
+        in.skipBytes(length);
+        LOGGER.info("Unsolicited chunk data of length: " + length + " bytes");
+    }
+
+    public void lockedChunk(DataInputStream in, DataOutputSender out) throws IOException {
+        String locker = in.readUTF();
+        LOGGER.info("Unsolicited locked chunk with locker: " + (locker.length() == 0 ? "null" : locker));
+    }
+
+    public void start(DataInputStream in, DataOutputSender out) throws IOException {
+        if (DedicatedServer.getServer() != null && DedicatedServer.getServer().getPlayerList() != null) {
+            MultiPaper.broadcastPacket(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.ADD_PLAYER, DedicatedServer.getServer().getPlayerList().players.toArray(new ServerPlayer[0])));
+        }
+    }
+
+    public CompletableFuture<DataInputStream> readChunk(String world, String path, int cx, int cz) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        AtomicBoolean hasReturned = new AtomicBoolean(false);
+
+        Consumer<DataInputStream> callback = in -> {
+            try {
+                hasReturned.set(true);
+
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        };
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(callback);
+
+        return future;
+    }
+
+    public void writeChunk(String world, String path, int cx, int cz, byte[] data) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        DeflaterOutputStream deflateOut = new DeflaterOutputStream(baos);
+        deflateOut.write(data);
+        deflateOut.close();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeInt(baos.size());
+        out.write(baos.toByteArray());
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public CompletableFuture<DataInputStream> readLevel(String world) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readLevel");
+        out.writeUTF(world);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new ByteArrayInputStream(data)));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeLevel(String world, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeLevel");
+        out.writeUTF(world);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public CompletableFuture<String> readJson(String name) throws IOException {
+        CompletableFuture<String> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readJson");
+        out.writeUTF(name);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(new String(data, StandardCharsets.UTF_8));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeJson(String name, String json) throws IOException {
+        byte[] data = json.getBytes(StandardCharsets.UTF_8);
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeJson");
+        out.writeUTF(name);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public CompletableFuture<DataInputStream> readPlayer(String uuid) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readPlayer");
+        out.writeUTF(uuid);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new ByteArrayInputStream(data)));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writePlayer(String uuid, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writePlayer");
+        out.writeUTF(uuid);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockPlayer(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockPlayer");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void releasePlayer(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("releasePlayer");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public CompletableFuture<DataInputStream> readUid(String world) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readUid");
+        out.writeUTF(world);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new ByteArrayInputStream(data)));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeUid(String world, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeUid");
+        out.writeUTF(world);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void writeTickTime(long time) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeTickTime");
+        out.writeLong(time);
+        out.send(null);
+    }
+
+    public void willSaveChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("willSaveChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void notifyChunkNotSaving(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("chunkNotSaving");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public CompletableFuture<String> readAdvancements(String uuid) throws IOException {
+        CompletableFuture<String> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readAdvancements");
+        out.writeUTF(uuid);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(new String(data, StandardCharsets.UTF_8));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeAdvancements(String uuid, String json) throws IOException {
+        byte[] data = json.getBytes(StandardCharsets.UTF_8);
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeAdvancements");
+        out.writeUTF(uuid);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockAdvancements(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockAdvancements");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void releaseAdvancements(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("releaseAdvancements");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public CompletableFuture<String> readStats(String uuid) throws IOException {
+        CompletableFuture<String> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readStats");
+        out.writeUTF(uuid);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(new String(data, StandardCharsets.UTF_8));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeStats(String uuid, String json) throws IOException {
+        byte[] data = json.getBytes(StandardCharsets.UTF_8);
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeStats");
+        out.writeUTF(uuid);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockStats(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockStats");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void releaseStats(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("releaseStats");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void broadcastPacket(Packet<?> packet) throws IOException {
+        ByteBuf buf = Unpooled.buffer();
+        packet.write(new FriendlyByteBuf(buf));
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("broadcastPacket");
+        out.writeUTF(packet.getClass().getName());
+        out.writeInt(buf.readableBytes());
+        buf.readBytes(out, buf.readableBytes());
+        out.send(null);
+    }
+
+    public void sendStart() throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("start");
+        out.send(null);
+    }
+
+    public CompletableFuture<byte[]> readData(String path) throws IOException {
+        CompletableFuture<byte[]> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readData");
+        out.writeUTF(path);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeData(String path, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeData");
+        out.writeUTF(path);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    private void sendLoadedChunkList() throws IOException {
+        if (Bukkit.getServer() != null) {
+            List<Chunk> chunks = new ArrayList<>();
+
+            for (World world : Bukkit.getWorlds()) {
+                chunks.addAll(Arrays.asList(world.getLoadedChunks()));
+            }
+
+            DataOutputSender out = new DataOutputSender(this);
+            out.writeUTF("loadedChunkList");
+            out.writeInt(chunks.size());
+
+            for (Chunk chunk : chunks) {
+                out.writeUTF(chunk.getWorld().getName());
+                out.writeInt(chunk.getX());
+                out.writeInt(chunk.getZ());
+            }
+
+            out.send(null);
+        }
+    }
+
+    public HashMap<String, ExternalServer> getServersMap() {
+        return serversMap;
+    }
+
+    public String getBungeeCordName() {
+        return myName;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperListener.java b/src/main/java/puregero/multipaper/MultiPaperListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..0588ba8600036534fbc2bfd3aab8f2279fb39eb5
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperListener.java
@@ -0,0 +1,76 @@
+package puregero.multipaper;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.event.EventHandler;
+import org.bukkit.event.EventPriority;
+import org.bukkit.event.Listener;
+import org.bukkit.event.entity.EntityPortalEvent;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.bukkit.event.player.PlayerQuitEvent;
+import org.bukkit.event.player.PlayerTeleportEvent;
+import org.bukkit.plugin.Plugin;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+
+public class MultiPaperListener implements Listener {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private static HashSet<Player> kickedPlayers = new HashSet<>();
+
+    private final Plugin plugin;
+
+    public MultiPaperListener(Plugin plugin) {
+        this.plugin = plugin;
+        Bukkit.getPluginManager().registerEvents(this, plugin);
+    }
+    
+    @EventHandler(priority = EventPriority.LOWEST)
+    public void onPlayerQuit(PlayerQuitEvent e) {
+        if (!kickedPlayers.remove(e.getPlayer())) {
+            willSaveChunks(e.getPlayer());
+        }
+    }
+
+    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
+    public void onPlayerQuit(PlayerKickEvent e) {
+        willSaveChunks(e.getPlayer());
+        kickedPlayers.add(e.getPlayer());
+    }
+
+    /**
+     * Mark the loaded chunks around the player as will be saved
+     * @param player Player to mark the chunks around
+     */
+    private void willSaveChunks(Player player) {
+        Zone zone = new Zone(player.getWorld(), player.getLocation().getBlockX() >> 4, player.getLocation().getBlockZ() >> 4);
+        zone.forEach(MultiPaper::willSaveChunk);
+    }
+    
+    private static final List<PlayerTeleportEvent.TeleportCause> teleportCauseCanMoveServers = Arrays.asList(
+            PlayerTeleportEvent.TeleportCause.COMMAND,
+            PlayerTeleportEvent.TeleportCause.PLUGIN,
+            PlayerTeleportEvent.TeleportCause.SPECTATE
+    );
+    
+    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
+    public void onTeleport(PlayerTeleportEvent e) {
+        if ((e.getTo().getWorld() != e.getFrom().getWorld() || e.getTo().distanceSquared(e.getFrom()) > 16 * 16)
+                && teleportCauseCanMoveServers.contains(e.getCause())) {
+            Bukkit.getScheduler().runTaskLater(plugin, () -> Zone.checkIfShouldMerge(e.getPlayer()), 0);
+        }
+    }
+    
+    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
+    public void onEntityPortal(EntityPortalEvent e) {
+        String server = Zone.getServer(e.getTo());
+        if (server != null) {
+            LOGGER.info("Disabling EntityPortalEvent{" + e.getEntity() + "," + e.getFrom() + " -> " + e.getTo() + "} as the other side is within " + server + "'s zone");
+            e.setCancelled(true);
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperPlugin.java b/src/main/java/puregero/multipaper/MultiPaperPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..4708cd8849aa46e9eed7f558499feaccf531f997
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperPlugin.java
@@ -0,0 +1,135 @@
+package puregero.multipaper;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Server;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.configuration.file.FileConfiguration;
+import org.bukkit.generator.BiomeProvider;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.java.JavaPluginLoader;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.InputStream;
+import java.util.List;
+import java.util.logging.Logger;
+
+public class MultiPaperPlugin implements Plugin {
+    
+    private JavaPluginLoader loader = new JavaPluginLoader(Bukkit.getServer());
+
+    @Override
+    public @NotNull File getDataFolder() {
+        return null;
+    }
+
+    @Override
+    public @NotNull PluginDescriptionFile getDescription() {
+        return new PluginDescriptionFile(getName(), Bukkit.getVersion(), getClass().getName());
+    }
+
+    @Override
+    public @NotNull FileConfiguration getConfig() {
+        return null;
+    }
+
+    @Override
+    public @Nullable InputStream getResource(@NotNull String filename) {
+        return null;
+    }
+
+    @Override
+    public void saveConfig() {
+
+    }
+
+    @Override
+    public void saveDefaultConfig() {
+
+    }
+
+    @Override
+    public void saveResource(@NotNull String resourcePath, boolean replace) {
+
+    }
+
+    @Override
+    public void reloadConfig() {
+
+    }
+
+    @Override
+    public @NotNull PluginLoader getPluginLoader() {
+        return loader;
+    }
+
+    @Override
+    public @NotNull Server getServer() {
+        return null;
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return true;
+    }
+
+    @Override
+    public void onDisable() {
+
+    }
+
+    @Override
+    public void onLoad() {
+
+    }
+
+    @Override
+    public void onEnable() {
+        
+    }
+
+    @Override
+    public boolean isNaggable() {
+        return false;
+    }
+
+    @Override
+    public void setNaggable(boolean canNag) {
+
+    }
+
+    @Override
+    public @Nullable ChunkGenerator getDefaultWorldGenerator(@NotNull String worldName, @Nullable String id) {
+        return null;
+    }
+
+    @Override
+    public @Nullable BiomeProvider getDefaultBiomeProvider(@NotNull String worldName, @Nullable String id) {
+        return null;
+    }
+
+    @Override
+    public @NotNull Logger getLogger() {
+        return null;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        return "MultiPaper";
+    }
+
+    @Override
+    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
+        return false;
+    }
+
+    @Override
+    public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String alias, @NotNull String[] args) {
+        return null;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/PlayerInfoManager.java b/src/main/java/puregero/multipaper/PlayerInfoManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..5bd73d6c1bce7c5db5379138676fc3ac0be31f65
--- /dev/null
+++ b/src/main/java/puregero/multipaper/PlayerInfoManager.java
@@ -0,0 +1,62 @@
+package puregero.multipaper;
+
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoPacket;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+
+import java.util.HashMap;
+import java.util.UUID;
+
+public class PlayerInfoManager {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private static HashMap<UUID, ClientboundPlayerInfoPacket.PlayerUpdate> playerInfos = new HashMap<>();
+
+    public static void handle(ClientboundPlayerInfoPacket packet) {
+        for (ClientboundPlayerInfoPacket.PlayerUpdate info : packet.getPlayerUpdates()) {
+            UUID uuid = info.getProfile().getId();
+
+            if (packet.getAction() == ClientboundPlayerInfoPacket.Action.ADD_PLAYER) {
+                playerInfos.put(uuid, info);
+                continue;
+            }
+
+            if (packet.getAction() == ClientboundPlayerInfoPacket.Action.REMOVE_PLAYER) {
+                CraftPlayer player = Bukkit.getServer() == null ? null : (CraftPlayer) Bukkit.getPlayer(uuid);
+                if (player != null) {
+                    DedicatedServer.getServer().getPlayerList().broadcastAll(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.ADD_PLAYER, player.getHandle()));
+                }
+
+                playerInfos.remove(uuid);
+                continue;
+            }
+
+            ClientboundPlayerInfoPacket.PlayerUpdate infoData = playerInfos.get(uuid);
+
+            if (infoData == null) {
+                continue;
+            }
+
+            if (info.latency != 0) {
+                infoData.latency = info.latency;
+            }
+
+            if (info.displayName != null) {
+                infoData.displayName = info.displayName;
+            }
+
+            if (info.gameMode != null) {
+                infoData.gameMode = info.gameMode;
+            }
+        }
+    }
+
+    public static void send(ServerPlayer player) {
+        player.connection.send(new ClientboundPlayerInfoPacket(playerInfos.values()));
+    }
+}
diff --git a/src/main/java/puregero/multipaper/Request.java b/src/main/java/puregero/multipaper/Request.java
new file mode 100644
index 0000000000000000000000000000000000000000..47f33a3aee0b5332bd4a3819d2fbe5ed23a07109
--- /dev/null
+++ b/src/main/java/puregero/multipaper/Request.java
@@ -0,0 +1,42 @@
+package puregero.multipaper;
+
+import java.io.DataInputStream;
+import java.net.Socket;
+import java.util.function.Consumer;
+
+public class Request {
+    private Socket lastSocket;
+    private final byte[] data;
+    private final Consumer<DataInputStream> callback;
+    private final long time = System.currentTimeMillis();
+
+    public Request(byte[] data, Consumer<DataInputStream> callback) {
+        this.data = data;
+        this.callback = callback;
+    }
+
+    public byte[] getData() {
+        return data;
+    }
+
+    public Consumer<DataInputStream> getCallback() {
+        return callback;
+    }
+
+    public long getTime() {
+        return time;
+    }
+
+    /**
+     * @return True if the socket is not the same as the last socket, false
+     * otherwise
+     */
+    public synchronized boolean setLastSocket(Socket socket) {
+        if (socket == lastSocket) {
+            return false;
+        }
+        
+        lastSocket = socket;
+        return true;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/ServersCommand.java b/src/main/java/puregero/multipaper/ServersCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6f77bfe0b0d11c4e312d73aa5021ebe97e0db8f
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ServersCommand.java
@@ -0,0 +1,42 @@
+package puregero.multipaper;
+
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class ServersCommand extends Command {
+    public ServersCommand(String command) {
+        super(command);
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        sender.sendMessage(ChatColor.GRAY + "[Servers] (Avg Tick Time / Tps / Player Count)");
+
+        for (ExternalServer server : MultiPaper.getServers()) {
+            String tickTime = Integer.toString(server.getAverageTickTime()) + "ms";
+            if (server.getAverageTickTime() < 40) {
+                tickTime = ChatColor.GREEN + tickTime;
+            } else if (server.getAverageTickTime() < 50) {
+                tickTime = ChatColor.YELLOW + tickTime;
+            } else {
+                tickTime = ChatColor.RED + tickTime;
+            }
+
+            String tpsString = String.format("%.1f tps", server.getTps());
+
+            String playersString = server.getPlayers().size() + " player";
+            if (server.getPlayers().size() != 1) {
+                playersString += "s";
+            }
+
+            if (!server.isAlive()) {
+                sender.sendMessage(ChatColor.DARK_GRAY + "[" + server.getName() + "] " + server.getAverageTickTime() + "ms, " + tpsString + ", " + playersString);
+            } else {
+                sender.sendMessage(ChatColor.GREEN + "[" + (server.isMe() ? ChatColor.GOLD : "") + server.getName() + ChatColor.GREEN + "] " + tickTime + ", " + tpsString + ", " + playersString);
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/ShutdownHandler.java b/src/main/java/puregero/multipaper/ShutdownHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..cac7062aa585b364dd48a26ace0df0f4373025dd
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ShutdownHandler.java
@@ -0,0 +1,63 @@
+package puregero.multipaper;
+
+import net.minecraft.server.MinecraftServer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+
+public class ShutdownHandler {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    public static void onStop() {
+        markServerAsOffline();
+        savePlayers();
+        movePlayersToDifferentServer();
+    }
+
+    private static void markServerAsOffline() {
+        MultiPaper.sendTickTime(-1);
+    }
+
+    private static void savePlayers() {
+        if (MinecraftServer.getServer().getPlayerList() != null) {
+            MinecraftServer.getServer().getPlayerList().saveAll();
+        }
+    }
+
+    private static void movePlayersToDifferentServer() {
+        HashSet<Player> moved = new HashSet<>();
+
+        for (Player player : Bukkit.getOnlinePlayers()) {
+            if (moved.contains(player)) {
+                continue;
+            }
+
+            String server = randomServer();
+
+            if (server == null) {
+                LOGGER.info("No other servers are online, disconnecting players instead");
+                return;
+            }
+
+            moved.addAll(Zone.doMerge(player, server));
+        }
+    }
+
+    private static String randomServer() {
+        List<String> servers = new ArrayList<>();
+
+        for (ExternalServer server : MultiPaper.getServers()) {
+            if (server != MultiPaper.getMe() && server.isAlive()) {
+                servers.add(server.getName());
+            }
+        }
+
+        return servers.isEmpty() ? null : servers.get((int) (Math.random() * servers.size()));
+    }
+}
diff --git a/src/main/java/puregero/multipaper/WriterWorkerThread.java b/src/main/java/puregero/multipaper/WriterWorkerThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..310dd44d77fdb51e8feea6b3d80b32ebb5dd8d29
--- /dev/null
+++ b/src/main/java/puregero/multipaper/WriterWorkerThread.java
@@ -0,0 +1,76 @@
+package puregero.multipaper;
+
+import java.net.Socket;
+import java.net.SocketException;
+import java.util.LinkedList;
+import java.util.Queue;
+import java.util.function.Supplier;
+
+public class WriterWorkerThread extends Thread {
+
+    private static final int MAX_QUEUE_SIZE = 16;
+    
+    private final Supplier<Socket> socketSupplier;
+    private final Queue<Request> queue = new LinkedList<>();
+
+    public WriterWorkerThread(Supplier<Socket> socketSupplier) {
+        super("WriterWorkerThread");
+        this.socketSupplier = socketSupplier;
+        start();
+    }
+    
+    public void write(Request request) {
+        while (true) {
+            synchronized (queue) {
+                // MultiPaperConnection gets priority in the queue, it mustn't block otherwise the connection can stall
+                if (queue.size() < MAX_QUEUE_SIZE || Thread.currentThread() instanceof MultiPaperConnection) {
+                    queue.add(request);
+                    queue.notify();
+                    return;
+                }
+            }
+
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+                return;
+            }
+        }
+    }
+    
+    public void run() {
+        Request toWrite;
+        
+        while (true) {
+            synchronized (queue) {
+                while (queue.isEmpty()) {
+                    try {
+                        queue.wait();
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                        return;
+                    }
+                }
+
+                toWrite = queue.poll();
+            }
+
+            try {
+                Socket socket = socketSupplier.get();
+
+                if (toWrite.setLastSocket(socket)) {
+                    synchronized (socket) {
+                        socket.getOutputStream().write(toWrite.getData());
+                        socket.getOutputStream().flush();
+                    }
+                }
+            } catch (NullPointerException | SocketException e) {
+                // Ignored
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+    
+}
diff --git a/src/main/java/puregero/multipaper/Zone.java b/src/main/java/puregero/multipaper/Zone.java
new file mode 100644
index 0000000000000000000000000000000000000000..794f61347671df8edb2fe2fac6673172890b1ef6
--- /dev/null
+++ b/src/main/java/puregero/multipaper/Zone.java
@@ -0,0 +1,181 @@
+package puregero.multipaper;
+
+import net.kyori.adventure.text.Component;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+import java.util.function.Consumer;
+
+public class Zone implements Iterable<Chunk> {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private static List<Consumer<Chunk>> chunkSaveHandlers = new ArrayList<>();
+
+    public static void registerChunkSaveHandler(Consumer<Chunk> handler) {
+        chunkSaveHandlers.add(handler);
+    }
+
+    public static Collection<Player> doMerge(Player centerPlayer, String server) {
+        HashSet<Player> players = new HashSet<>();
+
+        recursivelyAddPlayersInSameZone(players, centerPlayer);
+        
+        LOGGER.info("Merging " + players.size() + " players with server " + server);
+
+        for (Player player : players) {
+            ((CraftPlayer) player).getHandle().isBeingSentToAnotherServer = true;
+            player.kick(Component.text("sendto:" + server));
+
+            if (player.getLocation().isChunkLoaded()) {
+                // Attempt to unload the player's chunk first to make teleporting faster
+                Chunk c = player.getChunk();
+                ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(c::unload, 0, "Unload Chunk");
+            }
+        }
+
+        return players;
+    }
+    
+    public static boolean inSameZone(Location location1, Location location2) {
+        return MultiPaper.chunkDistance(location1, location2) <= (12 + Bukkit.getViewDistance()) * 2;
+    }
+
+    public static String getServer(Location location) {
+        for (ExternalServer server : MultiPaper.getConnection().getServersMap().values()) {
+            if (server.isAlive() && !server.isMe()) {
+                for (UUID uuid : server.getPlayers()) {
+                    Location loc = MultiPaper.getConnection().playerLocations.get(uuid);
+                    if (Bukkit.getPlayer(uuid) == null && loc != null && loc.getWorld() == location.getWorld()
+                            && Zone.inSameZone(loc, location)) {
+                        return server.getName();
+                    }
+                }
+            }
+        }
+        
+        return null;
+    }
+
+    public static boolean checkIfShouldMerge(Player player) {
+        String serverAtLocation = getServer(player.getLocation());
+        
+        if (serverAtLocation != null) {
+            Zone.doMerge(player, serverAtLocation);
+            return true;
+        }
+        
+        ExternalServer serverTo = MultiPaper.getMe();
+
+        // Find server with lowest average tick time
+        for (ExternalServer server : MultiPaper.getServers()) {
+            if (server.getAverageTickTime() < serverTo.getAverageTickTime() - 2 &&
+                    server.isAlive()) {
+                serverTo = server;
+            }
+        }
+
+        if (serverTo.isMe()) {
+            // Can't merge with yourself
+            return false;
+        }
+        
+        HashSet<Player> players = new HashSet<>();
+        
+        recursivelyAddPlayersInSameZone(players, player);
+        
+        if (players.size() == 1) {
+            Zone.doMerge(player, serverTo.getName());
+            return true;
+        }
+        
+        return false;
+    }
+
+    private static void recursivelyAddPlayersInSameZone(HashSet<Player> players, Player player) {
+        if (players.add(player)) {
+            for (Player p : player.getWorld().getPlayers()) {
+                if (p != player && inSameZone(p.getLocation(), player.getLocation())) {
+                    recursivelyAddPlayersInSameZone(players, p);
+                }
+            }
+        }
+    }
+
+    private final HashSet<Chunk> chunks = new HashSet<>();
+    private final HashSet<Player> players = new HashSet<>();
+    private final int chunkLimit;
+
+    public Zone(Chunk chunk) {
+        this(chunk, Integer.MAX_VALUE);
+    }
+
+    public Zone(Chunk chunk, int chunkLimit) {
+        this.chunkLimit = chunkLimit;
+        mapChunks(chunk);
+        mapPlayers(chunk.getWorld());
+    }
+
+    public Zone(World world, int cx, int cz) {
+        this(world, cx, cz, Integer.MAX_VALUE);
+    }
+
+    public Zone(World world, int cx, int cz, int chunkLimit) {
+        this.chunkLimit = chunkLimit;
+        mapChunks(world, cx, cz);
+        mapPlayers(world);
+    }
+
+    private void mapChunks(Chunk chunk) {
+        if (chunks.contains(chunk)) {
+            return;
+        }
+
+        if (chunk.isLoaded()) {
+            chunks.add(chunk);
+        }
+
+        if (chunks.size() > chunkLimit) {
+            return;
+        }
+
+        mapChunks(chunk.getWorld(), chunk.getX(), chunk.getZ());
+    }
+
+    private void mapChunks(World world, int cx, int cz) {
+        if (world == null) {
+            return;
+        }
+        
+        for (int dx = -4; dx <= 4; dx ++) {
+            for (int dz = -4; dz <= 4; dz ++) {
+                if (world.isChunkLoaded(cx + dx, cz + dz)) {
+                    mapChunks(world.getChunkAt(cx + dx, cz + dz));
+                }
+                
+            }
+        }
+    }
+
+    private void mapPlayers(World world) {
+        for (Player player : world.getPlayers()) {
+            if (chunks.contains(player.getChunk())) {
+                players.add(player);
+            }
+        }
+    }
+
+    @NotNull
+    @Override
+    public Iterator<Chunk> iterator() {
+        return chunks.iterator();
+    }
+}
