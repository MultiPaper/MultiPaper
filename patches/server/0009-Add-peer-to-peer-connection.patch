From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Mon, 15 Nov 2021 13:27:45 +1000
Subject: [PATCH] Add peer-to-peer connection


diff --git a/src/main/java/com/destroystokyo/paper/Metrics.java b/src/main/java/com/destroystokyo/paper/Metrics.java
index ead87ad864494358096d59a4dbe2fe2b20e3ae37..82db269d5fcb304cc3e38c14adced776303ad633 100644
--- a/src/main/java/com/destroystokyo/paper/Metrics.java
+++ b/src/main/java/com/destroystokyo/paper/Metrics.java
@@ -9,6 +9,8 @@ import org.bukkit.plugin.Plugin;
 
 import org.json.simple.JSONArray;
 import org.json.simple.JSONObject;
+import puregero.multipaper.ExternalServer;
+import puregero.multipaper.MultiPaper;
 
 import javax.net.ssl.HttpsURLConnection;
 import java.io.ByteArrayOutputStream;
@@ -606,6 +608,7 @@ public class Metrics {
                 metrics.addCustomChart(new Metrics.SimplePie("online_mode", () -> Bukkit.getOnlineMode() ? "online" : (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode() ? "bungee" : "offline"))); // Purpur
                 metrics.addCustomChart(new Metrics.SimplePie("purpur_version", () -> (org.bukkit.craftbukkit.Main.class.getPackage().getImplementationVersion() != null) ? org.bukkit.craftbukkit.Main.class.getPackage().getImplementationVersion() : "unknown")); // Purpur
                 metrics.addCustomChart(new Metrics.SimplePie("multipaper_version", () -> (CraftServer.class.getPackage().getImplementationVersion() != null) ? CraftServer.class.getPackage().getImplementationVersion() : "unknown")); // MultiPaper
+                metrics.addCustomChart(new Metrics.SimplePie("total_servers", () -> String.valueOf(MultiPaper.getConnection().getServersMap().values().stream().filter(ExternalServer::isAlive).count()))); // MultiPaper
 
                 metrics.addCustomChart(new Metrics.DrilldownPie("java_version", () -> {
                     Map<String, Map<String, Integer>> map = new HashMap<>();
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 2a70abb9e0af502885593df1e732887cd9d2ce4d..ab27b4dc9c790426b7977b20174b7a86eeec4bf0 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -62,6 +62,7 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.craftbukkit.util.Waitable; // Paper
 import org.bukkit.event.server.RemoteServerCommandEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class DedicatedServer extends MinecraftServer implements ServerInterface {
@@ -305,6 +306,8 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         }
         // Purpur end
 
+        MultiPaper.onStart(bindAddress); // MultiPaper
+
         // CraftBukkit start
         // this.setPlayerList(new DedicatedPlayerList(this, this.registries(), this.playerDataStorage)); // Spigot - moved up
         server.loadPlugins();
diff --git a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
index 44d99e89226adb6234b9405f25ac9dab9bd84297..02c4b5728844d7158385616e1792a2cdcf2275b1 100644
--- a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
+++ b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
@@ -61,7 +61,7 @@ public class ServerConnectionListener {
     private final List<ChannelFuture> channels = Collections.synchronizedList(Lists.newArrayList());
     final List<Connection> connections = Collections.synchronizedList(Lists.newArrayList());
     // Paper start - prevent blocking on adding a new network manager while the server is ticking
-    private final java.util.Queue<Connection> pending = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    public final java.util.Queue<Connection> pending = new java.util.concurrent.ConcurrentLinkedQueue<>(); // MultiPaper - make public
     private static final boolean disableFlushConsolidation = Boolean.getBoolean("Paper.disableFlushConsolidate"); // Paper
     private final void addPending() {
         Connection manager = null;
@@ -159,7 +159,7 @@ public class ServerConnectionListener {
                     ((Connection) object).setListener(new ServerHandshakePacketListenerImpl(ServerConnectionListener.this.server, (Connection) object));
                     io.papermc.paper.network.ChannelInitializeListenerHolder.callListeners(channel); // Paper
                 }
-            }).group((EventLoopGroup) lazyinitvar.get()).localAddress(address)).option(ChannelOption.AUTO_READ, false).bind().syncUninterruptibly()); // CraftBukkit // Paper
+            }).group((EventLoopGroup) lazyinitvar.get()).localAddress(address)).option(ChannelOption.AUTO_READ, true).bind().syncUninterruptibly()); // CraftBukkit // Paper // MultiPaper - set auto read to true
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
index 63cf71940f6480c593a43bd39900c50676367404..b41b49f904c09b39a198b86488ae3b8197102e0b 100644
--- a/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
@@ -10,6 +10,8 @@ import net.minecraft.network.protocol.handshake.ServerHandshakePacketListener;
 import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
 import net.minecraft.network.protocol.status.ServerStatus;
 import net.minecraft.server.MinecraftServer;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
 
 // CraftBukkit start
 import java.net.InetAddress;
@@ -39,6 +41,17 @@ public class ServerHandshakePacketListenerImpl implements ServerHandshakePacketL
 
     @Override
     public void handleIntention(ClientIntentionPacket packet) {
+        // MultiPaper start - Check if this is a MultiPaper peer connection
+        for (String part : packet.getHostName().split("\00")) {
+            if (part.equals(MultiPaper.getConnection().secret)) {
+                server.getConnection().pending.remove(connection);
+                server.getConnection().getConnections().remove(connection);
+                new ExternalServerConnection(connection.channel);
+                return;
+            }
+        }
+        // MultiPaper end
+
         this.connection.hostname = packet.hostName + ":" + packet.port; // CraftBukkit  - set hostname
         switch (packet.getIntention()) {
             case LOGIN:
diff --git a/src/main/java/puregero/multipaper/ExternalServer.java b/src/main/java/puregero/multipaper/ExternalServer.java
index 35b8352a2c798c70cfebeddd2a95dc8edf1d21d9..ceaad2b5af855905ad1b87e7308fb354304819b1 100644
--- a/src/main/java/puregero/multipaper/ExternalServer.java
+++ b/src/main/java/puregero/multipaper/ExternalServer.java
@@ -6,6 +6,7 @@ public class ExternalServer {
     private int averageTickTime;
     private double tps;
     private long lastAlive;
+    private ExternalServerConnection connection;
 
     public ExternalServer(String name, boolean me) {
         this.name = name;
@@ -47,4 +48,12 @@ public class ExternalServer {
     public void setTps(double tps) {
         this.tps = tps;
     }
+
+    public void setConnection(ExternalServerConnection connection) {
+        this.connection = connection;
+    }
+
+    public ExternalServerConnection getConnection() {
+        return connection;
+    }
 }
diff --git a/src/main/java/puregero/multipaper/ExternalServerConnection.java b/src/main/java/puregero/multipaper/ExternalServerConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..c5abd55879ea5e317806e435f7be7b10489ffa12
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ExternalServerConnection.java
@@ -0,0 +1,123 @@
+package puregero.multipaper;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.util.internal.SystemPropertyUtil;
+import net.minecraft.network.*;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.handshake.ClientIntentionPacket;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.config.MultiPaperConfiguration;
+import puregero.multipaper.externalserverprotocol.*;
+import puregero.multipaper.mastermessagingprotocol.MessageBootstrap;
+import puregero.multipaper.mastermessagingprotocol.MessageLengthDecoder;
+import puregero.multipaper.mastermessagingprotocol.MessageLengthEncoder;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+
+public class ExternalServerConnection extends ChannelInitializer<SocketChannel> implements Closeable {
+
+    private static final Logger LOGGER = LogManager.getLogger(ExternalServerConnection.class.getSimpleName());
+
+    private Channel channel;
+    public long nanoTime = 0;
+    public ExternalServer externalServer = null;
+    public final CompletableFuture<Void> onConnect = new CompletableFuture<>();
+
+    public ExternalServerConnection() {
+
+    }
+
+    public ExternalServerConnection(Channel channel) {
+        this.channel = channel;
+        setupPipeline();
+        nanoTime = System.nanoTime();
+        this.channel.writeAndFlush(new HelloPacket(MultiPaperConfiguration.get().masterConnection.myName, nanoTime, getSupportedCompressionFlags()));
+    }
+
+    public int getSupportedCompressionFlags() {
+        int supportedCompressionFlags = SetCompressionPacket.ZLIB_COMPRESSION;
+        return supportedCompressionFlags;
+    }
+
+    @Override
+    public void initChannel(SocketChannel channel) {
+        this.channel = channel;
+    }
+
+    public void sendMinecraftHandshake(String address, String secret, int port) {
+        channel.pipeline()
+                .addLast("prepender", new MessageLengthEncoder())
+                .addLast("encoder", new PacketEncoder(PacketFlow.SERVERBOUND));
+        channel.attr(Connection.ATTRIBUTE_PROTOCOL).set(ConnectionProtocol.HANDSHAKING);
+        channel.writeAndFlush(new ClientIntentionPacket(address + "\00" + secret, port, ConnectionProtocol.STATUS))
+                .addListener(future -> {
+                    if (future.isSuccess()) {
+                        setupPipeline();
+                    } else if (future.cause() != null) {
+                        future.cause().printStackTrace();
+                    }
+                });
+    }
+
+    public void setupPipeline() {
+        // Let's yeet minecraft's networking out of here
+        while (channel.pipeline().last() != null) {
+            channel.pipeline().removeLast();
+        }
+
+        // And add our own
+        if (!Boolean.getBoolean("Paper.disableFlushConsolidate")) channel.pipeline().addFirst(new io.netty.handler.flush.FlushConsolidationHandler());
+
+        com.velocitypowered.natives.compression.VelocityCompressor compressor = com.velocitypowered.natives.util.Natives.compress.get().create(-1);
+        channel.pipeline()
+                .addLast("packetsplitter", new MessageLengthDecoder())
+                .addLast("decoder", new ExternalServerPacketDecoder())
+                .addLast("packetprepender", new MessageLengthEncoder())
+                .addLast("encoder", new ExternalServerPacketEncoder())
+                .addLast("packet_handler", new ExternalServerPacketHandler(this));
+
+        // And put it onto our own event loop
+        if (MessageBootstrap.getEventLoopGroup() != channel.eventLoop().parent()) {
+            if (SystemPropertyUtil.getBoolean("multipaper.netty.useOwnEventLoop", true)) {
+                channel.deregister().addListener((ChannelFutureListener) future -> {
+                    MessageBootstrap.getEventLoopGroup().register(future.channel()).sync();
+                });
+            } else {
+                LOGGER.info("Using Minecraft's event loop");
+            }
+        }
+    }
+
+    public Channel getChannel() {
+        return channel;
+    }
+
+    @Override
+    public void close() throws IOException {
+        channel.close();
+    }
+
+    public boolean isOpen() {
+        return channel.isOpen();
+    }
+
+    public void send(ExternalServerPacket packet) {
+        if (!channel.isOpen()) {
+            new IOException("Channel is closed for " + externalServer.getName()).printStackTrace();
+        } else {
+            onConnect.thenRun(() -> {
+                if (channel.eventLoop().inEventLoop()) {
+                    channel.writeAndFlush(packet);
+                } else {
+                    channel.eventLoop().execute(() -> channel.writeAndFlush(packet));
+                }
+            });
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index 19948c5a87dd5f0da3aef064dbb6448d306395b6..48e1a3cf1d61b38eda44ba55f7591c706cb0a106 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -1,7 +1,18 @@
 package puregero.multipaper;
 
+import net.minecraft.server.MinecraftServer;
+import puregero.multipaper.externalserverprotocol.ExternalServerPacket;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.StartMessage;
 import puregero.multipaper.mastermessagingprotocol.messages.masterbound.WriteTickTimeMessage;
 
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.util.Collection;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
 public class MultiPaper {
     private static MultiPaperConnection multiPaperConnection = null;
 
@@ -16,4 +27,44 @@ public class MultiPaper {
     public static void sendTickTime(long time, double tps) {
         getConnection().send(new WriteTickTimeMessage(time, (float) tps));
     }
+
+    public static void onStart(SocketAddress bindAddress) {
+        getConnection().send(new StartMessage(
+                System.getProperty("server.address", ((InetSocketAddress) bindAddress).getAddress().getHostAddress()),
+                ((InetSocketAddress) bindAddress).getPort()
+        ));
+    }
+    
+    public static void runSync(Runnable runnable) {
+        if (MinecraftServer.getServer() == null) {
+            // Wait a bit for the server to start up
+            CompletableFuture.delayedExecutor(50, TimeUnit.MILLISECONDS).execute(() -> runSync(runnable));
+            return;
+        }
+
+        MinecraftServer.getServer().scheduleOnMain(runnable);
+    }
+
+    public static void forEachExternalServer(Consumer<ExternalServer> externalServerConsumer) {
+        getConnection().getServersMap().values().forEach(externalServerConsumer);
+    }
+
+    public static void broadcastPacketToExternalServers(ExternalServerPacket packet) {
+        broadcastPacketToExternalServers(getConnection().getServersMap().values(), packet);
+    }
+
+    public static void broadcastPacketToExternalServers(Collection<ExternalServer> externalServers, ExternalServerPacket packet) {
+        broadcastPacketToExternalServers(externalServers, () -> packet);
+    }
+
+    public static void broadcastPacketToExternalServers(Collection<ExternalServer> externalServers, Supplier<ExternalServerPacket> generatePacketIfNeeded) {
+        if (!externalServers.isEmpty()) {
+            ExternalServerPacket packet = generatePacketIfNeeded.get();
+            externalServers.forEach(externalServer -> {
+                if (!externalServer.isMe() && externalServer.getConnection() != null && externalServer.getConnection().isOpen()) {
+                    externalServer.getConnection().send(packet);
+                }
+            });
+        }
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index 784ed3647536dae2ea02494aca8a9e6840220d0c..541cb73f572c8f63d39e158e50541469343e3c2c 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -1,9 +1,15 @@
 package puregero.multipaper;
 
+import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.epoll.EpollEventLoopGroup;
+import io.netty.channel.epoll.EpollSocketChannel;
 import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import net.minecraft.server.MinecraftServer;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import puregero.multipaper.config.MultiPaperConfiguration;
@@ -12,10 +18,7 @@ import puregero.multipaper.mastermessagingprotocol.messages.masterbound.HelloMes
 import puregero.multipaper.mastermessagingprotocol.messages.masterbound.MasterBoundMessage;
 import puregero.multipaper.mastermessagingprotocol.messages.masterbound.MasterBoundProtocol;
 import puregero.multipaper.mastermessagingprotocol.messages.masterbound.PingMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ServerBoundMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ServerBoundMessageHandler;
-import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ServerBoundProtocol;
-import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ServerInfoUpdateMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.*;
 
 import java.util.Map;
 import java.util.Set;
@@ -39,6 +42,7 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
     private long lastPingReceived;
     private final Set<MasterBoundMessage> unhandledRequests = ConcurrentHashMap.newKeySet();
     private final Map<String, ExternalServer> serversMap = new ConcurrentHashMap<>();
+    public String secret;
 
     public MultiPaperConnection() {
         System.setProperty("multipaper.netty.threads", System.getProperty("multipaper.netty.threads", Integer.toString(Math.min(Runtime.getRuntime().availableProcessors(), 3))));
@@ -63,6 +67,14 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
         return channel;
     }
 
+    public ExternalServer getOrCreateServer(String name) {
+        return serversMap.computeIfAbsent(name, key -> new ExternalServer(key, key.equals(myName)));
+    }
+
+    public ExternalServer getMe() {
+        return getOrCreateServer(myName);
+    }
+
     @Override
     public void channelActive(ChannelHandlerContext ctx) {
         channel = (SocketChannel) ctx.channel();
@@ -136,4 +148,39 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
         server.setTps(message.tps);
         server.setLastAlive(System.currentTimeMillis());
     }
+
+    @Override
+    public void handle(SetSecretMessage message) {
+        secret = message.secret;
+    }
+
+    @Override
+    public void handle(ServerStartedMessage message) {
+        if (MinecraftServer.getServer() == null) {
+            return;
+        }
+
+        LOGGER.info("Connecting to external server " + message.host + ":" + message.port + "...");
+
+        ExternalServerConnection externalServerConnection = new ExternalServerConnection();
+
+        Bootstrap bootstrap = new Bootstrap();
+        bootstrap.option(ChannelOption.SO_KEEPALIVE, true);
+        bootstrap.handler(externalServerConnection);
+        bootstrap.group(MessageBootstrap.getEventLoopGroup());
+
+        if (MessageBootstrap.getEventLoopGroup() instanceof EpollEventLoopGroup) {
+            bootstrap.channel(EpollSocketChannel.class);
+        } else {
+            bootstrap.channel(NioSocketChannel.class);
+        }
+
+        bootstrap.connect(message.host, message.port).addListener(future -> {
+            if (future.isSuccess()) {
+                externalServerConnection.sendMinecraftHandshake(message.host, secret, message.port);
+            } else if (future.cause() != null) {
+                future.cause().printStackTrace();
+            }
+        });
+    }
 }
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..1a11a2f97e72936cf936d058e6d2a9183390f773
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacket.java
@@ -0,0 +1,12 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.network.FriendlyByteBuf;
+import puregero.multipaper.ExternalServerConnection;
+
+public abstract class ExternalServerPacket {
+
+    public abstract void handle(ExternalServerConnection connection);
+
+    public abstract void write(FriendlyByteBuf out);
+
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketDecoder.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketDecoder.java
new file mode 100644
index 0000000000000000000000000000000000000000..1732ed4a0efe0b1ab25cf54a85866697dd58da01
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketDecoder.java
@@ -0,0 +1,27 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import net.minecraft.network.FriendlyByteBuf;
+
+import java.util.List;
+import java.util.function.Function;
+
+public class ExternalServerPacketDecoder extends ByteToMessageDecoder {
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> list) throws Exception {
+        try {
+            int i = byteBuf.readableBytes();
+            if (i != 0) {
+                FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(byteBuf);
+                int packetId = friendlyByteBuf.readVarInt();
+                Function<FriendlyByteBuf, ExternalServerPacket> deserializer = ExternalServerPacketSerializer.getDeserializer(packetId);
+                list.add(deserializer.apply(friendlyByteBuf));
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+            throw e;
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketEncoder.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketEncoder.java
new file mode 100644
index 0000000000000000000000000000000000000000..e5537b79ec4b6329e4b5932279ea2bb4f1bd67ab
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketEncoder.java
@@ -0,0 +1,22 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToByteEncoder;
+import net.minecraft.network.FriendlyByteBuf;
+
+public class ExternalServerPacketEncoder extends MessageToByteEncoder<ExternalServerPacket> {
+    @Override
+    protected void encode(ChannelHandlerContext ctx, ExternalServerPacket msg, ByteBuf out) throws Exception {
+        try {
+            int packetId = ExternalServerPacketSerializer.getPacketId(msg);
+
+            FriendlyByteBuf byteBuf = new FriendlyByteBuf(out);
+            byteBuf.writeVarInt(packetId);
+            msg.write(byteBuf);
+        } catch (Exception e) {
+            e.printStackTrace();
+            throw e;
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketHandler.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..4b5bb154c26b6a1c95d013b571c1d0f7867f52d2
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketHandler.java
@@ -0,0 +1,46 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.SimpleChannelInboundHandler;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+
+import java.net.SocketException;
+
+public class ExternalServerPacketHandler extends SimpleChannelInboundHandler<ExternalServerPacket> {
+    private static final Logger LOGGER = LogManager.getLogger(ExternalServerPacketHandler.class.getSimpleName());
+    private final ExternalServerConnection connection;
+    private boolean disconnectedWithException = false;
+
+    public ExternalServerPacketHandler(ExternalServerConnection connection) {
+        this.connection = connection;
+    }
+
+    @Override
+    protected void channelRead0(ChannelHandlerContext ctx, ExternalServerPacket msg) {
+        msg.handle(connection);
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable throwable) {
+        if (ctx.channel().isOpen()) {
+            if (throwable instanceof SocketException) {
+                disconnectedWithException = true;
+                if (connection.externalServer != null) {
+                    LOGGER.info("External server " + connection.externalServer.getName() + " has disconnected: " + throwable.getMessage());
+                }
+            } else {
+                throwable.printStackTrace();
+            }
+        }
+    }
+
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) {
+        connection.nanoTime = 0;
+        if (!disconnectedWithException && connection.externalServer != null) {
+            LOGGER.info("External server " + connection.externalServer.getName() + " has disconnected");
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ae5d51ce27c013595462029c8237a1cffe22571
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -0,0 +1,35 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.network.FriendlyByteBuf;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Function;
+
+public class ExternalServerPacketSerializer {
+
+    private static final List<Class<? extends ExternalServerPacket>> PACKETS = new ArrayList<>();
+    private static final List<Function<FriendlyByteBuf, ExternalServerPacket>> PACKET_DESERIALIZERS = new ArrayList<>();
+    static {
+        addPacket(HelloPacket.class, HelloPacket::new);
+        addPacket(SetCompressionPacket.class, SetCompressionPacket::new);
+    }
+
+    private static void addPacket(Class<? extends ExternalServerPacket> clazz, Function<FriendlyByteBuf, ExternalServerPacket> deserializer) {
+        PACKETS.add(clazz);
+        PACKET_DESERIALIZERS.add(deserializer);
+    }
+
+    public static int getPacketId(ExternalServerPacket packet) {
+        int id = PACKETS.indexOf(packet.getClass());
+        if (id == -1) {
+            System.err.println("Unknown packet " + packet);
+            throw new IllegalArgumentException("Unknown packet " + packet);
+        }
+        return id;
+    }
+
+    public static Function<FriendlyByteBuf, ExternalServerPacket> getDeserializer(int packetId) {
+        return PACKET_DESERIALIZERS.get(packetId);
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/HelloPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/HelloPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..e375e2aba32cdc0a0d7ce7afa2c99fcf2d473281
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/HelloPacket.java
@@ -0,0 +1,108 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.channel.ChannelOutboundHandlerAdapter;
+import net.minecraft.network.FriendlyByteBuf;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.config.MultiPaperConfiguration;
+import puregero.multipaper.mastermessagingprotocol.MessageLengthEncoder;
+
+import java.net.InetSocketAddress;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+
+public class HelloPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(HelloPacket.class.getSimpleName());
+
+    private final String bungeecordName;
+    private final long nanoTime;
+    private final int supportedCompressionFlags;
+
+    public HelloPacket(String bungeecordName, int supportedCompressionFlags) {
+        this(bungeecordName, System.nanoTime(), supportedCompressionFlags);
+    }
+
+    public HelloPacket(String bungeecordName, long nanoTime, int supportedCompressionFlags) {
+        this.bungeecordName = bungeecordName;
+        this.nanoTime = nanoTime;
+        this.supportedCompressionFlags = supportedCompressionFlags;
+    }
+
+    public HelloPacket(FriendlyByteBuf in) {
+        bungeecordName = in.readUtf();
+        nanoTime = in.readLong();
+        supportedCompressionFlags = in.readVarInt();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(bungeecordName);
+        out.writeLong(nanoTime);
+        out.writeVarInt(supportedCompressionFlags);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        connection.externalServer = MultiPaper.getConnection().getOrCreateServer(bungeecordName);
+
+        ExternalServerConnection previousConnection = connection.externalServer.getConnection();
+        if (previousConnection == null || previousConnection.nanoTime < nanoTime) {
+            LOGGER.info("Connected to external server " + bungeecordName);
+            initCompression(connection);
+            connection.externalServer.setConnection(connection);
+            onConnect(connection);
+        } else if (previousConnection.nanoTime == nanoTime) {
+            // How lucky do you have to be for nano time to be the same?
+            LOGGER.info("A new connection to external server " + bungeecordName + " had the same nano time as a previous connection, resending with a new nano time...");
+            HelloPacket helloPacket = new HelloPacket(MultiPaperConfiguration.get().masterConnection.myName, connection.getSupportedCompressionFlags());
+            if (helloPacket.nanoTime == nanoTime) {
+                // Oh, nano time is broken, that's why
+                throw new RuntimeException("System.nanoTime() does not work. (Returned " + helloPacket.nanoTime + ")");
+            }
+            connection.getChannel().writeAndFlush(helloPacket);
+        } else {
+            LOGGER.info("A new connection to external server " + bungeecordName + " failed as a previous connection had a newer nano time.");
+        }
+    }
+
+    private void initCompression(ExternalServerConnection connection) {
+        int compressionType = 0;
+        ChannelOutboundHandlerAdapter compressionHandler = null;
+
+        if (MultiPaperConfiguration.get().peerConnection.compressionThreshold > 0 && !(connection.getChannel().remoteAddress() instanceof InetSocketAddress address && address.getAddress().isLoopbackAddress())) {
+            if ((supportedCompressionFlags & SetCompressionPacket.ZLIB_COMPRESSION) == SetCompressionPacket.ZLIB_COMPRESSION) {
+                compressionType = SetCompressionPacket.ZLIB_COMPRESSION;
+                compressionHandler = SetCompressionPacket.createZlibCompressionEncoder();
+            }
+        }
+
+        if (compressionHandler != null) {
+            LOGGER.info("Using compression " + compressionHandler.getClass().getSimpleName() + " with " + connection.externalServer.getName());
+            ChannelOutboundHandlerAdapter finalCompressionHandler = compressionHandler;
+            connection.getChannel().writeAndFlush(new SetCompressionPacket(compressionType)).addListener(future -> {
+                if (MultiPaperConfiguration.get().peerConnection.consolidationDelay > 0) {
+                    connection.getChannel().pipeline().addFirst("consolidator", new PacketConsolidationHandler());
+                }
+
+                connection.getChannel().pipeline()
+                        .addFirst("compresser", finalCompressionHandler)
+                        .addFirst("prepender", new MessageLengthEncoder());
+
+                // Wait for the other side to initiate the compression
+                CompletableFuture.delayedExecutor(100, TimeUnit.MILLISECONDS).execute(() -> connection.onConnect.complete(null));
+            });
+        } else {
+            connection.onConnect.complete(null);
+        }
+    }
+
+    private void onConnect(ExternalServerConnection connection) {
+        if (connection.nanoTime != nanoTime) {
+            connection.nanoTime = nanoTime;
+            connection.send(new HelloPacket(MultiPaperConfiguration.get().masterConnection.myName, nanoTime, connection.getSupportedCompressionFlags()));
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/PacketConsolidationHandler.java b/src/main/java/puregero/multipaper/externalserverprotocol/PacketConsolidationHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..d79dfe5d4f078bbd7a332c099d95813a1bff628d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/PacketConsolidationHandler.java
@@ -0,0 +1,65 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.DefaultChannelPromise;
+import puregero.multipaper.config.MultiPaperConfiguration;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+public class PacketConsolidationHandler extends ChannelDuplexHandler {
+    private final int MAX_BUFFER_SIZE = 2 * 1024 * 1024;
+    private final Executor consolidationDelay = CompletableFuture.delayedExecutor(MultiPaperConfiguration.get().peerConnection.consolidationDelay, TimeUnit.MILLISECONDS);
+    private CompletableFuture<Void> consolidationFuture;
+    private ChannelPromise bufferPromise;
+    private ByteBuf buffer;
+
+    @Override
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
+        if (buffer != null && (buffer.readableBytes() > MAX_BUFFER_SIZE || buffer.readableBytes() + ((ByteBuf) msg).readableBytes() > MAX_BUFFER_SIZE)) {
+            ctx.writeAndFlush(buffer, bufferPromise);
+            buffer = null;
+        }
+
+        if (((ByteBuf) msg).readableBytes() > MAX_BUFFER_SIZE) {
+            ctx.writeAndFlush(msg, promise);
+            return;
+        }
+
+        if (buffer == null) {
+            buffer = ctx.alloc().buffer();
+            bufferPromise = new DefaultChannelPromise(ctx.channel());
+        }
+
+        buffer.writeBytes((ByteBuf) msg);
+        bufferPromise.addListener(p -> {
+            if (p.isSuccess()) {
+                promise.setSuccess();
+            } else if (p.cause() != null) {
+                promise.setFailure(p.cause());
+            }
+        });
+    }
+
+    @Override
+    public void flush(ChannelHandlerContext ctx) throws Exception {
+        if (consolidationFuture == null || consolidationFuture.isDone()) {
+            consolidationFuture = new CompletableFuture<>();
+            consolidationDelay.execute(() -> {
+                ctx.channel().eventLoop().execute(() -> {
+                    if (buffer != null) {
+                        ctx.write(buffer, bufferPromise);
+                        ctx.flush();
+                    }
+                    buffer = null;
+                    bufferPromise = null;
+                    consolidationFuture.complete(null);
+                });
+            });
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SetCompressionPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SetCompressionPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..049dad6e8590f894095654c1acc3776e3e033f33
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SetCompressionPacket.java
@@ -0,0 +1,43 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.network.FriendlyByteBuf;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.mastermessagingprotocol.MessageLengthDecoder;
+
+public class SetCompressionPacket extends ExternalServerPacket {
+
+    public static final int ZLIB_COMPRESSION = 1;
+
+    private final int compressionType;
+
+    public SetCompressionPacket(int compressionType) {
+        this.compressionType = compressionType;
+    }
+
+    public SetCompressionPacket(FriendlyByteBuf in) {
+        compressionType = in.readVarInt();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeVarInt(compressionType);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        connection.getChannel().pipeline()
+                .addFirst("decompresser", switch (compressionType) {
+                    case ZLIB_COMPRESSION -> createZlibCompressionDecoder();
+                    default -> throw new IllegalArgumentException("Unknown compression type of " + compressionType);
+                })
+                .addFirst("splitter", new MessageLengthDecoder());
+    }
+
+    public static ZlibCompressionDecoder createZlibCompressionDecoder() {
+        return new ZlibCompressionDecoder(com.velocitypowered.natives.util.Natives.compress.get().create(-1));
+    }
+
+    public static ZlibCompressionEncoder createZlibCompressionEncoder() {
+        return new ZlibCompressionEncoder(com.velocitypowered.natives.util.Natives.compress.get().create(-1));
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ZlibCompressionDecoder.java b/src/main/java/puregero/multipaper/externalserverprotocol/ZlibCompressionDecoder.java
new file mode 100644
index 0000000000000000000000000000000000000000..4cb19c0f4b62a688ae497db26fc717d3c33bc9a0
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ZlibCompressionDecoder.java
@@ -0,0 +1,66 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import net.minecraft.network.FriendlyByteBuf;
+
+import java.util.List;
+import java.util.zip.Inflater;
+
+public class ZlibCompressionDecoder extends ByteToMessageDecoder {
+    private final Inflater inflater;
+    private final com.velocitypowered.natives.compression.VelocityCompressor compressor;
+
+    public ZlibCompressionDecoder() {
+        this(null);
+    }
+
+    public ZlibCompressionDecoder(com.velocitypowered.natives.compression.VelocityCompressor compressor) {
+        this.inflater = compressor == null ? new Inflater() : null;
+        this.compressor = compressor;
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {
+        if (byteBuf.readableBytes() != 0) {
+            FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(byteBuf);
+            int length = friendlyByteBuf.readVarInt();
+            if (length == 0) {
+                list.add(byteBuf.readBytes(byteBuf.readableBytes()));
+            } else {
+                if (this.inflater != null) {
+                    byte[] bs = new byte[friendlyByteBuf.readableBytes()];
+                    friendlyByteBuf.readBytes(bs);
+                    this.inflater.setInput(bs);
+                    byte[] cs = new byte[length];
+                    this.inflater.inflate(cs);
+                    list.add(Unpooled.wrappedBuffer(cs));
+                    this.inflater.reset();
+                    return;
+                }
+
+                ByteBuf compatibleIn = com.velocitypowered.natives.util.MoreByteBufUtils.ensureCompatible(channelHandlerContext.alloc(), this.compressor, byteBuf);
+                ByteBuf uncompressed = com.velocitypowered.natives.util.MoreByteBufUtils.preferredBuffer(channelHandlerContext.alloc(), this.compressor, length);
+                try {
+                    this.compressor.inflate(compatibleIn, uncompressed, length);
+                    list.add(uncompressed);
+                    byteBuf.clear();
+                } catch (Exception e) {
+                    uncompressed.release();
+                    throw e;
+                } finally {
+                    compatibleIn.release();
+                }
+            }
+        }
+    }
+
+    @Override
+    public void handlerRemoved0(ChannelHandlerContext ctx) {
+        if (this.compressor != null) {
+            this.compressor.close();
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ZlibCompressionEncoder.java b/src/main/java/puregero/multipaper/externalserverprotocol/ZlibCompressionEncoder.java
new file mode 100644
index 0000000000000000000000000000000000000000..1aef3d1138a66bb60d8bffc6cafa29d47419cfe9
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ZlibCompressionEncoder.java
@@ -0,0 +1,92 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToByteEncoder;
+import net.minecraft.network.FriendlyByteBuf;
+import puregero.multipaper.config.MultiPaperConfiguration;
+
+import java.util.zip.Deflater;
+
+public class ZlibCompressionEncoder extends MessageToByteEncoder<ByteBuf> {
+    private final byte[] encodeBuf;
+    private final Deflater deflater;
+    private final com.velocitypowered.natives.compression.VelocityCompressor compressor;
+
+    public ZlibCompressionEncoder() {
+        this(null);
+    }
+
+    public ZlibCompressionEncoder(com.velocitypowered.natives.compression.VelocityCompressor compressor) {
+        if (compressor == null) {
+            this.encodeBuf = new byte[8192];
+            this.deflater = new Deflater();
+        } else {
+            this.encodeBuf = null;
+            this.deflater = null;
+        }
+        this.compressor = compressor;
+    }
+
+    @Override
+    protected void encode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, ByteBuf byteBufDest) throws Exception {
+        int i = byteBuf.readableBytes();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(byteBufDest);
+        if (i < MultiPaperConfiguration.get().peerConnection.compressionThreshold) {
+            friendlyByteBuf.writeVarInt(0);
+            friendlyByteBuf.writeBytes(byteBuf);
+        } else {
+            // Paper start
+            if (this.deflater != null) {
+                byte[] bs = new byte[i];
+                byteBuf.readBytes(bs);
+                friendlyByteBuf.writeVarInt(bs.length);
+                this.deflater.setInput(bs, 0, i);
+                this.deflater.finish();
+
+                while(!this.deflater.finished()) {
+                    int j = this.deflater.deflate(this.encodeBuf);
+                    friendlyByteBuf.writeBytes(this.encodeBuf, 0, j);
+                }
+
+                this.deflater.reset();
+                return;
+            }
+
+            friendlyByteBuf.writeVarInt(i);
+            ByteBuf compatibleIn = com.velocitypowered.natives.util.MoreByteBufUtils.ensureCompatible(channelHandlerContext.alloc(), this.compressor, byteBuf);
+            try {
+                this.compressor.deflate(compatibleIn, byteBufDest);
+            } finally {
+                compatibleIn.release();
+            }
+            // Paper end
+        }
+
+    }
+
+    @Override
+    protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, ByteBuf msg, boolean preferDirect) throws Exception {
+        if (this.compressor != null) {
+            // We allocate bytes to be compressed plus 1 byte. This covers two cases:
+            //
+            // - Compression
+            //    According to https://github.com/ebiggers/libdeflate/blob/master/libdeflate.h#L103,
+            //    if the data compresses well (and we do not have some pathological case) then the maximum
+            //    size the compressed size will ever be is the input size minus one.
+            // - Uncompressed
+            //    This is fairly obvious - we will then have one more than the uncompressed size.
+            int initialBufferSize = msg.readableBytes() + 1;
+            return com.velocitypowered.natives.util.MoreByteBufUtils.preferredBuffer(ctx.alloc(), this.compressor, initialBufferSize);
+        }
+
+        return super.allocateBuffer(ctx, msg, preferDirect);
+    }
+
+    @Override
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+        if (this.compressor != null) {
+            this.compressor.close();
+        }
+    }
+}
