From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sat, 5 Mar 2022 00:29:09 +1000
Subject: [PATCH] Add generic file syncing between servers


diff --git a/build.gradle.kts b/build.gradle.kts
index 01eaa7ae1c5e726403d1b8707d0a22f8c8fdb3af..9df79d30246e7cceafab4f21f9aa02fdc915392f 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -59,6 +59,8 @@ dependencies {
     }
     // Pufferfish end
 
+    implementation("io.methvin:directory-watcher:0.15.0") // MultiPaper
+
     implementation("com.github.technove:AIR:fe3dbb4420") // Airplane - config
     implementation("org.yaml:snakeyaml:1.28")
     implementation ("me.carleslc.Simple-YAML:Simple-Yaml:1.7.2") { // Airplane - more config
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 0e0f48c196a6c819071e1a65cf32dc020b51394f..221497b42c0df533569524379a01ea4008ab8692 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -57,6 +57,7 @@ import org.apache.logging.log4j.Logger;
 import net.minecraft.SharedConstants;
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.MultiPaperConfig;
+import puregero.multipaper.MultiPaperFileSyncer;
 
 public class Main {
 
@@ -101,9 +102,11 @@ public class Main {
                 JvmProfiler.INSTANCE.start(Environment.SERVER);
             }
 
-            MultiPaperConfig.init((File) optionset.valueOf("multipaper-settings")); // MultiPaper
+            MultiPaperConfig.init((File) optionset.valueOf("multipaper-settings")); // MultiPa
             System.setProperty("bungeecordName", MultiPaperConfig.bungeeCordName); // MultiPaper - remember this property even after config reloads
             MultiPaper.getConnection(); // MultiPaper - start connection
+            MultiPaperFileSyncer.init(); // MultiPaper
+            MultiPaperConfig.init((File) optionset.valueOf("multipaper-settings")); // MultiPaper - reload the config incase it was changed during the sync
 
             Bootstrap.bootStrap();
             Bootstrap.validate();
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 868e1f664b6f0e906b6fcc6a37d01aba892fac5d..f6bf803a340d255c0fc7cd09edb313862d4267d2 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -187,6 +187,7 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.MultiPaperExternalBlocksHandler;
+import puregero.multipaper.MultiPaperFileSyncer;
 import puregero.multipaper.externalserverprotocol.DifficultyUpdatePacket;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements CommandSource, AutoCloseable {
@@ -1100,6 +1101,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper start - move final shutdown items here
         LOGGER.info("Flushing Chunk IO");
         com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.close(true, true); // Paper
+        LOGGER.info("Closing MultiPaper File Syncer"); // MultiPaper
+        MultiPaperFileSyncer.onStop().join(); // MultiPaper
         LOGGER.info("Closing Thread Pool");
         Util.shutdownExecutors(); // Paper
         LOGGER.info("Closing Server");
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index b8fb7e282a62b4448beede1efb5cd95e25997e7c..3f770e4bf79673c19d78afa792a0fc6e56ffb9a2 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -29,10 +29,13 @@ import org.bukkit.World;
 import org.bukkit.craftbukkit.CraftWorld;
 import puregero.multipaper.externalserverprotocol.*;
 import puregero.multipaper.mastermessagingprotocol.MessageBootstrap;
+import puregero.multipaper.mastermessagingprotocol.datastream.InboundDataStream;
 import puregero.multipaper.mastermessagingprotocol.messages.masterbound.*;
 import puregero.multipaper.mastermessagingprotocol.messages.serverbound.*;
 
 import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
@@ -415,4 +418,44 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
     public void handle(ShutdownMessage message) {
         Bukkit.shutdown();
     }
+
+    @Override
+    public void handle(FileContentMessage message) {
+        File file = new File(message.path);
+        File fileTemp;
+        if (file.getParentFile() != null) {
+            file.getParentFile().mkdirs();
+            fileTemp = new File(file.getParentFile(), "." + file.getName() + "." + Double.toString(Math.random()).substring(2, 7) + ".tmp");
+        } else {
+            fileTemp = new File("." + file.getName() + "." + Double.toString(Math.random()).substring(2, 7) + ".tmp");
+        }
+
+        try {
+            InboundDataStream dataStream = MultiPaper.getConnection().getDataStreamManager().createInboundDataStream(MultiPaper.getConnection().getChannel(), message.streamId);
+            dataStream.copyToAsync(new FileOutputStream(fileTemp)).addListener(future2 -> {
+                if (future2.cause() != null) {
+                    future2.cause().printStackTrace();
+                }
+
+                fileTemp.setLastModified(message.lastModified);
+
+                synchronized (MultiPaperFileSyncer.pathsBeingModified) {
+                    MultiPaperFileSyncer.pathsBeingModified.add(message.path);
+                }
+
+                if (!fileTemp.renameTo(file) && fileTemp.isFile()) {
+                    file.delete();
+                    if (!fileTemp.renameTo(file)) {
+                        LOGGER.warn("Failed to rename " + fileTemp.getPath() + " to " + file.getPath());
+                    }
+                }
+
+                if (MultiPaperConfig.logFileSyncing) {
+                    LOGGER.info("Downloaded synced file " + file.getPath() + " (" + file.length() / 1024 + "KB)");
+                }
+            });
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperFileSyncer.java b/src/main/java/puregero/multipaper/MultiPaperFileSyncer.java
new file mode 100644
index 0000000000000000000000000000000000000000..500be6f539557784b353ec12ea215c61f5cf6e65
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperFileSyncer.java
@@ -0,0 +1,297 @@
+package puregero.multipaper;
+
+import io.methvin.watcher.DirectoryWatcher;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.mastermessagingprotocol.datastream.InboundDataStream;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.DownloadFileMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.RequestFilesToSyncMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.UploadFileMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.BooleanMessageReply;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.FileContentMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.FilesToSyncMessage;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.file.*;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+public class MultiPaperFileSyncer extends Thread {
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperFileSyncer.class.getSimpleName());
+
+    public static void init() {
+        MultiPaper.getConnection().sendAndAwaitReply(new RequestFilesToSyncMessage(), FilesToSyncMessage.class)
+                .thenApply(message -> message.filesToSync)
+                .thenComposeAsync(MultiPaperFileSyncer::uploadFiles)
+                .join();
+        try {
+            Thread.sleep(50);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+        instance = new MultiPaperFileSyncer();
+    }
+
+    public MultiPaperFileSyncer() {
+        super("MultiPaperFileSyncer");
+
+        start();
+    }
+
+    private static MultiPaperFileSyncer instance;
+    public static final HashSet<String> pathsBeingModified = new HashSet<>();
+    private static final Executor DELAYED_EXECUTOR = CompletableFuture.delayedExecutor(50, TimeUnit.MILLISECONDS);
+    private final HashMap<File, CompletableFuture<Void>> queuedUploads = new HashMap<>();
+    private final HashSet<CompletableFuture<Void>> ongoingUploads = new HashSet<>();
+    private final HashSet<File> writeOnServerStop = new HashSet<>();
+
+    public static CompletableFuture<Void> onStop() {
+        if (instance != null) {
+            return instance.closeUploads();
+        }
+        return CompletableFuture.completedFuture(null);
+    }
+
+    public CompletableFuture<Void> closeUploads() {
+        synchronized (ongoingUploads) {
+            for (File file : writeOnServerStop) {
+                if (file.isFile()) {
+                    ongoingUploads.add(sendUpload(file, false));
+                }
+            }
+        }
+
+        CompletableFuture<Void> future = CompletableFuture.completedFuture(null);
+        synchronized (ongoingUploads) {
+            for (CompletableFuture<Void> ongoingUpload : ongoingUploads) {
+                future = CompletableFuture.allOf(future, ongoingUpload);
+            }
+        }
+
+        return future;
+    }
+
+    public static CompletableFuture<Void> sendUpload(File file, boolean immediatelySyncToOtherServers) {
+        try {
+            byte[] data = Files.readAllBytes(file.toPath());
+
+            return MultiPaper.getConnection().sendAndAwaitReply(new UploadFileMessage(immediatelySyncToOtherServers, file.getPath(), file.lastModified(), data), BooleanMessageReply.class).thenAccept(message -> {
+                if (MultiPaperConfig.logFileSyncing) {
+                    LOGGER.info("Uploaded " + file.getPath() + " (" + data.length / 1024 + "KB)");
+                }
+            });
+        } catch (IOException e) {
+            e.printStackTrace();
+            return CompletableFuture.completedFuture(null);
+        }
+    }
+
+    @Override
+    public void run() {
+        try {
+            DirectoryWatcher.builder()
+                    .path(Paths.get("."))
+                    .fileHashing(false)
+                    .listener(event -> {
+                        try {
+                            if (!event.isDirectory()) {
+                                switch (event.eventType()) {
+                                    case CREATE:
+                                    case MODIFY:
+                                        queueFileUpload(event.path());
+                                }
+                            }
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        }
+                    })
+                    .build()
+                    .watch();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private synchronized void queueFileUpload(Path path) {
+        File file = new File(getPathWithoutDotSlash(Paths.get(".").toAbsolutePath().relativize(path.toAbsolutePath()).toFile()));
+        if (!syncFile(file)) {
+            return;
+        }
+
+        boolean shouldWrite = false;
+        boolean immediatelySyncToOtherServers = false;
+
+        for (String toSync : MultiPaperConfig.filesToSyncInRealTime) {
+            if (file.getPath().startsWith(toSync)) {
+                shouldWrite = true;
+                immediatelySyncToOtherServers = true;
+            }
+        }
+
+        for (String toSync : MultiPaperConfig.filesToSyncOnStartup) {
+            if (file.getPath().startsWith(toSync)) {
+                shouldWrite = true;
+            }
+        }
+
+        for (String toNotSync : MultiPaperConfig.filesToNotSync) {
+            if (file.getPath().startsWith(toNotSync)) {
+                shouldWrite = false;
+            }
+        }
+
+        if (shouldWrite) {
+            synchronized (MultiPaperFileSyncer.pathsBeingModified) {
+                if (MultiPaperFileSyncer.pathsBeingModified.remove(file.getPath())) {
+                    return;
+                }
+            }
+
+            for (String toNotSync : MultiPaperConfig.filesToOnlyUploadOnServerStop) {
+                if (file.getPath().startsWith(toNotSync)) {
+                    writeOnServerStop.add(file);
+                    return;
+                }
+            }
+
+            CompletableFuture<Void> completableFuture = new CompletableFuture<>();
+            queuedUploads.put(file, completableFuture);
+            boolean finalImmediatelySyncToOtherServers = immediatelySyncToOtherServers;
+            CompletableFuture.runAsync(() -> uploadFile(completableFuture, file, finalImmediatelySyncToOtherServers), DELAYED_EXECUTOR);
+        }
+    }
+
+    private void uploadFile(CompletableFuture<Void> future, File file, boolean immediatelySyncToOtherServers) {
+        if (queuedUploads.remove(file, future) && file.isFile()) {
+            CompletableFuture<Void> uploadFuture = sendUpload(file, immediatelySyncToOtherServers);
+
+            synchronized (ongoingUploads) {
+                ongoingUploads.add(uploadFuture);
+            }
+
+            uploadFuture.thenRun(() -> {
+                synchronized (ongoingUploads) {
+                    ongoingUploads.remove(uploadFuture);
+                }
+            });
+        }
+    }
+
+    private void registerRecursively(Path path, WatchService watchService) throws IOException {
+        boolean listen = false;
+
+        for (String toSync : MultiPaperConfig.filesToSyncInRealTime) {
+            if (toSync.contains(getPathWithoutDotSlash(path.toFile()))) {
+                listen = true;
+            }
+        }
+
+        for (String toSync : MultiPaperConfig.filesToSyncOnStartup) {
+            if (toSync.contains(getPathWithoutDotSlash(path.toFile()))) {
+                listen = true;
+            }
+        }
+
+        for (String toNotSync : MultiPaperConfig.filesToNotSync) {
+            if ((getPathWithoutDotSlash(path.toFile()) + "/").contains(toNotSync)) {
+                listen = false;
+            }
+        }
+
+        if (listen) {
+            path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_MODIFY);
+
+            for (File child : path.toFile().listFiles()) {
+                if (child.isDirectory()) {
+                    registerRecursively(child.toPath(), watchService);
+                }
+            }
+        }
+    }
+
+    private static String getPathWithoutDotSlash(File file) {
+        if (file.getPath().startsWith("./")) {
+            return file.getPath().substring(2);
+        }
+
+        if (file.getPath().equals(".")) {
+            return "";
+        }
+
+        return file.getPath();
+    }
+
+    private static CompletableFuture<Void> uploadFiles(FilesToSyncMessage.FileToSync[] fileInfos) {
+        CompletableFuture<Void> future = CompletableFuture.completedFuture(null);
+        HashSet<String> paths = new HashSet<>();
+
+        for (FilesToSyncMessage.FileToSync fileInfo : fileInfos) {
+            File file = new File(fileInfo.getPath());
+            paths.add(file.getPath());
+            if (!file.isFile() || Math.abs(fileInfo.getLastModified() - file.lastModified()) > 2000) {
+                if (file.getParentFile() != null) {
+                    file.getParentFile().mkdirs();
+                }
+                future = CompletableFuture.allOf(future, MultiPaper.getConnection()
+                        .sendAndAwaitReply(new DownloadFileMessage(file.getPath()), FileContentMessage.class)
+                        .thenCompose(message -> {
+                            CompletableFuture<Void> fileDownloadedFuture = new CompletableFuture<>();
+                            try {
+                                InboundDataStream dataStream = MultiPaper.getConnection().getDataStreamManager().createInboundDataStream(MultiPaper.getConnection().getChannel(), message.streamId);
+                                dataStream.copyToAsync(new FileOutputStream(file)).addListener(future2 -> {
+                                    if (future2.cause() != null) {
+                                        future2.cause().printStackTrace();
+                                    }
+                                    if (!file.setLastModified(message.lastModified)) {
+                                        LOGGER.warn("Failed to setLastModified on file " + file);
+                                    }
+                                    if (MultiPaperConfig.logFileSyncing) {
+                                        LOGGER.info("Downloaded " + file.getPath() + " (" + file.length() / 1024 + "KB)");
+                                    }
+                                    fileDownloadedFuture.complete(null);
+                                });
+                            } catch (IOException e) {
+                                e.printStackTrace();
+                            }
+                            return fileDownloadedFuture;
+                        }));
+            }
+        }
+
+        for (String path : MultiPaperConfig.filesToSyncInRealTime) {
+            future = uploadFileIfNeededRecursively(new File(path), future, paths, true);
+        }
+
+        for (String path : MultiPaperConfig.filesToSyncOnStartup) {
+            future = uploadFileIfNeededRecursively(new File(path), future, paths, false);
+        }
+
+        return future;
+    }
+
+    private static CompletableFuture<Void> uploadFileIfNeededRecursively(File file, CompletableFuture<Void> future, HashSet<String> paths, boolean immediatelySyncToOtherServers) {
+        if (file.isDirectory()) {
+            for (File child : file.listFiles()) {
+                future = uploadFileIfNeededRecursively(child, future, paths, immediatelySyncToOtherServers);
+            }
+        } else if (syncFile(file) && !paths.contains(getPathWithoutDotSlash(file)) ) {
+            for (String toNotSync : MultiPaperConfig.filesToNotSync) {
+                if (getPathWithoutDotSlash(file).startsWith(toNotSync)) {
+                    return future;
+                }
+            }
+
+            paths.add(getPathWithoutDotSlash(file));
+            return CompletableFuture.allOf(future, sendUpload(new File(getPathWithoutDotSlash(file)), immediatelySyncToOtherServers));
+        }
+        return future;
+    }
+
+    private static boolean syncFile(File file) {
+        return file.isFile() && !file.getName().toLowerCase(Locale.ROOT).endsWith(".tmp") && !file.getName().toLowerCase(Locale.ROOT).endsWith(".hprof") && !file.getName().endsWith("~") && !file.getName().toLowerCase(Locale.ROOT).startsWith(".");
+    }
+}
