From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Tue, 16 Nov 2021 19:23:16 +1000
Subject: [PATCH] Add chunk syncing


diff --git a/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java
index 7bab31a312463cc963d9621cdc543a281459bd32..7d49a0bdb11afd8616a97d6c7f043f9d2b0ce073 100644
--- a/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java
+++ b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java
@@ -42,6 +42,12 @@ public class QueuedChangesMapLong2Object<V> {
         return this.updatingMap.remove(k);
     }
 
+    // MultiPaper start
+    public boolean isQueuedToRemove(final long k) {
+        return this.queuedChanges.get(k) == REMOVED;
+    }
+    // MultiPaper end
+
     public V getUpdating(final long k) {
         return this.updatingMap.get(k);
     }
diff --git a/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java b/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java
index 0b7a2b0ead4f3bc07bfd9a38c2b7cf024bd140c6..4295125018c898897bc59c1619d40002ffd4bea0 100644
--- a/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java
+++ b/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java
@@ -22,7 +22,7 @@ import java.util.function.BooleanSupplier;
 
 public final class LightQueue {
 
-    protected final Long2ObjectOpenHashMap<ChunkTasks> chunkTasks = new Long2ObjectOpenHashMap<>();
+    public final Long2ObjectOpenHashMap<ChunkTasks> chunkTasks = new Long2ObjectOpenHashMap<>(); // MultiPaper - make public
     protected final StarLightInterface manager;
     protected final ServerLevel world;
 
@@ -31,6 +31,18 @@ public final class LightQueue {
         this.world = ((ServerLevel)manager.getWorld());
     }
 
+    // MultiPaper start - get Chunk on lighting complete
+    public CompletableFuture<Void> getChunkFuture(final ChunkPos chunkPos) {
+        ChunkTasks tasks = chunkTasks.get(chunkPos.longKey);
+
+        if (tasks == null) {
+            return CompletableFuture.completedFuture(null);
+        }
+
+        return tasks.onComplete;
+    }
+    // MultiPaper end - get Chunk on lighting complete
+
     public void lowerPriority(final int chunkX, final int chunkZ, final PrioritisedExecutor.Priority priority) {
         final ChunkTasks task;
         synchronized (this) {
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index 830d863cd9665d58875bfa5ca2bcd22f89ab2d49..1ca2579d59874fbeb78e2f4a82e77c62562ed428 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -2,7 +2,6 @@ package io.papermc.paper.chunk.system.scheduling;
 
 import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
 import ca.spottedleaf.concurrentutil.map.SWMRLong2ObjectHashTable;
-import co.aikar.timings.Timing;
 import com.google.common.collect.ImmutableList;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
@@ -33,8 +32,6 @@ import net.minecraft.server.level.TicketType;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.util.Unit;
 import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.chunk.ChunkAccess;
-import net.minecraft.world.level.chunk.ChunkStatus;
 import org.bukkit.plugin.Plugin;
 import org.slf4j.Logger;
 import java.io.IOException;
@@ -801,7 +798,7 @@ public final class ChunkHolderManager {
 
     final ReferenceLinkedOpenHashSet<NewChunkHolder> unloadQueue = new ReferenceLinkedOpenHashSet<>();
 
-    private void removeChunkHolder(final NewChunkHolder holder) {
+    public void removeChunkHolder(final NewChunkHolder holder) { // MultiPaper - make public (unsafe method, do not use!!!)
         holder.killed = true;
         holder.vanillaChunkHolder.onChunkRemove();
         this.autoSaveQueue.remove(holder);
@@ -900,6 +897,65 @@ public final class ChunkHolderManager {
         }
     }
 
+    // MultiPaper start
+    public void unloadChunkNowNoSave(NewChunkHolder chunkHolder) {
+        TickThread.ensureTickThread("Cannot unload chunks off-main");
+
+        if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
+            throw new IllegalStateException("Cannot unload chunks recursively");
+        }
+        if (this.ticketLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot hold ticket update lock while calling processUnloads");
+        }
+        if (this.taskScheduler.schedulingLock.isHeldByCurrentThread()) {
+            throw new IllegalStateException("Cannot hold scheduling lock while calling processUnloads");
+        }
+
+        NewChunkHolder.UnloadState state;
+
+        this.ticketLock.lock();
+        try {
+            this.taskScheduler.schedulingLock.lock();
+            try {
+                state = chunkHolder.unloadStage1();
+                if (state == null) {
+                    // can unload immediately
+                    this.removeChunkHolder(chunkHolder);
+                    return;
+                }
+            } finally {
+                this.taskScheduler.schedulingLock.unlock();
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+
+        final Boolean before = this.blockTicketUpdates();
+        try {
+            chunkHolder.unloadStage2(state, true);
+        } finally {
+            this.unblockTicketUpdates(before);
+        }
+
+        this.ticketLock.lock();
+        try {
+            this.taskScheduler.schedulingLock.lock();
+            try {
+                if (chunkHolder.unloadStage3()) {
+                    this.removeChunkHolder(chunkHolder);
+                } else {
+                    // add cooldown so the next unload check is not immediately next tick
+                    this.addTicketAtLevel(TicketType.UNLOAD_COOLDOWN, chunkHolder.chunkX, chunkHolder.chunkZ, MAX_TICKET_LEVEL, Unit.INSTANCE);
+                }
+            } finally {
+                this.taskScheduler.schedulingLock.unlock();
+            }
+        } finally {
+            this.ticketLock.unlock();
+        }
+    }
+    // MultiPaper end
+
     private final ThreadLocal<Boolean> BLOCK_TICKET_UPDATES = ThreadLocal.withInitial(() -> {
         return Boolean.FALSE;
     });
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
index e42eb93fd9f6f51ff5bb4b14a2304d4ffcdd8441..db60d21560d772af2c3be0cf43378aaa7b440757 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
@@ -34,12 +34,21 @@ import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.storage.ChunkSerializer;
 import net.minecraft.world.level.chunk.storage.EntityStorage;
 import org.slf4j.Logger;
+import puregero.multipaper.ExternalServer;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.SubscribeChunkMessage;
+
+import javax.annotation.Nullable;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
@@ -62,6 +71,10 @@ public final class NewChunkHolder {
 
     public final ChunkTaskScheduler scheduler;
 
+    @Nullable public ExternalServer externalOwner; // MultiPaper - Chunk owner
+    public Set<ExternalServer> externalSubscribers = ConcurrentHashMap.newKeySet(); // MultiPaper - Chunk subscribers
+    public boolean hasExternalLockRequest = false; // MultiPaper - Have we sent a request to lock this chunk?
+
     // load/unload state
 
     // chunk data state
@@ -427,6 +440,24 @@ public final class NewChunkHolder {
 
     private ChunkAccess currentChunk;
 
+    // MultiPaper start - listen for loading of the current chunk
+    private CompletableFuture<ChunkAccess> onCurrentChunkLoaded;
+    public CompletableFuture<ChunkAccess> onCurrentChunkLoaded() {
+        if (!this.hasGenerationTask()) {
+            if (onCurrentChunkLoaded == null || (onCurrentChunkLoaded.isDone() && onCurrentChunkLoaded.getNow(null) != currentChunk)) {
+                onCurrentChunkLoaded = CompletableFuture.completedFuture(currentChunk);
+            }
+            return onCurrentChunkLoaded;
+        }
+
+        if (onCurrentChunkLoaded == null || onCurrentChunkLoaded.isDone()) {
+            onCurrentChunkLoaded = new CompletableFuture<>();
+        }
+
+        return onCurrentChunkLoaded;
+    }
+    // MultiPaper end
+
     // generation status state
 
     /**
@@ -797,13 +828,14 @@ public final class NewChunkHolder {
         }
     }
 
-    void unloadStage2(final UnloadState state) {
+    void unloadStage2(final UnloadState state) { unloadStage2(state, false); } // MultiPaper - add option to not save chunk
+    void unloadStage2(final UnloadState state, boolean doNotSaveChunk) { // MultiPaper - add option to not save chunk
         this.unloadState = null;
         final ChunkAccess chunk = state.chunk();
         final ChunkEntitySlices entityChunk = state.entityChunk();
         final PoiChunk poiChunk = state.poiChunk();
 
-        final boolean shouldLevelChunkNotSave = (chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave);
+        final boolean shouldLevelChunkNotSave = doNotSaveChunk || (chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave); // MultiPaper - add option to not save chunk
 
         // unload chunk data
         if (chunk != null) {
@@ -820,10 +852,13 @@ public final class NewChunkHolder {
             if (chunk instanceof LevelChunk levelChunk) {
                 this.world.unload(levelChunk);
             }
+
+            MultiPaperChunkHandler.onChunkUnload(this, chunk, entityChunk); // MultiPaper
         }
 
         // unload entity data
         if (entityChunk != null) {
+            if (!doNotSaveChunk) // MultiPaper - add option to not save chunk
             this.saveEntities(entityChunk, true);
             // yes this is a hack to pass the compound tag through...
             final CompoundTag lastEntityUnload = this.lastEntityUnload;
@@ -1541,6 +1576,7 @@ public final class NewChunkHolder {
         this.currentChunk = newChunk;
         this.currentGenStatus = newStatus;
         this.lastChunkCompletion = new ChunkCompletion(newChunk, newStatus);
+        MultiPaper.getConnection().send(new SubscribeChunkMessage(world.getWorld().getName(), chunkX, chunkZ)); // MultiPaper - ensure we're subscribed to this chunk
 
         final ChunkStatus requestedGenStatus = this.requestedGenStatus;
 
@@ -1620,6 +1656,8 @@ public final class NewChunkHolder {
 
             this.scheduleNeighbours(needsScheduling, scheduleList);
         }
+
+        if (onCurrentChunkLoaded != null) onCurrentChunkLoaded.completeAsync(() -> currentChunk, world.getServer()::scheduleOnMain); // MultiPaper - listen for loading of the current chunk
     }
 
     private void scheduleNeighbours(final List<NewChunkHolder> needsScheduling, final List<ChunkProgressionTask> scheduleList) {
@@ -1833,6 +1871,7 @@ public final class NewChunkHolder {
         try {
             if (unloading) {
                 try {
+                    chunk.setUnsaved(false); // MultiPaper - set as saved before serializing
                     final ChunkSerializer.AsyncSaveData asyncSaveData = ChunkSerializer.getAsyncSaveData(this.world, chunk);
 
                     final PrioritisedExecutor.PrioritisedTask task = this.scheduler.loadExecutor.createTask(new AsyncChunkSerializeTask(this.world, chunk, asyncSaveData, this));
@@ -1841,7 +1880,7 @@ public final class NewChunkHolder {
 
                     task.queue();
 
-                    chunk.setUnsaved(false);
+                    // chunk.setUnsaved(false); // MultiPaper - set as saved before serializing
 
                     return true;
                 } catch (final ThreadDeath death) {
@@ -1852,6 +1891,7 @@ public final class NewChunkHolder {
                 }
             }
 
+            chunk.setUnsaved(false); // MultiPaper - set as saved before serializing
             final CompoundTag save = ChunkSerializer.saveChunk(this.world, chunk, null);
 
             if (unloading) {
@@ -1861,7 +1901,7 @@ public final class NewChunkHolder {
             } else {
                 RegionFileIOThread.scheduleSave(this.world, this.chunkX, this.chunkZ, save, RegionFileIOThread.RegionFileType.CHUNK_DATA);
             }
-            chunk.setUnsaved(false);
+            // chunk.setUnsaved(false); // MultiPaper - set as saved before serializing
         } catch (final ThreadDeath death) {
             throw death;
         } catch (final Throwable thr) {
diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index 314318a21b6fa9e827945d8996c6ed0f9679a4eb..76b1183ae62f7f94a8aa8b54e91973353388f8f9 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -91,6 +91,8 @@ public class FriendlyByteBuf extends ByteBuf {
 
     public static boolean hasItemSerializeEvent = false; // Purpur
 
+    public long maxNbtSize = 2097152L; // MultiPaper
+
     public FriendlyByteBuf(ByteBuf parent) {
         this.source = parent;
     }
@@ -603,7 +605,7 @@ public class FriendlyByteBuf extends ByteBuf {
 
     @Nullable
     public CompoundTag readNbt() {
-        return this.readNbt(new NbtAccounter(2097152L));
+        return this.readNbt(new NbtAccounter(maxNbtSize)); // MultiPaper
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
index 3944852921335c78a04a9dc301882ab5b152b1ed..90107814a68a401bda71d66bbec50eff6be727c0 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
@@ -16,8 +16,12 @@ public class ClientboundBlockEntityDataPacket implements Packet<ClientGamePacket
     @Nullable
     private final CompoundTag tag;
 
+    public static ClientboundBlockEntityDataPacket create(BlockEntity blockEntity, Function<BlockEntity, CompoundTag> nbtGetter, boolean sanitizeNbt) {
+        return new ClientboundBlockEntityDataPacket(blockEntity.getBlockPos(), blockEntity.getType(), sanitizeNbt ? blockEntity.sanitizeSentNbt(nbtGetter.apply(blockEntity)) : nbtGetter.apply(blockEntity)); // MultiPaper - Skip nbt sanitization when syncing between servers
+    }
+
     public static ClientboundBlockEntityDataPacket create(BlockEntity blockEntity, Function<BlockEntity, CompoundTag> nbtGetter) {
-        return new ClientboundBlockEntityDataPacket(blockEntity.getBlockPos(), blockEntity.getType(), blockEntity.sanitizeSentNbt(nbtGetter.apply(blockEntity))); // Paper - Sanitize sent data
+        return create(blockEntity, nbtGetter, true); // MultiPaper - Sanitize sent data (Paper compatibility)
     }
 
     public static ClientboundBlockEntityDataPacket create(BlockEntity blockEntity) {
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index bc46479fd0622a90fd98ac88f92b2840a22a2d04..d497283cc468daf9a35baf2be72de3b8d7d71518 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -2,12 +2,14 @@ package net.minecraft.server.level;
 
 import com.mojang.datafixers.util.Either;
 import com.mojang.datafixers.util.Pair;
+import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.List;
 import java.util.Optional;
+import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReferenceArray;
@@ -18,6 +20,7 @@ import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
@@ -40,6 +43,9 @@ import net.minecraft.world.level.lighting.LevelLightEngine;
 import net.minecraft.server.MinecraftServer;
 // CraftBukkit end
 
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+
 public class ChunkHolder {
 
     public static final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> UNLOADED_CHUNK = Either.right(ChunkHolder.ChunkLoadingFailure.UNLOADED);
@@ -57,6 +63,10 @@ public class ChunkHolder {
     private final DebugBuffer<ChunkHolder.ChunkSaveDebug> chunkToSaveHistory;
     // Paper - rewrite chunk system
     public final ChunkPos pos;
+    public boolean addChangesToPlayersOnly = false; // MultiPaper
+    private boolean broadcastingToOtherServersOnly = false; // MultiPaper
+    private boolean broadcastingToPlayersOnly = false; // MultiPaper
+    private @Nullable Set<BlockPos> blocksToBroadcastToPlayers = null; // MultiPaper
     private boolean hasChangedSections;
     private final ShortSet[] changedBlocksPerSection;
     private final BitSet blockChangedLightSectionFilter;
@@ -225,6 +235,7 @@ public class ChunkHolder {
     // Paper - rewrite chunk system
 
     public void blockChanged(BlockPos pos) {
+        if (addChangesToPlayersOnly && !MultiPaper.isChunkLocal(this.chunkMap.level.getChunkIfLoaded(pos))) { broadcastBlockToPlayersLater(pos); return; } // MultiPaper
         LevelChunk chunk = this.getSendingChunk(); // Paper - no-tick view distance
 
         if (chunk != null) {
@@ -237,6 +248,8 @@ public class ChunkHolder {
             }
 
             this.changedBlocksPerSection[i].add(SectionPos.sectionRelativePos(pos));
+
+            if (blocksToBroadcastToPlayers != null && !blocksToBroadcastToPlayers.isEmpty()) blocksToBroadcastToPlayers.remove(pos); // MultiPaper
         }
     }
 
@@ -281,8 +294,45 @@ public class ChunkHolder {
         this.chunkMap.needsChangeBroadcasting.add(this);
     }
     // Paper end - optimise chunk tick iteration
+    
+    // MultiPaper start
+    public void broadcastChangesToOtherServers(LevelChunk chunk) {
+        if (newChunkHolder.externalSubscribers.isEmpty()) return; // No point running this if no one's listening
+        broadcastingToOtherServersOnly = true;
+        broadcastChanges(chunk);
+        broadcastingToOtherServersOnly = false;
+    }
+
+    private void broadcastBlockToPlayersLater(BlockPos blockPos) {
+        if (blocksToBroadcastToPlayers == null) {
+            blocksToBroadcastToPlayers = new ObjectLinkedOpenHashSet<>();
+        }
+
+        if (blockPos instanceof BlockPos.MutableBlockPos) {
+            // Let's make it not mutable...
+            blockPos = new BlockPos(blockPos);
+        }
+
+        this.addToBroadcastMap();
+        blocksToBroadcastToPlayers.add(blockPos);
+    }
+    // MultiPaper end
 
     public void broadcastChanges(LevelChunk chunk) {
+        // MultiPaper start
+        if (!broadcastingToOtherServersOnly && blocksToBroadcastToPlayers != null && !blocksToBroadcastToPlayers.isEmpty()) {
+            // Send blocks to players that shouldn't be sent to other servers as they've already been sent to other servers
+            broadcastingToPlayersOnly = true;
+            blocksToBroadcastToPlayers.forEach(blockPos -> {
+                BlockState blockState = chunk.getLevel().getBlockState(blockPos);
+                this.broadcast(new ClientboundBlockUpdatePacket(blockPos, blockState), false);
+                this.broadcastBlockEntityIfNeeded(chunk.getLevel(), blockPos, blockState);
+            });
+            broadcastingToPlayersOnly = false;
+            blocksToBroadcastToPlayers.clear();
+        }
+        // MultiPaper end
+
         if (this.needsBroadcastChanges()) { // Paper - moved into above, other logic needs to call
             Level world = chunk.getLevel();
             int i = 0;
@@ -294,6 +344,7 @@ public class ChunkHolder {
             }
 
             this.resendLight |= i >= 64;
+            if (!broadcastingToOtherServersOnly) // MultiPaper
             if (!this.skyChangedLightSectionFilter.isEmpty() || !this.blockChangedLightSectionFilter.isEmpty()) {
                 this.broadcast(new ClientboundLightUpdatePacket(chunk.getPos(), this.lightEngine, this.skyChangedLightSectionFilter, this.blockChangedLightSectionFilter, true), !this.resendLight);
                 this.skyChangedLightSectionFilter.clear();
@@ -311,6 +362,7 @@ public class ChunkHolder {
                         BlockPos blockposition = sectionposition.relativeToBlockPos(shortset.iterator().nextShort());
                         BlockState iblockdata = world.getBlockState(blockposition);
 
+                        if (broadcastingToOtherServersOnly) broadcastBlockToPlayersLater(blockposition); // MultiPaper
                         this.broadcast(new ClientboundBlockUpdatePacket(blockposition, iblockdata), false);
                         this.broadcastBlockEntityIfNeeded(world, blockposition, iblockdata);
                     } else {
@@ -319,6 +371,7 @@ public class ChunkHolder {
 
                         this.broadcast(packetplayoutmultiblockchange, false);
                         packetplayoutmultiblockchange.runUpdates((blockposition1, iblockdata1) -> {
+                            if (broadcastingToOtherServersOnly) broadcastBlockToPlayersLater(blockposition1); // MultiPaper
                             this.broadcastBlockEntityIfNeeded(world, blockposition1, iblockdata1);
                         });
                     }
@@ -347,11 +400,20 @@ public class ChunkHolder {
             if (packet != null) {
                 this.broadcast(packet, false);
             }
+
+            if(!broadcastingToPlayersOnly) MultiPaperChunkHandler.onBlockUpdate(newChunkHolder, ClientboundBlockEntityDataPacket.create(tileentity, BlockEntity::saveWithFullMetadata, false)); // MultiPaper - sync the full block with external servers
         }
 
     }
 
     public void broadcast(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
+        // MultiPaper start - Sync blocks with external servers
+        if (!broadcastingToPlayersOnly && !(packet instanceof ClientboundBlockEntityDataPacket)) { // We handle block entities separately
+            MultiPaperChunkHandler.onBlockUpdate(newChunkHolder, packet);
+        }
+        if (broadcastingToOtherServersOnly) return; // MultiPaper
+        // MultiPaper end
+
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 8264307236e0db1581e27493a668ef9eac33d279..913fd1b12bb65513aaa75f212522ee54b3048f5c 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -969,6 +969,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             return status;
         }
 
+        if (true) return null; // MultiPaper - Don't load chunk status from the disk
+
         this.readChunk(chunkPos);
 
         return regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 0ae45cf5a084fd412305e8b2f5dabe608b4eb1c1..fa375755334e69bac98a6ec48628be6b7d25760e 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -49,6 +49,7 @@ import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import puregero.multipaper.MultiPaper;
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -770,6 +771,13 @@ public class ServerChunkCache extends ChunkSource {
                 // Paper end - optimise chunk tick iteration
                 ChunkPos chunkcoordintpair = chunk1.getPos();
 
+                // MultiPaper start - Don't tick this chunk if we don't own it
+                boolean isTicking = chunkMap.getDistanceManager().inEntityTickingRange(chunkcoordintpair.longKey);
+                if (isTicking && !holder.newChunkHolder.hasExternalLockRequest) MultiPaper.lockChunk(holder.newChunkHolder);
+                if (!isTicking && holder.newChunkHolder.hasExternalLockRequest) MultiPaper.unlockChunk(holder.newChunkHolder, chunk1, holder.newChunkHolder.getEntityChunk());
+                if (!MultiPaper.isChunkLocal(chunk1)) continue;
+                // MultiPaper end - Don't tick this chunk if we don't own it
+
                 if ((true || this.level.isNaturalSpawningAllowed(chunkcoordintpair)) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, false)) { // Paper - optimise anyPlayerCloseEnoughForSpawning // Paper - the chunk is known ticking
                     chunk1.incrementInhabitedTime(j);
                     if (flag2 && (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning || _pufferfish_spawnCountsReady.get()) && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, true)) { // Spigot // Paper - optimise anyPlayerCloseEnoughForSpawning & optimise chunk tick iteration
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index b396a329e753f42b3878736b6b14bafda02d3744..e90bdb1c0c8fd72b14af3f9bc4c9324caed77749 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -173,6 +173,8 @@ import org.bukkit.event.world.GenericGameEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -537,8 +539,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
         // CraftBukkit end
         this.players = Lists.newArrayList();
         this.entityTickList = new EntityTickList();
-        this.blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
-        this.fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
+        this.blockTicks = new LevelTicks<>(this, this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier()); // MultiPaper - add level
+        this.fluidTicks = new LevelTicks<>(this, this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier()); // MultiPaper - add level
         this.navigatingMobs = new ObjectOpenHashSet();
         this.blockEvents = new ObjectLinkedOpenHashSet();
         this.blockEventsToReschedule = new ArrayList(64);
@@ -2398,6 +2400,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 return;
             }
             // CraftBukkit end
+            // MultiPaper start - run neighbour updates later if we're handling block changes
+            if (MultiPaperChunkHandler.blockUpdateChunk != null) {
+                MCUtil.ensureMain(() -> this.updateNeighborsAt(pos, block));
+            } else
+            // MultiPaper end - run neighbour updates later if we're handling block changes
             this.updateNeighborsAt(pos, block);
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index 8950b220b9a3512cd4667beb7bdec0e82e07edc6..dab03b55325442b48875a3e6ca0169c13a9d2707 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -34,6 +34,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.storage.SectionStorage;
+import puregero.multipaper.MultiPaper;
 
 public class PoiManager extends SectionStorage<PoiSection> {
     public static final int MAX_VILLAGE_DISTANCE = 6;
@@ -412,6 +413,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
     @javax.annotation.Nullable
     @Override
     public net.minecraft.nbt.CompoundTag read(ChunkPos chunkcoordintpair) throws java.io.IOException {
+        if (true) return MultiPaper.readRegionFileNBT(world, "poi", chunkcoordintpair); // MultiPaper
         // Paper start - rewrite chunk system
         if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
             return io.papermc.paper.chunk.system.io.RegionFileIOThread.loadData(
@@ -425,6 +427,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
 
     @Override
     public void write(ChunkPos chunkcoordintpair, net.minecraft.nbt.CompoundTag nbttagcompound) throws java.io.IOException {
+        if (true) MultiPaper.writeRegionFileNBT(world, "poi", chunkcoordintpair, nbttagcompound); // MultiPaper
         // Paper start - rewrite chunk system
         if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
             io.papermc.paper.chunk.system.io.RegionFileIOThread.scheduleSave(
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index a9289072b048095330ea32d7c965e8dda61a36fc..e1960686c6ba842e96cb8395c1a140adef986a4b 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -100,6 +100,7 @@ import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
+import puregero.multipaper.MultiPaperChunkHandler;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -1046,6 +1047,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 toRemove.add(tickingblockentity); // Paper - use removeAll
                 // Spigot end
             } else if (this.shouldTickBlocksAt(tickingblockentity.getPos())) {
+                if (!MultiPaperChunkHandler.shouldTick(this, tickingblockentity.getPos())) continue; // MultiPaper - should tick
                 tickingblockentity.tick();
                 // Paper start - execute chunk tasks during tick
                 if ((this.tileTickPosition & 7) == 0) {
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index efc1bdcaf141a2c2152173439d707f50feaaf91a..6cc266091f1512e079d14aa22f55284c7f148aad 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -11,6 +11,7 @@ import net.minecraft.nbt.StringTag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientGamePacketListener;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
@@ -43,12 +44,14 @@ public abstract class BlockEntity {
     protected final BlockPos worldPosition;
     protected boolean remove;
     private BlockState blockState;
+    public final ResourceLocation minecraftKey; // MultiPaper
 
     public BlockEntity(BlockEntityType<?> type, BlockPos pos, BlockState state) {
         this.type = type;
         this.worldPosition = pos.immutable();
         this.blockState = state;
         this.persistentDataContainer = new CraftPersistentDataContainer(DATA_TYPE_REGISTRY); // Paper - always init
+        this.minecraftKey = BlockEntityType.getKey(this.type); // MultiPaper
     }
 
     public static BlockPos getPosFromTag(CompoundTag nbt) {
@@ -189,6 +192,7 @@ public abstract class BlockEntity {
     }
 
     protected static void setChanged(Level world, BlockPos pos, BlockState state) {
+        ((ServerLevel) world).getChunkSource().blockChanged(pos); // MultiPaper
         world.blockEntityChanged(pos);
         if (!state.isAir()) {
             world.updateNeighbourForOutputSignal(pos, state.getBlock());
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
index 9b2c162c362fcf6093a3bf6da715ae8f18176c82..1fca610e6c1b217c381a0befbf71342fa3ed348f 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
@@ -29,5 +29,6 @@ public class ComparatorBlockEntity extends BlockEntity {
 
     public void setOutputSignal(int outputSignal) {
         this.output = outputSignal;
+        setChanged(); // MultiPaper
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index f456ad8a74464414f69b616a48ee9a2c1cee4d90..95d65d3ac2b8def54e0e309839021a8270854541 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -2,9 +2,8 @@ package net.minecraft.world.level.block.piston;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
+
+import java.util.*;
 import java.util.Map.Entry;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -39,7 +38,6 @@ import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 // CraftBukkit start
 import com.google.common.collect.ImmutableList;
-import java.util.AbstractList;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.block.BlockPistonRetractEvent;
 import org.bukkit.event.block.BlockPistonExtendEvent;
@@ -446,6 +444,7 @@ public class PistonBaseBlock extends DirectionalBlock {
                 }
                 // Paper end - fix a variety of piston desync dupes
                 aiblockdata[j++] = iblockdata1;
+                ((ServerLevel) world).getChunkSource().blockChanged(blockposition3); // MultiPaper
             }
 
             if (retract) {
@@ -456,6 +455,7 @@ public class PistonBaseBlock extends DirectionalBlock {
                 map.remove(blockposition1);
                 world.setBlock(blockposition1, iblockdata1, 68);
                 world.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(blockposition1, iblockdata1, iblockdata3, dir, true, true));
+                ((ServerLevel) world).getChunkSource().blockChanged(blockposition1); // MultiPaper
             }
 
             BlockState iblockdata4 = Blocks.AIR.defaultBlockState();
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
index 221c5d080d55326e458c1182823d6b49224ef498..271a7c62e5f2972f9d4b7ebec029813f204d7dc5 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
@@ -9,6 +9,7 @@ import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtUtils;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
@@ -27,6 +28,7 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import puregero.multipaper.MultiPaper;
 
 public class PistonMovingBlockEntity extends BlockEntity {
     private static final int TICKS_TO_EXTEND = 2;
@@ -256,7 +258,7 @@ public class PistonMovingBlockEntity extends BlockEntity {
     }
 
     public void finalTick() {
-        if (this.level != null && (this.progressO < 1.0F || this.level.isClientSide)) {
+        if (this.level != null && (this.progressO < 1.0F || this.level.isClientSide) && !MultiPaper.isChunkExternal((ServerLevel) level, getBlockPos())) { // MultiPaper
             this.progress = 1.0F;
             this.progressO = this.progress;
             this.level.removeBlockEntity(this.worldPosition);
@@ -310,6 +312,7 @@ public class PistonMovingBlockEntity extends BlockEntity {
                 blockEntity.progress = 1.0F;
             }
 
+            blockEntity.setChanged(); // MultiPaper
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/border/WorldBorder.java b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
index 7a12a4da4864306ec6589ca81368e84718825047..d7d99d46c0614331960657bbf11f979c60ab0dd3 100644
--- a/src/main/java/net/minecraft/world/level/border/WorldBorder.java
+++ b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
@@ -14,6 +14,7 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import puregero.multipaper.MultiPaperWorldBorderHandler;
 
 public class WorldBorder {
 
@@ -31,7 +32,7 @@ public class WorldBorder {
     public static final WorldBorder.Settings DEFAULT_SETTINGS = new WorldBorder.Settings(0.0D, 0.0D, 0.2D, 5.0D, 5, 15, 5.9999968E7D, 0L, 0.0D);
     public net.minecraft.server.level.ServerLevel world; // CraftBukkit
 
-    public WorldBorder() {}
+    public WorldBorder() { listeners.add(new MultiPaperWorldBorderHandler()); } // MultiPaper - Add our own world border listener
 
     public boolean isWithinBounds(BlockPos pos) {
         return (double) (pos.getX() + 1) > this.getMinX() && (double) pos.getX() < this.getMaxX() && (double) (pos.getZ() + 1) > this.getMinZ() && (double) pos.getZ() < this.getMaxZ();
@@ -304,6 +305,7 @@ public class WorldBorder {
     }
 
     public void applySettings(WorldBorder.Settings properties) {
+        MultiPaperWorldBorderHandler.updatingWorldBorder = true; // MultiPaper
         this.setCenter(properties.getCenterX(), properties.getCenterZ());
         this.setDamagePerBlock(properties.getDamagePerBlock());
         this.setDamageSafeZone(properties.getSafeZone());
@@ -314,7 +316,7 @@ public class WorldBorder {
         } else {
             this.setSize(properties.getSize());
         }
-
+        MultiPaperWorldBorderHandler.updatingWorldBorder = false; // MultiPaper
     }
 
     private class StaticBorderExtent implements WorldBorder.BorderExtent {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index e254b2d04e4fc1dc76c26f61ea38aeb27755143f..0572c468291144616c2b73c8b49b4777da81f8d8 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -56,7 +56,7 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final LongSet EMPTY_REFERENCE_SET = new LongOpenHashSet();
     protected final ShortList[] postProcessing;
-    protected volatile boolean unsaved;
+    public volatile boolean unsaved; // MultiPaper - make public
     private volatile boolean isLightCorrect;
     protected final ChunkPos chunkPos; public final long coordinateKey; public final int locX; public final int locZ; // Paper - cache coordinate key
     private long inhabitedTime;
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 79bf9c277fe98df176113de39360fb34ad917577..d50f1eb0946875c50990390d647c8f4e30f24e01 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -8,9 +8,10 @@ import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
-import java.util.Iterator;
-import java.util.Map;
+
+import java.util.*;
 import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -23,6 +24,7 @@ import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkPacketData;
 import net.minecraft.server.level.ChunkHolder;
@@ -53,6 +55,7 @@ import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.ticks.LevelChunkTicks;
 import net.minecraft.world.ticks.TickContainerAccess;
 import org.slf4j.Logger;
+import puregero.multipaper.*;
 
 public class LevelChunk extends ChunkAccess {
 
@@ -85,8 +88,10 @@ public class LevelChunk extends ChunkAccess {
     @Nullable
     private LevelChunk.PostLoadProcessor postLoad;
     private final Int2ObjectMap<GameEventListenerRegistry> gameEventListenerRegistrySections;
-    private final LevelChunkTicks<Block> blockTicks;
-    private final LevelChunkTicks<Fluid> fluidTicks;
+    @Nullable public ListTag entitiesToLoad; // MultiPaper
+    @Nullable public ListTag blockEntitiesToLoad; // MultiPaper
+    public LevelChunkTicks<Block> blockTicks; // MultiPaper - make public and non-final
+    public LevelChunkTicks<Fluid> fluidTicks; // MultiPaper - make public and non-final
 
     // Pufferfish start - instead of using a random every time the chunk is ticked, define when lightning strikes preemptively
     private int lightningTick;
@@ -775,6 +780,12 @@ public class LevelChunk extends ChunkAccess {
 
     @Override
     public void removeBlockEntity(BlockPos pos) {
+        // MultiPaper start - allow removing a block entity on unloaded block entities
+        if (blockEntitiesToLoad != null) {
+            blockEntitiesToLoad.removeIf(tag -> pos.equals(BlockEntity.getPosFromTag((CompoundTag) tag)));
+        }
+        // MultiPaper end
+
         if (this.isInLevel()) {
             BlockEntity tileentity = (BlockEntity) this.blockEntities.remove(pos);
 
@@ -908,6 +919,7 @@ public class LevelChunk extends ChunkAccess {
 
     public void onChunkNotEntityTicking(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
         io.papermc.paper.chunk.system.ChunkSystem.onChunkNotEntityTicking(this, chunkHolder.vanillaChunkHolder);
+        if (chunkHolder.hasExternalLockRequest) MultiPaper.unlockChunk(chunkHolder, chunkHolder.getCurrentChunk(), chunkHolder.getEntityChunk());
     }
     // Paper end - new load callbacks
 
@@ -919,6 +931,7 @@ public class LevelChunk extends ChunkAccess {
         // Paper - rewrite chunk system - move into separate callback
         org.bukkit.Server server = this.level.getCraftServer();
         // Paper - rewrite chunk system - move into separate callback
+        MultiPaperChunkHandler.onChunkLoad(this); // MultiPaper
         ((ServerLevel)this.level).getChunkSource().chunkMap.playerChunkManager.onChunkLoad(this.chunkPos.x, this.chunkPos.z); // Paper - rewrite player chunk management
         if (server != null) {
             /*
@@ -994,6 +1007,7 @@ public class LevelChunk extends ChunkAccess {
 
     @Override
     public boolean isUnsaved() {
+        if (MultiPaper.isChunkExternal(this)) return false; // MultiPaper - only save if no one else owns it
         // Paper start - add dirty system to tick lists
         long gameTime = this.level.getLevelData().getGameTime();
         if (this.blockTicks.isDirty(gameTime) || this.fluidTicks.isDirty(gameTime)) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index c24b4c6a560aab2df07783b3481981deb8571a50..7f51c49c51da259c9ee3cb8983a6f8cc1bce7268 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -46,8 +46,8 @@ public class ProtoChunk extends ChunkAccess {
     private final Map<GenerationStep.Carving, CarvingMask> carvingMasks = new Object2ObjectArrayMap<>();
     @Nullable
     private BelowZeroRetrogen belowZeroRetrogen;
-    private final ProtoChunkTicks<Block> blockTicks;
-    private final ProtoChunkTicks<Fluid> fluidTicks;
+    public ProtoChunkTicks<Block> blockTicks; // MultiPaper - make public and non-final
+    public ProtoChunkTicks<Fluid> fluidTicks; // MultiPaper - make public and non-final
 
     public ProtoChunk(ChunkPos pos, UpgradeData upgradeData, LevelHeightAccessor world, Registry<Biome> biomeRegistry, @Nullable BlendingData blendingData) {
         this(pos, upgradeData, (LevelChunkSection[])null, new ProtoChunkTicks<>(), new ProtoChunkTicks<>(), world, biomeRegistry, blendingData);
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
index d4c4d37bcef14e392739d9aae9e20b7d69b05c12..4f1d9432f1b4dfbfb0bbe5b758ab97b5d82541ce 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
@@ -294,6 +294,10 @@ public class ChunkSerializer {
             object1 = new LevelChunk(world.getLevel(), chunkPos, chunkconverter, levelchunkticks, levelchunkticks1, l, achunksection, ChunkSerializer.postLoadChunk(world, nbt), blendingdata);
             ((LevelChunk)object1).setBlockNibbles(blockNibbles); // Paper - replace light impl
             ((LevelChunk)object1).setSkyNibbles(skyNibbles); // Paper - replace light impl
+            // MultiPaper start - Keep copy of entities and block entities until they're loaded
+            ((LevelChunk)object1).entitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "entities");
+            ((LevelChunk)object1).blockEntitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "block_entities");
+            // MultiPaper end
         } else {
             ProtoChunkTicks<Block> protochunkticklist = ProtoChunkTicks.load(nbt.getList("block_ticks", 10), (s) -> {
                 return BuiltInRegistries.BLOCK.getOptional(ResourceLocation.tryParse(s));
@@ -522,6 +526,8 @@ public class ChunkSerializer {
         DataResult<Tag> dataresult; // CraftBukkit - decompile error
         Logger logger;
 
+        if (chunk.unsaved) nbttagcompound.putBoolean("shouldSave", true); // MultiPaper
+
         if (blendingdata != null) {
             dataresult = BlendingData.CODEC.encodeStart(NbtOps.INSTANCE, blendingdata);
             logger = ChunkSerializer.LOGGER;
@@ -746,6 +752,10 @@ public class ChunkSerializer {
                 }
             }
 
+            // MultiPaper start - Keep copy of entities and block entities until they're loaded
+            chunk.entitiesToLoad = null;
+            chunk.blockEntitiesToLoad = null;
+            // MultiPaper end
         };
     }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
index 2c9e9d35cd6500aa0ce3b53122067c6a2a15cbf7..4161292b281db260f215fe78c110649240581759 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -80,7 +80,7 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
             if (this.emptyChunks.add(chunkPos.toLong())) {
                 // Paper - rewrite chunk system
             }
-
+            this.emptyChunks.remove(chunkPos.toLong()); // MultiPaper - don't cache empty chunks
         } else {
             // Paper - move into saveEntityChunk0
             this.emptyChunks.remove(chunkPos.toLong());
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index dcfe090c269d4cbcc2eb1b6f85392848bb34656c..24cf410f2361c39db1cef87c3e1c3ddee90aba69 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -893,6 +893,7 @@ public class RegionFile implements AutoCloseable {
     }
 
     public boolean hasChunk(ChunkPos pos) {
+        if (true) return true; // MultiPaper - always return true
         return this.getOffset(pos) != 0;
     }
 
@@ -902,6 +903,12 @@ public class RegionFile implements AutoCloseable {
     }
 
     public void close() throws IOException {
+        // MultiPaper start
+        if (this.file == null) {
+            this.closed = true;
+            return;
+        }
+        // MultiPaper end
         // Paper start - Prevent regionfiles from being closed during use
         this.fileLock.lock();
         synchronized (this) {
diff --git a/src/main/java/net/minecraft/world/level/portal/PortalForcer.java b/src/main/java/net/minecraft/world/level/portal/PortalForcer.java
index 92d13c9f1ec1e5ff72c1d68f924a8d1c86c91565..ba6bd3da9f08eb1a033b254ef813e12c65533294 100644
--- a/src/main/java/net/minecraft/world/level/portal/PortalForcer.java
+++ b/src/main/java/net/minecraft/world/level/portal/PortalForcer.java
@@ -58,7 +58,7 @@ public class PortalForcer {
             villageplace,
             type -> type.is(PoiTypes.NETHER_PORTAL),
             (BlockPos pos) -> {
-                net.minecraft.world.level.chunk.ChunkAccess lowest = this.level.getChunk(pos.getX() >> 4, pos.getZ() >> 4, net.minecraft.world.level.chunk.ChunkStatus.EMPTY);
+                net.minecraft.world.level.chunk.ChunkAccess lowest = this.level.getChunk(pos.getX() >> 4, pos.getZ() >> 4, net.minecraft.world.level.chunk.ChunkStatus.FULL); // MultiPaper - For some reason empty was reseting the chunks nearby the portal
                 if (!lowest.getStatus().isOrAfter(net.minecraft.world.level.chunk.ChunkStatus.FULL)
                     && (lowest.getBelowZeroRetrogen() == null || !lowest.getBelowZeroRetrogen().targetStatus().isOrAfter(net.minecraft.world.level.chunk.ChunkStatus.HEIGHTMAPS))) {
                     // why would we generate the chunk?
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
index 5dea8414964e0d2d1fb15a6baa27227e9722bfc7..afae4011fd57730abf5309837ec8cbaf171a3edd 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -23,9 +23,11 @@ import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.Vec3i;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import puregero.multipaper.MultiPaper;
 
 public class LevelTicks<T> implements LevelTickAccess<T> {
     private static final Comparator<LevelChunkTicks<?>> CONTAINER_DRAIN_ORDER = (a, b) -> {
@@ -48,7 +50,10 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
 
     };
 
-    public LevelTicks(LongPredicate tickingFutureReadyPredicate, Supplier<ProfilerFiller> profilerGetter) {
+    public ServerLevel level; // MultiPaper - add level
+
+    public LevelTicks(ServerLevel level, LongPredicate tickingFutureReadyPredicate, Supplier<ProfilerFiller> profilerGetter) { // MultiPaper - add level
+        this.level = level; // MultiPaper - add level
         this.tickCheck = tickingFutureReadyPredicate;
         this.profiler = profilerGetter;
     }
@@ -115,6 +120,10 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
                 LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
                 if (levelChunkTicks == null) {
                     objectIterator.remove();
+                // MultiPaper start - Don't tick chunks that aren't owned by us
+                } else if (levelChunkTicks.count() > 0 && !MultiPaper.isChunkLocal(level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(l))) {
+                    levelChunkTicks.getAll().forEach(tick -> tick.triggerTick++);
+                // MultiPaper end - Don't tick chunks that aren't owned by us
                 } else {
                     ScheduledTick<T> scheduledTick = levelChunkTicks.peek();
                     if (scheduledTick == null) {
diff --git a/src/main/java/net/minecraft/world/ticks/ScheduledTick.java b/src/main/java/net/minecraft/world/ticks/ScheduledTick.java
index 4161bea782f45753ce74c4c9091d110aebb53b21..277484f22fd5d0c97418457ed0b8cf8b49f17ca2 100644
--- a/src/main/java/net/minecraft/world/ticks/ScheduledTick.java
+++ b/src/main/java/net/minecraft/world/ticks/ScheduledTick.java
@@ -5,7 +5,16 @@ import java.util.Comparator;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 
-public record ScheduledTick<T>(T type, BlockPos pos, long triggerTick, TickPriority priority, long subTickOrder) {
+// MultiPaper start - transform ScheduledTick from a record into a class
+public class ScheduledTick<T> {
+
+    public T type; public T type() { return type; }
+    public long triggerTick; public long triggerTick() { return triggerTick; }
+    public BlockPos pos; public BlockPos pos() { return pos; }
+    public TickPriority priority; public TickPriority priority() { return priority; }
+    public long subTickOrder; public long subTickOrder() { return subTickOrder; }
+// MultiPaper end
+
     public static final Comparator<ScheduledTick<?>> DRAIN_ORDER = (first, second) -> {
         int i = Long.compare(first.triggerTick, second.triggerTick);
         if (i != 0) {
@@ -41,9 +50,15 @@ public record ScheduledTick<T>(T type, BlockPos pos, long triggerTick, TickPrior
         this(type, pos, triggerTick, TickPriority.NORMAL, subTickOrder);
     }
 
-    public ScheduledTick {
-        blockPos = blockPos.immutable();
+    // MultiPaper start - transform ScheduledTick from a record into a class
+    public ScheduledTick(T type, BlockPos pos, long triggerTick, TickPriority priority, long subTickOrder) {
+        this.type = type;
+        this.pos = pos.immutable();
+        this.triggerTick = triggerTick;
+        this.priority = priority;
+        this.subTickOrder = subTickOrder;
     }
+    // MultiPaper end
 
     public static <T> ScheduledTick<T> probe(T type, BlockPos pos) {
         return new ScheduledTick<>(type, pos, 0L, TickPriority.NORMAL, 0L);
diff --git a/src/main/java/puregero/multipaper/ChunkKey.java b/src/main/java/puregero/multipaper/ChunkKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..d139536be7ab15293b798af115e71a8dbe4a2f3d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ChunkKey.java
@@ -0,0 +1,34 @@
+package puregero.multipaper;
+
+public class ChunkKey {
+    private final String name;
+    private final int x;
+    private final int z;
+
+    public ChunkKey(String name, int x, int z) {
+        this.name = name;
+        this.x = x;
+        this.z = z;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof ChunkKey) {
+            return ((ChunkKey) other).name.equals(name)
+                    && ((ChunkKey) other).x == x
+                    && ((ChunkKey) other).z == z;
+        }
+
+        return super.equals(other);
+    }
+
+    @Override
+    public int hashCode() {
+        // Taken from ChunkCoordIntPair
+        int i = 1664525 * this.x + 1013904223;
+        int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+
+        return name.hashCode() ^ i ^ j;
+    }
+}
+
diff --git a/src/main/java/puregero/multipaper/ExternalServerConnection.java b/src/main/java/puregero/multipaper/ExternalServerConnection.java
index 83736cca003bf96271153700a89fcee3c43a63ff..c145a3e278ded8e32b1541f4f042102db79c68bb 100644
--- a/src/main/java/puregero/multipaper/ExternalServerConnection.java
+++ b/src/main/java/puregero/multipaper/ExternalServerConnection.java
@@ -21,9 +21,12 @@ import puregero.multipaper.mastermessagingprotocol.MessageLengthDecoder;
 import puregero.multipaper.mastermessagingprotocol.MessageLengthEncoder;
 
 import java.io.Closeable;
+import java.io.DataInputStream;
 import java.io.IOException;
 import java.util.*;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Consumer;
 
 public class ExternalServerConnection extends ChannelInitializer<SocketChannel> implements Closeable {
 
@@ -36,6 +39,9 @@ public class ExternalServerConnection extends ChannelInitializer<SocketChannel>
     public HashSet<String> subscribedWorlds = new HashSet<>();
     private static final Queue<List<ExternalPlayer>> externalPlayerListPool = new LinkedList<>();
     private final HashMap<Packet<?>, List<ExternalPlayer>> packetsToSend = new LinkedHashMap<>();
+    public final ConcurrentHashMap<ChunkKey, Consumer<DataInputStream>> chunkCallbacks = new ConcurrentHashMap<>();
+    public long lastPacketSent = 0;
+    public long lastPacketReceived = 0;
 
     public ExternalServerConnection() {
 
@@ -135,8 +141,10 @@ public class ExternalServerConnection extends ChannelInitializer<SocketChannel>
         } else {
             onConnect.thenRun(() -> {
                 if (channel.eventLoop().inEventLoop()) {
+                    lastPacketSent = System.currentTimeMillis();
                     channel.writeAndFlush(packet);
                 } else {
+                    lastPacketSent = System.currentTimeMillis();
                     channel.eventLoop().execute(() -> channel.writeAndFlush(packet));
                 }
             });
@@ -170,4 +178,16 @@ public class ExternalServerConnection extends ChannelInitializer<SocketChannel>
             players.add(player);
         }
     }
+
+    public void requestChunk(String world, int cx, int cz, Consumer<DataInputStream> callback) {
+        if (callback != null) {
+            if (chunkCallbacks.put(new ChunkKey(world, cx, cz), callback) != null) {
+                LOGGER.warn("A chunk callback already existed for " + world + ", " + cx + ", " + cz + " (new request is to " + externalServer.getName() + ")");
+                LOGGER.warn("Stats for " + externalServer.getName() + ": last packet sent=" + (System.currentTimeMillis() - lastPacketSent) + "ms ago; last packet received=" + (System.currentTimeMillis() - lastPacketReceived) + "ms ago");
+            }
+        }
+
+        RequestChunkPacket.blocker = externalServer;
+        send(new RequestChunkPacket(world, cx, cz));
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index 136a7bb726afef1ee199b066eec8ebecf7ef13b1..4f4f658edb77cb36e4ee473626a620ab0dfd619a 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -1,25 +1,52 @@
 package puregero.multipaper;
 
-import net.minecraft.server.MinecraftServer;
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import io.papermc.paper.world.ChunkEntitySlices;
+import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.Container;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.event.inventory.InventoryCloseEvent;
+import puregero.multipaper.externalserverprotocol.*;
 import puregero.multipaper.externalserverprotocol.ExternalServerPacket;
 import puregero.multipaper.externalserverprotocol.PlayerCreatePacket;
 import puregero.multipaper.externalserverprotocol.PlayerRemovePacket;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.PlayerConnectMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.PlayerDisconnectMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.StartMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.WriteTickTimeMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.*;
 import puregero.multipaper.mastermessagingprotocol.messages.serverbound.BooleanMessageReply;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ChunkLoadedOnAnotherServerMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.DataMessageReply;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ServerBoundMessage;
 
+import java.io.*;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
-import java.util.Collection;
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
 
 public class MultiPaper {
 
@@ -157,4 +184,248 @@ public class MultiPaper {
     public static boolean isExternalPlayer(org.bukkit.entity.Entity bukkitEntity) {
         return isExternalPlayer(((CraftEntity) bukkitEntity).getHandle());
     }
+
+    public static boolean isChunkExternal(Chunk chunk) {
+        return chunk != null && isChunkExternal(((CraftChunk) chunk).getHandle());
+    }
+
+    public static boolean isChunkExternal(LevelChunk chunk) {
+        return chunk != null && isChunkExternal(chunk.getChunkHolder());
+    }
+
+    public static boolean isChunkExternal(ServerLevel level, BlockPos pos) {
+        return isChunkExternal(level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(ChunkPos.asLong(pos.getX() >> 4, pos.getZ() >> 4)));
+    }
+
+    public static boolean isChunkExternal(NewChunkHolder newChunkHolder) {
+        return newChunkHolder != null && newChunkHolder.externalOwner != null && !newChunkHolder.externalOwner.isMe();
+    }
+
+    public static boolean isChunkLocal(Chunk chunk) {
+        return chunk != null && isChunkLocal(((CraftChunk) chunk).getHandle());
+    }
+
+    public static boolean isChunkLocal(LevelChunk chunk) {
+        return chunk != null && isChunkLocal(chunk.getChunkHolder());
+    }
+
+    public static boolean isChunkLocal(ServerLevel level, BlockPos pos) {
+        return isChunkLocal(level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(ChunkPos.asLong(pos.getX() >> 4, pos.getZ() >> 4)));
+    }
+
+    public static boolean isChunkLocal(NewChunkHolder newChunkHolder) {
+        return newChunkHolder != null && newChunkHolder.externalOwner != null && newChunkHolder.externalOwner.isMe();
+    }
+
+    public static CompoundTag readChunk(ChunkPos chunkPos, ServerLevel serverLevel) throws IOException {
+        return readRegionFileNBT(serverLevel, "region", chunkPos);
+    }
+
+    public static void writeChunk(ChunkPos chunkPos, ServerLevel serverLevel, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel, "region", chunkPos, compoundTag);
+    }
+
+    public static CompletableFuture<byte[]> forceReadChunk(String world, String path, int cx, int cz) {
+        return getConnection().sendAndAwaitReply(new ForceReadChunkMessage(world, path, cx, cz), DataMessageReply.class).thenApply(message -> message.data);
+    }
+
+    public static CompletableFuture<DataInputStream> readRegionFileAsync(String world, String path, int cx, int cz) {
+        if (path.equals("region")) {
+            World bukkitWorld = Bukkit.getWorld(world);
+            if (bukkitWorld == null || MultiPaper.getChunkHolder(world, cx, cz) == null) {
+                if (Bukkit.getPluginManager().getPlugin("Dynmap") == null) {
+                    // Dynmap uses this, so don't log for Dynmap servers
+                    LOGGER.warn(Thread.currentThread() + " has no chunk holder for reading chunk " + world + "," + path + "," + cx + "," + cz + ", reading it straight from disk instead");
+                }
+
+                return forceReadChunk(world, path, cx, cz).thenApply(data -> data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+            }
+        }
+
+        return getConnection().sendAndAwaitReply(new ReadChunkMessage(world, path, cx, cz), ServerBoundMessage.class).thenCompose(message -> {
+            if (message instanceof ChunkLoadedOnAnotherServerMessage chunkLoadedOnAnotherServerMessage) {
+                ExternalServer server = getConnection().getServersMap().get(chunkLoadedOnAnotherServerMessage.server);
+                CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+                if (server.getConnection() == null) {
+                    // Don't throw the exception as that will cause the chunk to get corrupted and regenerate, losing data. Instead, allow the chunk loader to naturally timeout and try again.
+                    new Exception("Tried to request a chunk " + world + "," + path + "," + cx + "," + cz + " from " + chunkLoadedOnAnotherServerMessage.server + ", but we are not connected to them!").printStackTrace();
+                } else if (path.equals("region")) {
+                    server.getConnection().requestChunk(world, cx, cz, inputStream -> {
+                        RequestChunkPacket.blocker = null;
+                        future.complete(inputStream);
+                    });
+                } else {
+                    throw new IllegalArgumentException("Cannot load a " + path + " chunk from an external server");
+                }
+                return future;
+            } else if (message instanceof DataMessageReply dataMessageReply) {
+                return CompletableFuture.completedFuture(dataMessageReply.data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(dataMessageReply.data))));
+            } else {
+                throw new IllegalArgumentException("Unexpected message reply " + message);
+            }
+        });
+    }
+
+    public static DataInput readRegionFile(String world, String path, int cx, int cz) {
+        try {
+            return readRegionFileAsync(world, path, cx, cz).get(20, TimeUnit.SECONDS);
+        } catch (TimeoutException timeoutException) {
+            LOGGER.warn("Timed out reading " + world + "," + path + "," + cx + "," + cz + ", retrying...");
+            return readRegionFile(world, path, cx, cz);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void writeRegionFile(String world, String path, int cx, int cz, byte[] bytes) throws IOException {
+        writeRegionFile(world, path, cx, cz, bytes, false);
+    }
+
+    public static void writeRegionFile(String world, String path, int cx, int cz, byte[] bytes, boolean isTransientEntities) throws IOException {
+        if (bytes.length > 0) {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            DeflaterOutputStream deflateOut = new DeflaterOutputStream(baos);
+            deflateOut.write(bytes);
+            deflateOut.close();
+            bytes = baos.toByteArray();
+        }
+
+        getConnection().send(new WriteChunkMessage(world, path, cx, cz, bytes, isTransientEntities), message -> { /* Do nothing */ });
+    }
+ 
+    public static CompoundTag readRegionFileNBT(File path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(serverLevel.getWorld().getName(), path, chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(String world, String path, int cx, int cz) throws IOException {
+        DataInput in = readRegionFile(world, path, cx, cz);
+
+        return in == null ? null : NbtIo.read(in);
+    }
+ 
+    public static void writeRegionFileNBT(File path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel.getWorld().getName(), path, chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(String world, String path, int cx, int cz, CompoundTag compoundTag) throws IOException {
+        writeRegionFile(world, path, cx, cz, nbtToBytes(compoundTag));
+    }
+
+    private static String getWorld(File path) {
+        do {
+            path = path.getParentFile();
+        } while (path.getName().startsWith("DIM"));
+        return path.getName();
+    }
+
+    public static void lockChunk(NewChunkHolder newChunkHolder) {
+        getConnection().send(new LockChunkMessage(newChunkHolder.world.getWorld().getName(), newChunkHolder.chunkX, newChunkHolder.chunkZ));
+        newChunkHolder.hasExternalLockRequest = true;
+    }
+
+    public static void unlockChunk(NewChunkHolder newChunkHolder, ChunkAccess chunkAccess, ChunkEntitySlices chunkEntitySlices) {
+        if (chunkAccess instanceof LevelChunk levelChunk && MultiPaper.isChunkLocal(newChunkHolder)) {
+            broadcastPacketToExternalServers(newChunkHolder.externalSubscribers, () -> new SendTickListPacket(levelChunk));
+            for (BlockEntity blockEntity : levelChunk.getBlockEntities().values()) {
+                if (blockEntity instanceof Container container) {
+                    List<HumanEntity> viewers = container.getViewers();
+                    if (!viewers.isEmpty()) {
+                        for (HumanEntity viewer : new ArrayList<>(container.getViewers())) {
+                            if (viewer instanceof CraftPlayer craftPlayer) {
+                                craftPlayer.closeInventory(InventoryCloseEvent.Reason.UNLOADED);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        getConnection().send(new UnlockChunkMessage(newChunkHolder.world.getWorld().getName(), newChunkHolder.chunkX, newChunkHolder.chunkZ));
+        newChunkHolder.externalOwner = null;
+        newChunkHolder.hasExternalLockRequest = false;
+    }
+    
+    public static byte[] nbtToBytes(CompoundTag compoundTag) throws IOException {
+        if (compoundTag == null) {
+            return new byte[0];
+        }
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        NbtIo.write(compoundTag, new DataOutputStream(buffer));
+        return buffer.toByteArray();
+    }
+
+    public static CompoundTag nbtFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new ByteArrayInputStream(data)));
+    }
+
+    public static byte[] nbtCompressToBytes(CompoundTag compoundTag) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(buffer);
+        NbtIo.write(compoundTag, new DataOutputStream(deflaterOutputStream));
+        deflaterOutputStream.close();
+        return buffer.toByteArray();
+    }
+
+    public static CompoundTag nbtDecompressFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+    }
+
+    public static ChunkAccess getChunkAccess(String world, int cx, int cz) {
+        CraftWorld bukkitWorld = ((CraftWorld) Bukkit.getWorld(world));
+
+        ChunkAccess chunkAccess = bukkitWorld != null ? bukkitWorld.getHandle().getChunkIfLoaded(cx, cz) : null;
+        if (chunkAccess == null) {
+            NewChunkHolder holder = getChunkHolder(world, cx, cz);
+            if (holder != null) {
+                chunkAccess = holder.getCurrentChunk();
+
+                if (chunkAccess instanceof ImposterProtoChunk) {
+                    chunkAccess = ((ImposterProtoChunk) chunkAccess).getWrapped();
+                }
+            }
+        }
+
+        return chunkAccess;
+    }
+
+    public static ChunkAccess getChunkAccess(String world, BlockPos pos) {
+        return getChunkAccess(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static NewChunkHolder getChunkHolder(String world, BlockPos pos) {
+        return getChunkHolder(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static NewChunkHolder getChunkHolder(UUID world, BlockPos pos) {
+        return getChunkHolder(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static NewChunkHolder getChunkHolder(ServerLevel level, BlockPos pos) {
+        return getChunkHolder(level, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static NewChunkHolder getChunkHolder(String world, int x, int z) {
+        CraftWorld craftWorld = ((CraftWorld) Bukkit.getWorld(world));
+        return craftWorld != null ? getChunkHolder(craftWorld.getHandle(), x, z) : null;
+    }
+
+    public static NewChunkHolder getChunkHolder(UUID world, int x, int z) {
+        CraftWorld craftWorld = ((CraftWorld) Bukkit.getWorld(world));
+        return craftWorld != null ? getChunkHolder(craftWorld.getHandle(), x, z) : null;
+    }
+
+    public static NewChunkHolder getChunkHolder(ServerLevel level, int x, int z) {
+        return level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(x, z);
+    }
+
+    public static void chunkChangedStatus(ServerLevel level, ChunkPos pos, ChunkStatus status) {
+        getConnection().send(new ChunkChangedStatusMessage(level.getWorld().getName(), pos.x, pos.z, BuiltInRegistries.CHUNK_STATUS.getKey(status).toString()));
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..59d011962c3692e235997a5cf2893478347a2828
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
@@ -0,0 +1,255 @@
+package puregero.multipaper;
+
+import ca.spottedleaf.starlight.common.light.SWMRNibbleArray;
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import io.papermc.paper.util.MCUtil;
+import io.papermc.paper.world.ChunkEntitySlices;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.lighting.LevelLightEngine;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.externalserverprotocol.SendUpdatePacket;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.SubscribeChunkMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.UnsubscribeChunkMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.BooleanMessageReply;
+
+import javax.annotation.Nullable;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.UUID;
+
+public class MultiPaperChunkHandler {
+
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperChunkHandler.class.getSimpleName());
+
+    public static boolean shouldTick(Level level, BlockPos pos) {
+        LevelChunk chunk = level.getChunkIfLoaded(pos);
+        return MultiPaper.isChunkLocal(chunk);
+    }
+
+    public static void onChunkLoad(LevelChunk chunk) {
+
+    }
+
+    public static void onChunkUnload(NewChunkHolder newChunkHolder, @Nullable ChunkAccess chunk, @Nullable ChunkEntitySlices chunkEntitySlices) {
+        if (newChunkHolder.hasExternalLockRequest) {
+            MultiPaper.unlockChunk(newChunkHolder, chunk, chunkEntitySlices);
+        }
+        MultiPaper.getConnection().sendAndAwaitReply(new UnsubscribeChunkMessage(newChunkHolder.world.getWorld().getName(), newChunkHolder.chunkX, newChunkHolder.chunkZ), BooleanMessageReply.class).thenRun(() ->
+            onChunkUnsubscribed(newChunkHolder.world.getWorld().getName(), newChunkHolder.chunkX, newChunkHolder.chunkZ)
+        );
+    }
+
+    public static void onChunkUnsubscribed(String world, int cx, int cz) {
+        NewChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+
+        if (holder != null && holder.getCurrentChunk() != null) {
+            LOGGER.warn("Chunk " + world + "," + cx + "," + cz + " was unsubscribed from but has a chunk loaded! Resubscribing...");
+            MultiPaper.getConnection().send(new SubscribeChunkMessage(world, cx, cz));
+        }
+    }
+
+    private static final HashSet<BlockEntity> blockEntitiesToBroadcast = new HashSet<>();
+    public static void broadcastBlockEntityChange(BlockEntity entity) {
+        if (blockUpdateChunk != null) return; // Don't broadcast the update to other servers if we're handling an update
+        blockEntitiesToBroadcast.add(entity);
+        // Wait a bit as the block entity may get changed multiple times in 1 tick
+        MultiPaper.runSync(() -> {
+            for (BlockEntity blockEntity : blockEntitiesToBroadcast) {
+                if (blockEntity != null && blockEntity.getLevel() != null) {
+                    onBlockUpdate(MultiPaper.getChunkHolder(blockEntity.getLevel().getWorld().getName(), blockEntity.getBlockPos()), ClientboundBlockEntityDataPacket.create(blockEntity, BlockEntity::saveWithFullMetadata, false));
+                }
+            }
+            blockEntitiesToBroadcast.clear();
+        });
+    }
+
+    public static void onBlockUpdate(NewChunkHolder newChunkHolder, Packet<?> packet) {
+        if (newChunkHolder == null) {
+            // Chunk is still loading
+            return;
+        }
+
+        ChunkAccess chunk = newChunkHolder.getCurrentChunk();
+
+        if (chunk instanceof ImposterProtoChunk imposterProtoChunk) {
+            chunk = imposterProtoChunk.getWrapped();
+        }
+
+        if (chunk == null) {
+            LOGGER.warn("A " + packet.getClass().getSimpleName() + " occurred on an unloaded chunk " + newChunkHolder);
+            return;
+        }
+        if (blockUpdateChunk == null) { // Don't broadcast the update to other servers if we're handling an update
+            for (ExternalServer externalServer : newChunkHolder.externalSubscribers) {
+                if (!externalServer.isMe()) {
+                    externalServer.getConnection().send(new SendUpdatePacket(newChunkHolder.world.uuid, packet));
+                }
+            }
+        }
+    }
+
+    public static ChunkAccess blockUpdateChunk = null;
+    private static NewChunkHolder holder = null;
+    public static void handleBlockUpdate(UUID world, Packet<?> packet, int depth) {
+        holder = null;
+        blockUpdateChunk = null;
+        ChunkAccess tempChunk = null;
+        CraftWorld bukkitWorld = ((CraftWorld) Bukkit.getWorld(world));
+        ServerLevel level = bukkitWorld != null ? bukkitWorld.getHandle() : null;
+        if (level == null) {
+            return;
+        } else if (packet instanceof ClientboundBlockUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+            update.runUpdates((pos, state) -> {
+                if (holder == null) holder = MultiPaper.getChunkHolder(world, pos);
+            });
+        } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundLightUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getX(), update.getZ());
+        }
+
+        if (holder != null && holder.hasGenerationTask()) {
+            holder.onCurrentChunkLoaded().thenRun(() -> {
+                if (!Bukkit.isPrimaryThread()) {
+                    new Exception("Loaded chunk " + holder.chunkX + "," + holder.chunkZ + ", outside of the main thread! (currentThread=" + Thread.currentThread() + ")").printStackTrace();
+                }
+                handleBlockUpdate(world, packet, depth);
+            });
+            return;
+        }
+
+        if (holder != null) {
+            tempChunk = holder.getCurrentChunk();
+
+            if (tempChunk instanceof ImposterProtoChunk imposterProtoChunk) {
+                tempChunk = imposterProtoChunk.getWrapped();
+            }
+        }
+
+        if (holder != null) {
+            // Only send changes we make below to players, not other servers
+            holder.vanillaChunkHolder.addChangesToPlayersOnly = true;
+        }
+
+        // Set blockUpdateChunk here so that we can broadcast changes beforehand
+        blockUpdateChunk = tempChunk;
+
+        if (holder != null && level.getChunkIfLoaded(holder.chunkX, holder.chunkZ) != null) {
+            // Chunk is loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                setBlock(((LevelChunk) blockUpdateChunk), update.getPos(), update.getBlockState());
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    setBlock(((LevelChunk) blockUpdateChunk), pos, state);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                BlockEntity existingBlockEntity = blockUpdateChunk.getBlockEntity(update.getPos());
+                if (existingBlockEntity != null && existingBlockEntity.minecraftKey.toString().equals(update.getTag().getString("id"))) {
+                    existingBlockEntity.load(update.getTag());
+                    holder.vanillaChunkHolder.blockChanged(update.getPos());
+                } else if (!blockUpdateChunk.getBlockState(update.getPos()).hasBlockEntity() && depth < 1) {
+                    MCUtil.scheduleTask(1, () -> handleBlockUpdate(world, packet, depth + 1));
+                } else {
+                    blockUpdateChunk.removeBlockEntity(update.getPos());
+                    blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                    blockUpdateChunk.getBlockEntity(update.getPos());
+                    holder.vanillaChunkHolder.blockChanged(update.getPos());
+                }
+            }
+        } else if (blockUpdateChunk != null) {
+            // Chunk is not loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                setBlockInUnloadedChunk(blockUpdateChunk, update.getPos(), update.getBlockState());
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    setBlockInUnloadedChunk(blockUpdateChunk, pos, state);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                blockUpdateChunk.removeBlockEntity(update.getPos());
+                if (blockUpdateChunk instanceof LevelChunk levelChunk && levelChunk.blockEntitiesToLoad != null) {
+                    levelChunk.blockEntitiesToLoad.add(update.getTag());
+                } else {
+                    blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                    blockUpdateChunk.getBlockEntity(update.getPos());
+                }
+            } else if (packet instanceof ClientboundLightUpdatePacket update) {
+                handleLightUpdatePacket(level, blockUpdateChunk, update);
+            }
+        }
+
+        if (holder != null) {
+            holder.vanillaChunkHolder.addChangesToPlayersOnly = false;
+        }
+
+        blockUpdateChunk = null;
+    }
+
+    private static void setBlockInUnloadedChunk(ChunkAccess chunk, BlockPos pos, BlockState blockState) {
+        if (chunk instanceof LevelChunk levelChunk) {
+            levelChunk.setBlockState(pos, blockState, false, false);
+        } else {
+            chunk.setBlockState(pos, blockState, false);
+        }
+    }
+
+    private static void setBlock(LevelChunk chunk, BlockPos pos, BlockState blockState) {
+        BlockState oldState = chunk.setBlockState(pos, blockState, false, false);
+        holder.vanillaChunkHolder.blockChanged(pos);
+
+        if (oldState != null && blockState != oldState && (blockState.getLightBlock(chunk, pos) != oldState.getLightBlock(chunk, pos) || blockState.getLightEmission() != oldState.getLightEmission() || blockState.useShapeForLightOcclusion() || oldState.useShapeForLightOcclusion())) {
+            chunk.level.getProfiler().push("queueCheckLightExternalUpdate");
+            chunk.level.getChunkSource().getLightEngine().checkBlock(pos);
+            chunk.level.getProfiler().pop();
+        }
+    }
+
+    // From the client
+    private static void handleLightUpdatePacket(ServerLevel level, ChunkAccess chunk, ClientboundLightUpdatePacket packet) {
+        int i = packet.getX();
+        int j = packet.getZ();
+        LevelLightEngine levellightengine = level.getChunkSource().getLightEngine();
+        BitSet bitset = packet.getLightData().getSkyYMask();
+        BitSet bitset1 = packet.getLightData().getEmptySkyYMask();
+        Iterator<byte[]> iterator = packet.getLightData().getSkyUpdates().iterator();
+        readSectionList(chunk, i, j, levellightengine, LightLayer.SKY, bitset, bitset1, iterator, packet.getLightData().getTrustEdges());
+        BitSet bitset2 = packet.getLightData().getBlockYMask();
+        BitSet bitset3 = packet.getLightData().getEmptyBlockYMask();
+        Iterator<byte[]> iterator1 = packet.getLightData().getBlockUpdates().iterator();
+        readSectionList(chunk, i, j, levellightengine, LightLayer.BLOCK, bitset2, bitset3, iterator1, packet.getLightData().getTrustEdges());
+    }
+
+    // From the client
+    private static void readSectionList(ChunkAccess chunk, int i, int j, LevelLightEngine levelLightEngine, LightLayer lightLayer, BitSet bitset2, BitSet bitset3, Iterator<byte[]> iterator1, boolean trustEdges) {
+        for(int k = 0; k < levelLightEngine.getLightSectionCount(); ++k) {
+            int l = levelLightEngine.getMinLightSection() + k;
+            boolean flag = bitset2.get(k);
+            boolean flag1 = bitset3.get(k);
+            if (flag || flag1) {
+                if (lightLayer == LightLayer.BLOCK) {
+                    chunk.getBlockNibbles()[k] = flag ? new SWMRNibbleArray(iterator1.next().clone()) : new SWMRNibbleArray();
+                } else if (lightLayer == LightLayer.SKY) {
+                    chunk.getSkyNibbles()[k] = flag ? new SWMRNibbleArray(iterator1.next().clone()) : new SWMRNibbleArray();
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index a9ecd0c2f8554970544e505d0099b8dc01644753..47aec762c8583f0f5af89ce13eb5e5be626249c0 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -9,16 +9,23 @@ import io.netty.channel.epoll.EpollEventLoopGroup;
 import io.netty.channel.epoll.EpollSocketChannel;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import puregero.multipaper.config.MultiPaperConfiguration;
+import puregero.multipaper.externalserverprotocol.SendChunkPacket;
+import puregero.multipaper.externalserverprotocol.SendTickListPacket;
 import puregero.multipaper.mastermessagingprotocol.MessageBootstrap;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.HelloMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.MasterBoundMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.MasterBoundProtocol;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.*;
 import puregero.multipaper.mastermessagingprotocol.messages.serverbound.*;
 
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
@@ -81,6 +88,14 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
             channel.write(unhandledRequest);
         }
 
+        if (MinecraftServer.getServer() != null) {
+            for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
+                level.chunkTaskScheduler.chunkHolderManager.getChunkHolders().forEach(chunkHolder -> {
+                    channel.write(new SubscribeChunkMessage(level.getWorld().getName(), chunkHolder.chunkX, chunkHolder.chunkZ));
+                });
+            }
+        }
+
         channelActive = true;
         channel.flush();
     }
@@ -117,6 +132,20 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
         }));
     }
 
+    public <T extends ServerBoundMessage> CompletableFuture<T> sendAndAwaitReply(MasterBoundMessage message, Class<T> expectedClass) {
+        CompletableFuture<T> future = new CompletableFuture<>();
+
+        send(message, reply -> {
+            try {
+                future.complete((T) reply);
+            } catch (ClassCastException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
     public Map<String, ExternalServer> getServersMap() {
         return serversMap;
     }
@@ -163,4 +192,104 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
             }
         });
     }
+
+    @Override
+    public void handle(SetChunkOwnerMessage message) {
+        ExternalServer server = message.owner.isEmpty() ? null : getOrCreateServer(message.owner);
+
+        NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+        if (newChunkHolder != null) {
+            if (newChunkHolder.externalOwner != null && newChunkHolder.externalOwner.isMe() && server != null && !server.isMe()) {
+                if (newChunkHolder.getCurrentChunk() instanceof LevelChunk levelChunk) {
+                    server.getConnection().send(new SendTickListPacket(levelChunk));
+                } else {
+                    LOGGER.warn("Chunk " + message.cx + ", " + message.cz + " in world " + message.world + " is not a level chunk, but we own it and want to send tick list to " + server.getName());
+                }
+            }
+            if (server != null && server.isMe()) {
+                // Wait a bit for extra data to arrive before ticking the chunk
+                newChunkHolder.externalOwner = null;
+                MultiPaper.runSync(() -> newChunkHolder.externalOwner = server);
+            } else if (server != null) {
+                newChunkHolder.externalOwner = server;
+                MultiPaper.runSync(() -> {
+                    if (newChunkHolder.getCurrentChunk() instanceof LevelChunk levelChunk) {
+                        levelChunk.blockTicks.removeIf(tick -> true);
+                        levelChunk.fluidTicks.removeIf(tick -> true);
+                    }
+                });
+            } else {
+                newChunkHolder.externalOwner = null;
+            }
+            if (server != null && newChunkHolder.getCurrentChunk() != null && newChunkHolder.getCurrentChunk().getStatus() != ChunkStatus.FULL) {
+                // A server has locked the chunk, which means their chunk must be full.
+                // Let's redownload their full copy
+                SendChunkPacket.forceChunkUnsafeUnload(message.world, message.cx, message.cz);
+            }
+        }
+
+    }
+
+    @Override
+    public void handle(AddChunkSubscriberMessage message) {
+        ExternalServer server = getOrCreateServer(message.server);
+
+        MultiPaper.runSync(() -> {
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (newChunkHolder != null) {
+                newChunkHolder.externalSubscribers.add(server);
+            } else {
+                LOGGER.warn("Received AddChunkSubscriberMessage for unloaded chunk " + message.world + " " + message.cx + " " + message.cz);
+            }
+        });
+    }
+
+    @Override
+    public void handle(RemoveChunkSubscriberMessage message) {
+        ExternalServer server = getOrCreateServer(message.server);
+
+        MultiPaper.runSync(() -> {
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (newChunkHolder != null) {
+                newChunkHolder.externalSubscribers.remove(server);
+            } else {
+                LOGGER.warn("Received RemoveChunkSubscriberMessage for unloaded chunk " + message.world + " " + message.cx + " " + message.cz);
+            }
+        });
+    }
+
+    @Override
+    public void handle(ChunkSubscribersSyncMessage message) {
+        ExternalServer ownerServer = message.owner.isEmpty() ? null : getOrCreateServer(message.owner);
+        HashSet<ExternalServer> servers = new HashSet<>();
+        for (String server : message.subscribers) {
+            servers.add(getOrCreateServer(server));
+        }
+
+        MultiPaper.runSync(() -> {
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (newChunkHolder != null) {
+                newChunkHolder.externalOwner = ownerServer;
+                newChunkHolder.externalSubscribers.clear();
+                newChunkHolder.externalSubscribers.addAll(servers);
+            } else {
+                LOGGER.warn("Received ChunkSubscribersSyncMessage for unloaded chunk " + message.world + " " + message.cx + " " + message.cz);
+            }
+        });
+    }
+
+    @Override
+    public void handle(ServerChangedChunkStatusMessage message) {
+        ExternalServer server = getOrCreateServer(message.server);
+        ChunkStatus status = BuiltInRegistries.CHUNK_STATUS.get(new ResourceLocation(message.status));
+
+        if (!server.isMe()) {
+            NewChunkHolder holder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (holder == null) {
+                LOGGER.warn("Received a chunk change status notification for an unloaded chunk " + message.world + ";" + message.cx + ";" + message.cz + " from " + server.getName());
+            } else if (holder.getCurrentChunk() != null && !holder.getCurrentChunk().getStatus().isOrAfter(status)) {
+                SendChunkPacket.forceChunkUnsafeUnload(message.world, message.cx, message.cz);
+            }
+        }
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperWorldBorderHandler.java b/src/main/java/puregero/multipaper/MultiPaperWorldBorderHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..229506e75000777a5c3c686533eac47ef17b30d4
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperWorldBorderHandler.java
@@ -0,0 +1,78 @@
+package puregero.multipaper;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.*;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.border.BorderChangeListener;
+import net.minecraft.world.level.border.WorldBorder;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.jetbrains.annotations.NotNull;
+import puregero.multipaper.externalserverprotocol.SendUpdatePacket;
+
+import java.util.UUID;
+
+public class MultiPaperWorldBorderHandler implements BorderChangeListener {
+
+    public static boolean updatingWorldBorder = false;
+
+    @Override
+    public void onBorderSizeSet(@NotNull WorldBorder border, double size) {
+        onWorldBorderChange(border, new ClientboundSetBorderSizePacket(border));
+    }
+
+    @Override
+    public void onBorderSizeLerping(@NotNull WorldBorder border, double fromSize, double toSize, long time) {
+        onWorldBorderChange(border, new ClientboundSetBorderLerpSizePacket(border));
+    }
+
+    @Override
+    public void onBorderCenterSet(@NotNull WorldBorder border, double centerX, double centerZ) {
+        onWorldBorderChange(border, new ClientboundSetBorderCenterPacket(border));
+    }
+
+    @Override
+    public void onBorderSetWarningTime(@NotNull WorldBorder border, int warningTime) {
+        onWorldBorderChange(border, new ClientboundSetBorderWarningDelayPacket(border));
+    }
+
+    @Override
+    public void onBorderSetWarningBlocks(@NotNull WorldBorder border, int warningBlockDistance) {
+        onWorldBorderChange(border, new ClientboundSetBorderWarningDistancePacket(border));
+    }
+
+    @Override
+    public void onBorderSetDamagePerBlock(@NotNull WorldBorder border, double damagePerBlock) {}
+
+    @Override
+    public void onBorderSetDamageSafeZOne(@NotNull WorldBorder border, double safeZoneRadius) {}
+
+    private void onWorldBorderChange(WorldBorder border, Packet<?> packet) {
+        if (!updatingWorldBorder && border.world != null && border.world.getWorldBorder() == border) {
+            MultiPaper.broadcastPacketToExternalServers(border.world.getWorld().getName(), new SendUpdatePacket(border.world.uuid, packet));
+
+            // Save the level.dat
+            border.world.saveIncrementally(true);
+        }
+    }
+
+    public static void handle(UUID world, Packet<?> packet) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+
+        updatingWorldBorder = true;
+
+        if (packet instanceof ClientboundSetBorderSizePacket setBorderSizePacket) {
+            level.getWorldBorder().setSize(setBorderSizePacket.getSize());
+        } else if (packet instanceof ClientboundSetBorderLerpSizePacket setBorderLerpSizePacket) {
+            level.getWorldBorder().lerpSizeBetween(setBorderLerpSizePacket.getOldSize(), setBorderLerpSizePacket.getNewSize(), setBorderLerpSizePacket.getLerpTime());
+        } else if (packet instanceof ClientboundSetBorderCenterPacket setBorderCenterPacket) {
+            level.getWorldBorder().setCenter(setBorderCenterPacket.getNewCenterX(), setBorderCenterPacket.getNewCenterZ());
+        } else if (packet instanceof ClientboundSetBorderWarningDelayPacket setBorderWarningDelayPacket) {
+            level.getWorldBorder().setWarningTime(setBorderWarningDelayPacket.getWarningDelay());
+        } else if (packet instanceof ClientboundSetBorderWarningDistancePacket setBorderWarningDistancePacket) {
+            level.getWorldBorder().setWarningBlocks(setBorderWarningDistancePacket.getWarningBlocks());
+        }
+
+        updatingWorldBorder = false;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketHandler.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketHandler.java
index 4b5bb154c26b6a1c95d013b571c1d0f7867f52d2..e4ecd29f6fe5c7d10613b9db6c7b7563d21ea02e 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketHandler.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketHandler.java
@@ -19,6 +19,7 @@ public class ExternalServerPacketHandler extends SimpleChannelInboundHandler<Ext
 
     @Override
     protected void channelRead0(ChannelHandlerContext ctx, ExternalServerPacket msg) {
+        connection.lastPacketReceived = System.currentTimeMillis();
         msg.handle(connection);
     }
 
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index 361232ab565973d262cfb6ecc54fd823e28d799e..191294b08434bd4ea0a7ea29d040b782125eb7e9 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -20,6 +20,10 @@ public class ExternalServerPacketSerializer {
         addPacket(PlayerRespawnPacket.class, PlayerRespawnPacket::new);
         addPacket(PlayerChangeDimensionPacket.class, PlayerChangeDimensionPacket::new);
         addPacket(SendPacketPacket.class, SendPacketPacket::new);
+        addPacket(SendUpdatePacket.class, SendUpdatePacket::new);
+        addPacket(RequestChunkPacket.class, RequestChunkPacket::new);
+        addPacket(SendChunkPacket.class, SendChunkPacket::new);
+        addPacket(SendTickListPacket.class, SendTickListPacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, Function<FriendlyByteBuf, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..4bfe8626ccfc5de2918a3b3416c884e74b26cba3
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
@@ -0,0 +1,146 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ThreadedLevelLightEngine;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServer;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.util.ConcurrentModificationException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+public class RequestChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(RequestChunkPacket.class.getSimpleName());
+    public static ExternalServer blocker = null;
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+
+    public RequestChunkPacket(String world, int cx, int cz) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+    }
+
+    public RequestChunkPacket(FriendlyByteBuf in) {
+        world = in.readUtf();
+        cx = in.readInt();
+        cz = in.readInt();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        World bukkitWorld = Bukkit.getWorld(world);
+
+        if (!(bukkitWorld instanceof CraftWorld craftWorld)) {
+            LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we don't have the world " + world + " loaded.");
+            connection.send(new SendChunkPacket(world, cx, cz, null));
+            return;
+        }
+
+        ServerLevel level = craftWorld.getHandle();
+        NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(world, cx, cz);
+
+        if (newChunkHolder == null) {
+            LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we aren't trying to load it.");
+            connection.send(new SendChunkPacket(world, cx, cz, null));
+            return;
+        }
+
+        CompletableFuture<ChunkAccess> future = newChunkHolder.onCurrentChunkLoaded();
+
+        CompletableFuture<ChunkAccess> futureToWaitOn = future;
+        if (blocker == connection.externalServer) {
+            ChunkAccess access = newChunkHolder.getCurrentChunk();
+            if (access != null) {
+                futureToWaitOn = CompletableFuture.completedFuture(newChunkHolder.getCurrentChunk());
+            } else {
+                connection.send(new SendChunkPacket(world, cx, cz, null));
+                return;
+            }
+        }
+
+        futureToWaitOn.thenAccept(chunk -> {
+            if (future != newChunkHolder.onCurrentChunkLoaded()) {
+                // The future has been updated, try again
+                handle(connection);
+                return;
+            }
+
+            if (chunk == null) {
+                LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we don't have it loaded.");
+                connection.send(new SendChunkPacket(world, cx, cz, null));
+                return;
+            }
+
+            CompletableFuture<Void> lightFuture = ((ThreadedLevelLightEngine) level.getLightEngine()).theLightEngine.lightQueue.getChunkFuture(newChunkHolder.vanillaChunkHolder.getPos());
+
+            if (!lightFuture.isDone()) {
+                lightFuture.thenRunAsync(() -> handle(connection));
+                return;
+            }
+
+            try {
+                ListTag entitiesToLoad = null;
+                ListTag blockEntitiesToLoad = null;
+
+                ChunkAccess fullChunk = chunk instanceof ImposterProtoChunk imposterProtoChunk ? imposterProtoChunk.getWrapped() : chunk;
+
+                if (fullChunk instanceof LevelChunk levelChunk) {
+                    // Cache these tags in case they get deleted while we serialize the chunk (multi-threaded fun!)
+                    entitiesToLoad = levelChunk.entitiesToLoad;
+                    blockEntitiesToLoad = levelChunk.blockEntitiesToLoad;
+                }
+
+                CompoundTag tag = ChunkSerializer.write(level, chunk);
+
+                if (entitiesToLoad != null) {
+                    tag.put("entities", entitiesToLoad);
+                }
+                if (blockEntitiesToLoad != null) {
+                    tag.put("block_entities", blockEntitiesToLoad);
+                }
+
+                connection.send(new SendChunkPacket(world, cx, cz, tag));
+            } catch (ConcurrentModificationException e) {
+                LOGGER.warn("Got ConcurrentModificationException while sending chunk, sending it in main thread instead");
+                MultiPaper.runSync(() -> handle(connection));
+            }
+        })
+        // Timeout instantly if this server is blocking our chunk loading, as this is probably also blocking their chunk loading
+        .orTimeout(15, TimeUnit.SECONDS).exceptionally(throwable -> {
+            if (throwable instanceof TimeoutException) {
+                LOGGER.warn("Timed out while sending chunk " + world + "," + cx + "," + cz);
+            } else {
+                LOGGER.warn("Error while sending chunk " + world + "," + cx + "," + cz, throwable);
+            }
+
+            connection.send(new SendChunkPacket(world, cx, cz, null));
+            return null;
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..9903fc6840284405970b0222540bda4685b36e11
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
@@ -0,0 +1,123 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ChunkKey;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.util.function.Consumer;
+import java.util.zip.InflaterInputStream;
+
+public class SendChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendChunkPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final byte[] data;
+
+    public SendChunkPacket(String world, int cx, int cz, CompoundTag tag) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+
+        try {
+            if (tag == null) {
+                data = new byte[0];
+            } else {
+                data = MultiPaper.nbtToBytes(tag);
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public SendChunkPacket(FriendlyByteBuf in) {
+        world = in.readUtf();
+        cx = in.readInt();
+        cz = in.readInt();
+        data = in.readByteArray();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeByteArray(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        try {
+            Consumer<DataInputStream> callback = connection.chunkCallbacks.remove(new ChunkKey(world, cx, cz));
+            if (callback != null) {
+                if (data.length == 0) {
+                    LOGGER.warn(connection.externalServer.getName() + " sent us an empty chunk for " + world + "," + cx + "," + cz + ", force loading it from disk");
+                    MultiPaper.forceReadChunk(world, "region", cx, cz).thenAccept(data2 -> callback.accept(data2.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data2)))));
+                } else {
+                    callback.accept(new DataInputStream(new ByteArrayInputStream(data)));
+                }
+            } else {
+                if (data.length == 0) {
+                    return;
+                }
+
+                CompoundTag tag = MultiPaper.nbtFromBytes(data);
+                CraftWorld craftWorld = ((CraftWorld) Bukkit.getWorld(world));
+                ServerLevel level = craftWorld != null ? craftWorld.getHandle() : null;
+                NewChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+                if (level == null) {
+                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " but we don't have world loaded.");
+                } else if (holder == null) {
+                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " but no chunk is loaded here");
+                } else if (holder.getCurrentChunk() instanceof LevelChunk) {
+                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " (" + tag.getString("Status") + "), but it is a level chunk (" + holder.getCurrentGenStatus() + ")");
+                } else {
+                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " (" + tag.getString("Status") + "), but we have a " + holder.getCurrentGenStatus() + " chunk, forcing reload from disk.");
+                    forceChunkUnsafeUnload(world, cx, cz);
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private ChunkAccess loadChunk(ServerLevel level, ChunkPos pos, CompoundTag tag) {
+        ChunkSerializer.InProgressChunkHolder newChunk = ChunkSerializer.loadChunk(level, level.getPoiManager(), pos, tag, true);
+        MultiPaper.runSync(() -> newChunk.tasks.forEach(Runnable::run));
+        return newChunk.protoChunk instanceof ImposterProtoChunk imposterProtoChunk ? imposterProtoChunk.getWrapped() : newChunk.protoChunk;
+    }
+
+    public static void forceChunkUnsafeUnload(String world, int cx, int cz) {
+        MultiPaper.runSync(() -> {
+            ChunkPos pos = new ChunkPos(cx, cz);
+            CraftWorld craftWorld = ((CraftWorld) Bukkit.getWorld(world));
+            if (craftWorld != null) {
+                ServerLevel level = craftWorld.getHandle();
+                NewChunkHolder holder = level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(pos.longKey);
+
+                if (holder != null) {
+                    level.chunkTaskScheduler.chunkHolderManager.unloadChunkNowNoSave(holder);
+                }
+            }
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..801d03669f9056ca9cd3dc2c617521c29a6854be
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
@@ -0,0 +1,89 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.ticks.LevelChunkTicks;
+import net.minecraft.world.ticks.ProtoChunkTicks;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.IOException;
+
+public class SendTickListPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendTickListPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final CompoundTag tag;
+
+    public SendTickListPacket(LevelChunk chunk) {
+        this.world = chunk.level.convertable.getLevelId();
+        this.cx = chunk.locX;
+        this.cz = chunk.locZ;
+
+        tag = new CompoundTag();
+        tag.put("block_ticks", chunk.blockTicks.save(chunk.level.getLevelData().getGameTime(), (block) -> BuiltInRegistries.BLOCK.getKey(block).toString()));
+        tag.put("fluid_ticks", chunk.fluidTicks.save(chunk.level.getLevelData().getGameTime(), (fluidtype) -> BuiltInRegistries.FLUID.getKey(fluidtype).toString()));
+    }
+
+    public SendTickListPacket(FriendlyByteBuf in) {
+        this.world = in.readUtf();
+        this.cx = in.readInt();
+        this.cz = in.readInt();
+
+        byte[] data = in.readByteArray();
+        try {
+            tag = MultiPaper.nbtFromBytes(data);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+
+        try {
+            byte[] data = MultiPaper.nbtToBytes(tag);
+
+            out.writeByteArray(data);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+            ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+            if (chunk instanceof LevelChunk levelChunk) {
+                levelChunk.unregisterTickContainerFromLevel(level);
+                levelChunk.blockTicks = LevelChunkTicks.load(tag.getList("block_ticks", Tag.TAG_COMPOUND), s -> BuiltInRegistries.BLOCK.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+                levelChunk.fluidTicks = LevelChunkTicks.load(tag.getList("fluid_ticks", Tag.TAG_COMPOUND), s -> BuiltInRegistries.FLUID.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+                levelChunk.unpackTicks(level.getLevelData().getGameTime());
+                if (levelChunk.loaded) levelChunk.registerTickContainerInLevel(level);
+            } else if (chunk instanceof ProtoChunk protoChunk) {
+                protoChunk.blockTicks = ProtoChunkTicks.load(tag.getList("block_ticks", Tag.TAG_COMPOUND), s -> BuiltInRegistries.BLOCK.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+                protoChunk.fluidTicks = ProtoChunkTicks.load(tag.getList("fluid_ticks", Tag.TAG_COMPOUND), s -> BuiltInRegistries.FLUID.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+            } else {
+                LOGGER.warn("Received tick lists for an unloaded chunk " + world + "," + cx + "," + cz);
+            }
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..c9ad59beb1115af9b058b3a03e41705f74df2cba
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
@@ -0,0 +1,65 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.*;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+import puregero.multipaper.MultiPaperWorldBorderHandler;
+
+import java.util.UUID;
+
+public class SendUpdatePacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendUpdatePacket.class.getSimpleName());
+
+    private final UUID world;
+    private final Packet<?> packet;
+
+    public SendUpdatePacket(UUID world, Packet<?> packet) {
+        this.world = world;
+        this.packet = packet;
+    }
+
+    public SendUpdatePacket(FriendlyByteBuf in) {
+        world = in.readUUID();
+
+        byte[] bytes = in.readByteArray();
+        ByteBuf buf = Unpooled.wrappedBuffer(bytes);
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.maxNbtSize = Long.MAX_VALUE;
+        int packetId = friendlyByteBuf.readVarInt();
+        packet = ConnectionProtocol.PLAY.createPacket(PacketFlow.CLIENTBOUND, packetId, friendlyByteBuf);
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUUID(world);
+
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(packet);
+        Integer id = protocol.getPacketId(PacketFlow.CLIENTBOUND, packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        packet.write(friendlyByteBuf);
+        out.writeByteArray(buf.array());
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        if (packet instanceof ClientboundBlockUpdatePacket || packet instanceof ClientboundSectionBlocksUpdatePacket || packet instanceof ClientboundLightUpdatePacket || packet instanceof ClientboundBlockEntityDataPacket) {
+            MultiPaper.runSync(() -> MultiPaperChunkHandler.handleBlockUpdate(world, packet, 0));
+        } else if (packet instanceof ClientboundSetBorderSizePacket || packet instanceof ClientboundSetBorderLerpSizePacket || packet instanceof ClientboundSetBorderCenterPacket || packet instanceof ClientboundSetBorderWarningDelayPacket || packet instanceof ClientboundSetBorderWarningDistancePacket) {
+            MultiPaper.runSync(() -> MultiPaperWorldBorderHandler.handle(world, packet));
+        } else {
+            LOGGER.warn("Unhandled update packet of type " + packet.getClass().getSimpleName());
+        }
+    }
+}
