From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Thu, 18 Nov 2021 00:00:34 +1000
Subject: [PATCH] Sync player inventories between servers


diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 1e311b86901b22b0ec09d0fc5188e886110a2c4f..747989a3c7c2019c4cffb4ad86474f6debe37692 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -164,6 +164,7 @@ import org.bukkit.event.player.PlayerPortalEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.inventory.MainHand;
+import puregero.multipaper.ExternalServer;
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.externalserverprotocol.PlayerChangeDimensionPacket;
 import puregero.multipaper.externalserverprotocol.PlayerChangeGamemodePacket;
@@ -227,6 +228,7 @@ public class ServerPlayer extends Player {
     private final ContainerSynchronizer containerSynchronizer;
     private final ContainerListener containerListener;
     private int containerCounter;
+    @Nullable public ExternalServer openContainer; // MultiPaper
     public int latency;
     public boolean wonGame;
     private int containerUpdateDelay; // Paper
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index b1a82769dfbec6eeb9cbeb768e218637c0efa9ed..80f6007a220698f61942b3c20b79517597f59c71 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -215,6 +215,7 @@ import org.bukkit.inventory.SmithingInventory;
 import org.bukkit.util.NumberConversions;
 import co.aikar.timings.MinecraftTimings; // Paper
 import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperInventoryHandler;
 // CraftBukkit end
 
 public class ServerGamePacketListenerImpl implements ServerPlayerConnection, ServerGamePacketListener {
@@ -750,6 +751,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
     @Override
     public void handleAcceptTeleportPacket(ServerboundAcceptTeleportationPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
+        MultiPaperInventoryHandler.handleAcceptTeleport(this.player, packet); // MultiPaper
         if (packet.getId() == this.awaitingTeleport && this.awaitingPositionFromClient != null) { // CraftBukkit
             this.player.moveTo(this.awaitingPositionFromClient.x, this.awaitingPositionFromClient.y, this.awaitingPositionFromClient.z, this.player.getYRot(), this.player.getXRot()); // Paper - use proper setPositionRotation for teleportation
             this.lastGoodX = this.awaitingPositionFromClient.x;
@@ -976,6 +978,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
     @Override
     public void handleRenameItem(ServerboundRenameItemPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return; // MultiPaper
         if (this.player.containerMenu instanceof AnvilMenu) {
             AnvilMenu containeranvil = (AnvilMenu) this.player.containerMenu;
             String s = SharedConstants.filterText(packet.getName());
@@ -990,6 +993,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
     @Override
     public void handleSetBeaconPacket(ServerboundSetBeaconPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return; // MultiPaper
         if (this.player.containerMenu instanceof BeaconMenu) {
             ((BeaconMenu) this.player.containerMenu).updateEffects(packet.getPrimary(), packet.getSecondary());
         }
@@ -1096,6 +1100,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
     @Override
     public void handleSelectTrade(ServerboundSelectTradePacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return;
         int i = packet.getItem();
         AbstractContainerMenu container = this.player.containerMenu;
 
@@ -1827,6 +1832,8 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
         }
         // Paper end - move check up
 
+        if (MultiPaperInventoryHandler.handleInteractEvent(this.player, packet)) return; // MultiPaper - send to external server if necessary
+
         this.player.resetLastActionTime();
         int i = this.player.level.getMaxBuildHeight();
 
@@ -1865,6 +1872,8 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
         InteractionHand enumhand = packet.getHand();
         ItemStack itemstack = this.player.getItemInHand(enumhand);
 
+        if (MultiPaperInventoryHandler.handleUseItemEvent(this.player, packet)) return; // MultiPaper
+
         this.player.resetLastActionTime();
         if (!itemstack.isEmpty()) {
             // CraftBukkit start
@@ -2050,6 +2059,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
 
             this.player.getInventory().selected = packet.getSlot();
             this.player.resetLastActionTime();
+            if (MultiPaper.isRealPlayer(this.player)) MultiPaper.broadcastPlayerAction(this.player, packet); // MultiPaper
         } else {
             ServerGamePacketListenerImpl.LOGGER.warn("{} tried to set an invalid carried item", this.player.getName().getString());
             this.disconnect("Invalid hotbar selection (Hacking?)", org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // CraftBukkit // Paper - kick event cause
@@ -2601,6 +2611,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
     public void handleContainerClose(ServerboundContainerClosePacket packetplayinclosewindow, InventoryCloseEvent.Reason reason) {
         // Paper end
         PacketUtils.ensureRunningOnSameThread(packetplayinclosewindow, this, this.player.getLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packetplayinclosewindow)) return; // MultiPaper
 
         if (this.player.isImmobile()) return; // CraftBukkit
         CraftEventFactory.handleInventoryCloseEvent(this.player, reason); // CraftBukkit // Paper
@@ -2611,6 +2622,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
     @Override
     public void handleContainerClick(ServerboundContainerClickPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return; // MultiPaper
         if (this.player.isImmobile()) return; // CraftBukkit
         this.player.resetLastActionTime();
         if (this.player.containerMenu.containerId == packet.getContainerId() && this.player.containerMenu.stillValid(this.player)) { // CraftBukkit
@@ -2921,6 +2933,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
 
     @Override
     public void handlePlaceRecipe(ServerboundPlaceRecipePacket packet) {
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return; // MultiPaper
         // Paper start
         if (!org.bukkit.Bukkit.isPrimaryThread()) {
             if (recipeSpamPackets.addAndGet(com.destroystokyo.paper.PaperConfig.autoRecipeIncrement) > com.destroystokyo.paper.PaperConfig.autoRecipeLimit) {
@@ -2946,6 +2959,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
     @Override
     public void handleContainerButtonClick(ServerboundContainerButtonClickPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return; // MultiPaper
         if (this.player.isImmobile()) return; // CraftBukkit
         this.player.resetLastActionTime();
         if (this.player.containerMenu.containerId == packet.getContainerId() && !this.player.isSpectator()) {
diff --git a/src/main/java/net/minecraft/stats/RecipeBook.java b/src/main/java/net/minecraft/stats/RecipeBook.java
index 87167f16fa9dedf19abefe38864498edb0c40a1d..8fb5f47a1ffeb248266e6bfa12a26a1bc8a8ad0f 100644
--- a/src/main/java/net/minecraft/stats/RecipeBook.java
+++ b/src/main/java/net/minecraft/stats/RecipeBook.java
@@ -33,6 +33,7 @@ public class RecipeBook {
     }
 
     public boolean contains(@Nullable Recipe<?> recipe) {
+        if (recipe != null) return true; // MultiPaper - who cares if they use a recipe that they don't have, no point trying to sync this between servers
         return recipe == null ? false : this.known.contains(recipe.getId());
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 7a1bec43df6711cb797960b69e20a744c44c36e2..e025c01f54381ba0b77b056b7cd6bdae4aa909de 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -84,14 +84,7 @@ import net.minecraft.world.level.Explosion;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.FenceGateBlock;
-import net.minecraft.world.level.block.HoneyBlock;
-import net.minecraft.world.level.block.Mirror;
-import net.minecraft.world.level.block.RenderShape;
-import net.minecraft.world.level.block.Rotation;
-import net.minecraft.world.level.block.SoundType;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
@@ -146,6 +139,7 @@ import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public abstract class Entity implements Nameable, EntityAccess, CommandSource, io.papermc.paper.util.KeyedObject { // Paper
@@ -1434,6 +1428,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, i
                         blockposition_mutableblockposition.set(i, j, k);
                         BlockState iblockdata = this.level.getBlockState(blockposition_mutableblockposition);
 
+                        boolean shouldTickOurPlayer = MultiPaper.isRealPlayer(this) && (iblockdata.getBlock() instanceof NetherPortalBlock || iblockdata.getBlock() instanceof EndPortalBlock); // MultiPaper - tick portals
+                        if (!shouldTickOurPlayer && MultiPaper.isChunkExternal(this.level.getChunkAt(blockposition_mutableblockposition))) continue; // MultiPaper - Only check for blocks on our server
+
                         try {
                             iblockdata.entityInside(this.level, blockposition_mutableblockposition, this);
                             this.onInsideBlock(iblockdata);
diff --git a/src/main/java/net/minecraft/world/entity/player/Inventory.java b/src/main/java/net/minecraft/world/entity/player/Inventory.java
index 8d329bca0818033df41fbd781028919c73e052a6..d43cdea5999da9f878bb6a84da1893f4767c90a1 100644
--- a/src/main/java/net/minecraft/world/entity/player/Inventory.java
+++ b/src/main/java/net/minecraft/world/entity/player/Inventory.java
@@ -17,6 +17,7 @@ import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.tags.Tag;
 import net.minecraft.world.Container;
 import net.minecraft.world.ContainerHelper;
+import net.minecraft.world.InteractionHand;
 import net.minecraft.world.Nameable;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
@@ -30,6 +31,7 @@ import java.util.ArrayList;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.entity.HumanEntity;
+import puregero.multipaper.NonNullListFilter;
 // CraftBukkit end
 
 public class Inventory implements Container, Nameable {
@@ -41,10 +43,12 @@ public class Inventory implements Container, Nameable {
     public static final int NOT_FOUND_INDEX = -1;
     public static final int[] ALL_ARMOR_SLOTS = new int[]{0, 1, 2, 3};
     public static final int[] HELMET_SLOT_ONLY = new int[]{3};
-    public final NonNullList<ItemStack> items;
-    public final NonNullList<ItemStack> armor;
-    public final NonNullList<ItemStack> offhand;
-    public final List<NonNullList<ItemStack>> compartments;
+    // MultiPaper start - Use NonNullListFilter instead of NonNullList
+    public final NonNullListFilter<ItemStack> items;
+    public final NonNullListFilter<ItemStack> armor;
+    public final NonNullListFilter<ItemStack> offhand;
+    public final List<NonNullListFilter<ItemStack>> compartments;
+    // MultiPaper end
     public int selected;
     public final Player player;
     private int timesChanged;
@@ -98,9 +102,11 @@ public class Inventory implements Container, Nameable {
     // CraftBukkit end
 
     public Inventory(Player player) {
-        this.items = NonNullList.withSize(36, ItemStack.EMPTY);
-        this.armor = NonNullList.withSize(4, ItemStack.EMPTY);
-        this.offhand = NonNullList.withSize(1, ItemStack.EMPTY);
+        // MultiPaper start - Filter the inventory and sync it with other server
+        this.items = NonNullListFilter.withSize(36, ItemStack.EMPTY, player, "items");
+        this.armor = NonNullListFilter.withSize(4, ItemStack.EMPTY, player, "armor");
+        this.offhand = NonNullListFilter.withSize(1, ItemStack.EMPTY, player, "offhand");
+        // MultiPaper end
         this.compartments = ImmutableList.of(this.items, this.armor, this.offhand);
         this.player = player;
     }
@@ -439,6 +445,8 @@ public class Inventory implements Container, Nameable {
             }
         }
 
+        if (list != null) ((NonNullListFilter<ItemStack>) list).markDirty(slot); // MultiPaper
+
         return list != null && !((ItemStack) list.get(slot)).isEmpty() ? ContainerHelper.removeItem(list, slot, amount) : ItemStack.EMPTY;
     }
 
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 66f808cabcf6a9a6584849b285f1c60133adc7b4..ee33647ae4658e3318db556556e682b84e479fd5 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -148,6 +148,8 @@ public final class ItemStack {
     private AdventureModeCheck adventureBreakCheck;
     @Nullable
     private AdventureModeCheck adventurePlaceCheck;
+    public boolean dirty = true; // MultiPaper
+    static { EMPTY.dirty = false; } // MultiPaper
 
     public Optional<TooltipComponent> getTooltipImage() {
         return this.getItem().getTooltipImage(this);
@@ -260,6 +262,7 @@ public final class ItemStack {
             this.setDamageValue(this.getDamageValue());
         }
 
+        dirty = true; // MultiPaper
     }
 
     private ItemStack(CompoundTag nbt) {
@@ -519,6 +522,8 @@ public final class ItemStack {
 
     public void setDamageValue(int damage) {
         this.getOrCreateTag().putInt("Damage", Math.max(0, damage));
+
+        dirty = true; // MultiPaper
     }
 
     public int getMaxDamage() {
@@ -788,6 +793,8 @@ public final class ItemStack {
             if (this.tag.isEmpty()) {
                 this.tag = null;
             }
+
+            dirty = true; // MultiPaper
         }
 
     }
@@ -826,6 +833,7 @@ public final class ItemStack {
             this.getItem().verifyTagAfterLoad(nbt);
         }
 
+        dirty = true; // MultiPaper
     }
 
     public Component getHoverName() {
@@ -857,6 +865,8 @@ public final class ItemStack {
             nbttagcompound.remove("Name");
         }
 
+        dirty = true; // MultiPaper
+
         return this;
     }
 
@@ -874,6 +884,8 @@ public final class ItemStack {
             this.tag = null;
         }
 
+        dirty = true; // MultiPaper
+
     }
 
     public boolean hasCustomHoverName() {
@@ -1059,6 +1071,8 @@ public final class ItemStack {
         CompoundTag nbttagcompound = this.getOrCreateTag();
 
         nbttagcompound.putInt("HideFlags", nbttagcompound.getInt("HideFlags") | tooltipSection.getMask());
+
+        dirty = true; // MultiPaper
     }
 
     public static void appendEnchantmentNames(List<Component> tooltip, ListTag enchantments) {
@@ -1126,6 +1140,8 @@ public final class ItemStack {
 
         nbttaglist.add(EnchantmentHelper.storeEnchantment(EnchantmentHelper.getEnchantmentId(enchantment), (byte) level));
         processEnchantOrder(this.tag); // Paper
+
+        dirty = true; // MultiPaper
     }
 
     public boolean isEnchanted() {
@@ -1134,6 +1150,8 @@ public final class ItemStack {
 
     public void addTagElement(String key, net.minecraft.nbt.Tag element) {
         this.getOrCreateTag().put(key, element);
+
+        dirty = true; // MultiPaper
     }
 
     public boolean isFramed() {
@@ -1166,6 +1184,8 @@ public final class ItemStack {
         }
         // CraftBukkit end
         this.getOrCreateTag().putInt("RepairCost", repairCost);
+
+        dirty = true; // MultiPaper
     }
 
     public Multimap<Attribute, AttributeModifier> getAttributeModifiers(EquipmentSlot slot) {
@@ -1219,6 +1239,8 @@ public final class ItemStack {
     public void setItem(Item item) {
         this.bukkitStack = null; // Paper
         this.item = item;
+
+        dirty = true; // MultiPaper
     }
     // CraftBukkit end
 
@@ -1271,6 +1293,8 @@ public final class ItemStack {
     public void setCount(int count) {
         this.count = count;
         this.updateEmptyCacheFlag();
+
+        dirty = true; // MultiPaper
     }
 
     public void grow(int amount) {
diff --git a/src/main/java/puregero/multipaper/ExternalPlayer.java b/src/main/java/puregero/multipaper/ExternalPlayer.java
index 75609c1074a45f20137ef1bb3d6bae9c96a61618..0e7172bb8d8024541662644ee5a0d0ea7dd902d6 100644
--- a/src/main/java/puregero/multipaper/ExternalPlayer.java
+++ b/src/main/java/puregero/multipaper/ExternalPlayer.java
@@ -84,4 +84,9 @@ public class ExternalPlayer extends ServerPlayer {
     public boolean broadcastToPlayer(ServerPlayer spectator) {
         return false;
     }
+
+    @Override
+    public void checkInsideBlocks() {
+        super.checkInsideBlocks();
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index 3f332668bad6c53c3884b9210c9a88ce432d2deb..d11f660c7d639f7b6035c7552d68a5f4c1f25878 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -5,6 +5,7 @@ import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Registry;
+import net.minecraft.network.protocol.game.ServerboundSetCarriedItemPacket;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtIo;
@@ -32,6 +33,7 @@ import puregero.multipaper.externalserverprotocol.*;
 import java.io.*;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
@@ -177,6 +179,14 @@ public class MultiPaper {
                 }
             });
         });
+
+        MultiPaperInventoryHandler.tick();
+
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            if (player instanceof ExternalPlayer externalPlayer) {
+                externalPlayer.checkInsideBlocks();
+            }
+        }
     }
 
     public static void sendTickTime(long time, double tps) {
@@ -436,7 +446,7 @@ public class MultiPaper {
             e.printStackTrace();
         }
     }
-    
+
     public static byte[] nbtToBytes(CompoundTag compoundTag) throws IOException {
         if (compoundTag == null) {
             return new byte[0];
@@ -506,4 +516,8 @@ public class MultiPaper {
             e.printStackTrace();
         };
     }
+
+    public static void broadcastPlayerAction(ServerPlayer player, ServerboundSetCarriedItemPacket packet) {
+        broadcastPacketToExternalServers(new PlayerActionPacket(player, packet));
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperInventoryHandler.java b/src/main/java/puregero/multipaper/MultiPaperInventoryHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..140299c05bce61d3f3a87e04200fecfb0be5c57f
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperInventoryHandler.java
@@ -0,0 +1,207 @@
+package puregero.multipaper;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.*;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.BucketItem;
+import net.minecraft.world.item.EnderEyeItem;
+import net.minecraft.world.item.FishingRodItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.chunk.LevelChunk;
+import puregero.multipaper.externalserverprotocol.PlayerActionPacket;
+import puregero.multipaper.externalserverprotocol.PlayerInventoryUpdatePacket;
+
+import java.util.*;
+
+public class MultiPaperInventoryHandler {
+
+    private static boolean updatingInventory = false;
+    private static final HashMap<UUID, ArrayList<AwaitingTeleport>> awaitingTeleports = new HashMap<>();
+
+    public static boolean handlePacketFromExternalServer(ExternalServer server, ServerPlayer player, Packet<?> packet) {
+        if (packet instanceof ClientboundOpenScreenPacket) {
+            // An external server has requested to open a window on a player
+            player.openContainer = server;
+        } else if (packet instanceof ClientboundContainerClosePacket) {
+            // An external server has requested to close the open window on a player
+            if (player.openContainer == server) {
+                player.openContainer = null;
+            }
+        } else if (packet instanceof ClientboundSetCarriedItemPacket setCarriedItemPacket) {
+            // An external server is changing the selected item in the hotbar
+            player.getInventory().selected = setCarriedItemPacket.getSlot();
+        } else if (packet instanceof ClientboundSetExperiencePacket setExperiencePacket) {
+            // An external server is changing the player's experience level
+            player.experienceLevel = setExperiencePacket.getExperienceLevel();
+            player.experienceProgress = setExperiencePacket.getExperienceProgress();
+            player.totalExperience = setExperiencePacket.getTotalExperience();
+        } else if (packet instanceof ClientboundPlayerPositionPacket playerPositionPacket) {
+            // An external server is teleporting the player
+            double x = playerPositionPacket.getRelativeArguments().contains(ClientboundPlayerPositionPacket.RelativeArgument.X) ? player.getX() : 0.0D;
+            double y = playerPositionPacket.getRelativeArguments().contains(ClientboundPlayerPositionPacket.RelativeArgument.Y) ? player.getY() : 0.0D;
+            double z = playerPositionPacket.getRelativeArguments().contains(ClientboundPlayerPositionPacket.RelativeArgument.Z) ? player.getZ() : 0.0D;
+            float yaw = playerPositionPacket.getRelativeArguments().contains(ClientboundPlayerPositionPacket.RelativeArgument.Y_ROT) ? player.getYRot() : 0.0F;
+            float pitch = playerPositionPacket.getRelativeArguments().contains(ClientboundPlayerPositionPacket.RelativeArgument.X_ROT) ? player.getXRot() : 0.0F;
+            player.connection.teleport(x + playerPositionPacket.getX(), y + playerPositionPacket.getY(), z + playerPositionPacket.getZ(), yaw + playerPositionPacket.getYRot(), pitch + playerPositionPacket.getXRot(), playerPositionPacket.getRelativeArguments());
+            server.getConnection().send(new PlayerActionPacket(player, new ServerboundAcceptTeleportationPacket(playerPositionPacket.getId())));
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Returns true if the even should be cancelled
+     */
+    public static boolean handleInteractEvent(ServerPlayer player, ServerboundUseItemOnPacket packet) {
+        LevelChunk chunk = player.level.getChunkIfLoaded(packet.getHitResult().getBlockPos());
+        ItemStack item = player.getItemInHand(packet.getHand());
+        if (MultiPaper.isChunkExternal(chunk) && !(item.getItem() instanceof BucketItem)) {
+            chunk.externalOwner.getConnection().send(new PlayerActionPacket(player, packet));
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Returns true if the even should be cancelled
+     */
+    public static boolean handleUseItemEvent(ServerPlayer player, ServerboundUseItemPacket packet) {
+        LevelChunk chunk = player.level.getChunkIfLoaded(player.blockPosition());
+        ItemStack item = player.getItemInHand(packet.getHand());
+        if (MultiPaper.isChunkExternal(chunk) && item.getItem() instanceof EnderEyeItem) {
+            chunk.externalOwner.getConnection().send(new PlayerActionPacket(player, packet));
+            return true;
+        } else if (MultiPaper.isRealPlayer(player) && item.getItem() instanceof FishingRodItem) {
+            MultiPaper.broadcastPacketToExternalServers(chunk.externalSubscribers, () -> new PlayerActionPacket(player, packet));
+        }
+
+        return false;
+    }
+
+    /**
+     * Returns true if the even should be cancelled
+     */
+    public static boolean handleContainerEvent(ServerPlayer player, Packet<ServerGamePacketListener> containerPacket) {
+        if (player.openContainer != null) {
+            player.openContainer.getConnection().send(new PlayerActionPacket(player, containerPacket));
+
+            if (containerPacket instanceof ServerboundContainerClosePacket) {
+                player.openContainer = null;
+            }
+
+            return true;
+        }
+
+        return false;
+    }
+
+    public static void updateInventory(ServerPlayer player, String name, int slot, ItemStack item) {
+        updatingInventory = true; // Don't let these changes mark the inventories as dirty
+        switch (name) {
+            case "items" -> player.getInventory().items.set(slot, item);
+            case "armor" -> player.getInventory().armor.set(slot, item);
+            case "offhand" -> player.getInventory().offhand.set(slot, item);
+            default -> throw new IllegalArgumentException("Unknown inventory component of " + name);
+        }
+        item.dirty = false;
+        updatingInventory = false;
+    }
+
+    /**
+     * Returns true if the changes to the inventory component should be marked as dirty.
+     */
+    public static <E extends ItemStack> boolean markDirty(NonNullListFilter<E> inventoryComponent) {
+        return !updatingInventory;
+    }
+
+    /**
+     * Runs at the end of a vanilla tick. Ie any changes to the inventory made in the tick will instantly be updated
+     * to other servers without a tick delay.
+     */
+    public static void tick() {
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            for (NonNullListFilter<? extends ItemStack> inventoryComponent : new NonNullListFilter[] {
+                    player.getInventory().items,
+                    player.getInventory().armor,
+                    player.getInventory().offhand,
+            }) {
+                if (!((ServerPlayer) inventoryComponent.player).didPlayerJoinEvent) {
+                    // Don't update the inventory until they fully join
+                    continue;
+                }
+
+                ListTag items = new ListTag();
+                for (int i = 0; i < inventoryComponent.size(); i++) {
+                    if (inventoryComponent.dirty[i] || inventoryComponent.get(i).dirty) {
+                        CompoundTag item = new CompoundTag();
+                        item.putInt("Slot", i);
+                        inventoryComponent.get(i).save(item);
+                        items.add(item);
+                        inventoryComponent.dirty[i] = false;
+                        inventoryComponent.get(i).dirty = false;
+                    }
+                }
+
+                if (!items.isEmpty()) {
+                    CompoundTag itemsRoot = new CompoundTag();
+                    itemsRoot.put("items", items);
+                    MultiPaper.broadcastPacketToExternalServers((ServerPlayer) inventoryComponent.player, new PlayerInventoryUpdatePacket((ServerPlayer) inventoryComponent.player, inventoryComponent.name, itemsRoot));
+                }
+            }
+        }
+    }
+
+    public static void sendFullInventoryUpdate(ExternalServerConnection connection, ServerPlayer player) {
+        for (NonNullListFilter<? extends ItemStack> inventoryComponent : new NonNullListFilter[] {
+                player.getInventory().items,
+                player.getInventory().armor,
+                player.getInventory().offhand,
+        }) {
+            ListTag items = new ListTag();
+            for (int i = 0; i < inventoryComponent.size(); i++) {
+                CompoundTag item = new CompoundTag();
+                item.putInt("Slot", i);
+                inventoryComponent.get(i).save(item);
+                items.add(item);
+            }
+
+            CompoundTag itemsRoot = new CompoundTag();
+            itemsRoot.put("items", items);
+            connection.send(new PlayerInventoryUpdatePacket((ServerPlayer) inventoryComponent.player, inventoryComponent.name, itemsRoot));
+        }
+    }
+
+    public static void handleAcceptTeleport(ServerPlayer player, ServerboundAcceptTeleportationPacket packet) {
+        ArrayList<AwaitingTeleport> accepts = awaitingTeleports.get(player.getUUID());
+
+        if (accepts != null) {
+            accepts.removeIf(accept -> {
+               if (accept.id == packet.getId()) {
+                   accept.externalServer.getConnection().send(new PlayerActionPacket(player, packet));
+                   return true;
+               } else {
+                   return false;
+               }
+            });
+
+            if (accepts.isEmpty()) {
+                awaitingTeleports.remove(player.getUUID());
+            }
+        }
+    }
+
+    private static class AwaitingTeleport {
+        private final ExternalServer externalServer;
+        private final int id;
+
+        private AwaitingTeleport(ExternalServer externalServer, int id) {
+            this.externalServer = externalServer;
+            this.id = id;
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/NonNullListFilter.java b/src/main/java/puregero/multipaper/NonNullListFilter.java
new file mode 100644
index 0000000000000000000000000000000000000000..79b5ec18fc80714daac2c70c6a385fb1abe58a01
--- /dev/null
+++ b/src/main/java/puregero/multipaper/NonNullListFilter.java
@@ -0,0 +1,62 @@
+package puregero.multipaper;
+
+import net.minecraft.core.NonNullList;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class NonNullListFilter<E extends ItemStack> extends NonNullList<E> {
+    public final boolean[] dirty;
+    public final Player player;
+    public final String name;
+
+    protected NonNullListFilter(List<E> delegate, @Nullable E initialElement, Player player, String name) {
+        super(delegate, initialElement);
+        this.dirty = new boolean[delegate.size()];
+        this.player = player;
+        this.name = name;
+    }
+
+    public static <E extends ItemStack> NonNullListFilter<E> withSize(int size, E defaultValue, Player player, String name) {
+        Validate.notNull(defaultValue);
+        ItemStack[] objects = new ItemStack[size];
+        Arrays.fill(objects, defaultValue);
+        return new NonNullListFilter<E>(Arrays.asList((E[])objects), defaultValue, player, name);
+    }
+
+    public boolean markDirty(int i) {
+        if (MultiPaperInventoryHandler.markDirty(this)) {
+            dirty[i] = true;
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public E set(int i, E object) {
+        markDirty(i);
+        return super.set(i, object);
+    }
+
+    @Override
+    public void add(int i, E object) {
+        throw new UnsupportedOperationException("Assumption - you can't add to a fixed sized list");
+    }
+
+    @Override
+    public E remove(int i) {
+        throw new UnsupportedOperationException("Assumption - you can't remove from a fixed sized list");
+    }
+
+    @Override
+    public void clear() {
+        if (markDirty(0)) {
+            Arrays.fill(dirty, true);
+        }
+        super.clear();
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index 934b75c68cc94cf39d09f086d97b88d0fe50c23c..7915ca20200bb2fff262259a7e71b618cb5d8068 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -24,6 +24,8 @@ public class ExternalServerPacketSerializer {
         addPacket(RequestChunkPacket.class, RequestChunkPacket::new);
         addPacket(SendChunkPacket.class, SendChunkPacket::new);
         addPacket(SendTickListPacket.class, SendTickListPacket::new);
+        addPacket(PlayerActionPacket.class, PlayerActionPacket::new);
+        addPacket(PlayerInventoryUpdatePacket.class, PlayerInventoryUpdatePacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, IOExceptionFunction<DataInputStream, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..b242b1f00b4f4380db4d2c3d5a9c7ec66f478fcd
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java
@@ -0,0 +1,72 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ServerGamePacketListener;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.UUID;
+
+public class PlayerActionPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(PlayerActionPacket.class.getSimpleName());
+
+    private final UUID uuid;
+    private final Packet<ServerGamePacketListener> action;
+
+    public PlayerActionPacket(ServerPlayer player, Packet<ServerGamePacketListener> action) {
+        this.uuid = player.getUUID();
+        this.action = action;
+    }
+
+    public PlayerActionPacket(DataInputStream in) throws IOException {
+        uuid = readUUID(in);
+
+        int length = in.readInt();
+        byte[] bytes = new byte[length];
+        in.readFully(bytes);
+        ByteBuf buf = Unpooled.wrappedBuffer(bytes);
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        int packetId = friendlyByteBuf.readVarInt();
+        action = (Packet<ServerGamePacketListener>) ConnectionProtocol.PLAY.createPacket(PacketFlow.SERVERBOUND, packetId, friendlyByteBuf);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        writeUUID(out, uuid);
+
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(action);
+        Integer id = protocol.getPacketId(PacketFlow.SERVERBOUND, action);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        action.write(friendlyByteBuf);
+        byte[] bytes = buf.array();
+        out.writeInt(bytes.length);
+        out.write(bytes);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        ServerPlayer player = MinecraftServer.getServer().getPlayerList().getPlayer(uuid);
+
+        if (player == null) {
+            LOGGER.warn("Tried to run an action on a non-existent player with uuid " + uuid);
+            return;
+        }
+
+        player.server.execute(() -> action.handle(player.connection));
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java
index e5fa6a719e7c4c9f1ee5085c687469c5ad8ce522..c823d42344f88a073998832c4b5d9c0123d66c5b 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java
@@ -1,5 +1,6 @@
 package puregero.multipaper.externalserverprotocol;
 
+import net.minecraft.network.protocol.game.ClientboundSetCarriedItemPacket;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.level.GameType;
 import org.apache.logging.log4j.LogManager;
@@ -7,6 +8,7 @@ import org.apache.logging.log4j.Logger;
 import puregero.multipaper.ExternalPlayer;
 import puregero.multipaper.ExternalServerConnection;
 import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperInventoryHandler;
 
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
@@ -72,5 +74,8 @@ public class PlayerCreatePacket extends ExternalServerPacket {
 
     public static void sendPlayer(ExternalServerConnection connection, ServerPlayer player) {
         connection.send(new PlayerCreatePacket(player));
+        connection.send(new SendPacketPacket(player, new ClientboundSetCarriedItemPacket(player.getInventory().selected)));
+
+        MultiPaperInventoryHandler.sendFullInventoryUpdate(connection, player);
     }
 }
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerInventoryUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerInventoryUpdatePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ccc6e591fa0d2eab520f426bf49ab9b377f36cd
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerInventoryUpdatePacket.java
@@ -0,0 +1,72 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.ItemStack;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperInventoryHandler;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.UUID;
+
+public class PlayerInventoryUpdatePacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(PlayerInventoryUpdatePacket.class.getSimpleName());
+
+    private final UUID uuid;
+    private final String component;
+    private final CompoundTag tag;
+
+    public PlayerInventoryUpdatePacket(ServerPlayer player, String component, CompoundTag tag) {
+        this.uuid = player.getUUID();
+        this.component = component;
+        this.tag = tag;
+    }
+
+    public PlayerInventoryUpdatePacket(DataInputStream in) throws IOException {
+        uuid = readUUID(in);
+        component = in.readUTF();
+
+        int length = in.readInt();
+        byte[] bytes = new byte[length];
+        in.readFully(bytes);
+        tag = MultiPaper.nbtDecompressFromBytes(bytes);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        writeUUID(out, uuid);
+
+        out.writeUTF(component);
+        byte[] bytes = MultiPaper.nbtCompressToBytes(tag);
+        out.writeInt(bytes.length);
+        out.write(bytes);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            ServerPlayer player = MinecraftServer.getServer().getPlayerList().getPlayer(uuid);
+
+            if (player == null) {
+                LOGGER.warn("Tried to update the inventory of a non-existant player uuid " + uuid);
+                return;
+            }
+
+            ListTag items = tag.getList("items", Tag.TAG_COMPOUND);
+            items.forEach(i -> {
+                CompoundTag item = (CompoundTag) i;
+                ItemStack itemStack = ItemStack.of(item);
+                MultiPaperInventoryHandler.updateInventory(player, component, item.getInt("Slot"), itemStack);
+            });
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendPacketPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendPacketPacket.java
index 086f6064400d03de8eb9ffe9fa1a5f349cdf8fe5..f23869ed3b55d8667edeb4f11b8adda07a542be0 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/SendPacketPacket.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendPacketPacket.java
@@ -12,6 +12,7 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import puregero.multipaper.ExternalServerConnection;
 import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperInventoryHandler;
 
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
@@ -84,6 +85,10 @@ public class SendPacketPacket extends ExternalServerPacket {
                     return;
                 }
 
+                if (MultiPaperInventoryHandler.handlePacketFromExternalServer(connection.externalServer, player, packet)) {
+                    return;
+                }
+
                 player.connection.send(packet);
             }
         });
