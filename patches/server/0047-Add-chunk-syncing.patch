From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Tue, 16 Nov 2021 19:23:16 +1000
Subject: [PATCH] Add chunk syncing


diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index d271871563fa883efb77b35ec3b1dfbba87f0b62..40e74c91d79eab808b5bed3954a67624188cc003 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -16,6 +16,7 @@ import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
@@ -38,6 +39,9 @@ import net.minecraft.world.level.lighting.LevelLightEngine;
 import net.minecraft.server.MinecraftServer;
 // CraftBukkit end
 
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+
 public class ChunkHolder {
 
     public static final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> UNLOADED_CHUNK = Either.right(ChunkHolder.ChunkLoadingFailure.UNLOADED);
@@ -337,11 +341,19 @@ public class ChunkHolder {
             if (packet != null) {
                 this.broadcast(packet, false);
             }
+
+            MultiPaperChunkHandler.onBlockUpdate(this, ClientboundBlockEntityDataPacket.create(tileentity, BlockEntity::saveWithFullMetadata)); // MultiPaper - sync the full block with external servers
         }
 
     }
 
     public void broadcast(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
+        // MultiPaper start - Sync blocks with external servers
+        if (!(packet instanceof ClientboundBlockEntityDataPacket)) { // We handle block entities separately
+            MultiPaperChunkHandler.onBlockUpdate(this, packet);
+        }
+        // MultiPaper end
+        
         this.playerProvider.getPlayers(this.pos, onlyOnWatchDistanceEdge).forEach((entityplayer) -> {
             entityplayer.connection.send(packet);
         });
@@ -615,6 +627,7 @@ public class ChunkHolder {
                 either.ifLeft(chunk -> {
                     ChunkHolder.this.isEntityTickingReady = true;
                     // Paper start - entity ticking chunk set
+                    if (!chunk.hasExternalLockRequest) MultiPaper.lockChunk(chunk); // MultiPaper
                     ChunkHolder.this.chunkMap.level.getChunkSource().entityTickingChunks.add(chunk);
                     // Paper end - entity ticking chunk set
                 });
@@ -629,6 +642,7 @@ public class ChunkHolder {
             // Paper start - entity ticking chunk set
             LevelChunk chunkIfCached = this.getFullChunkUnchecked();
             if (chunkIfCached != null) {
+                if (chunkIfCached.hasExternalLockRequest) MultiPaper.unlockChunk(chunkIfCached); // MultiPaper
                 this.chunkMap.level.getChunkSource().entityTickingChunks.remove(chunkIfCached);
             }
             // Paper end - entity ticking chunk set
@@ -747,6 +761,40 @@ public class ChunkHolder {
         this.updateChunkToSave(CompletableFuture.completedFuture(Either.left(chunk.getWrapped())), "replaceProto");
     }
 
+    // MultiPaper start
+    public void replaceProtoChunk(ChunkAccess protoChunk) {
+        if (protoChunk instanceof ImposterProtoChunk imposterProtoChunk) {
+            protoChunk = imposterProtoChunk.getWrapped();
+        }
+
+        for (int i = protoChunk.getStatus().getIndex() + 1; i < this.futures.length(); ++i) {
+            this.futures.set(i, null);
+        }
+
+        Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = Either.left(protoChunk);
+
+        for (int i = 0; i <= protoChunk.getStatus().getIndex(); ++i) {
+            this.futures.set(i, CompletableFuture.completedFuture(either));
+        }
+
+        this.updateChunkToSave(CompletableFuture.completedFuture(Either.left(protoChunk)), "replaceProtoWithProto");
+    }
+
+    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getLastAvailableChunkFuture() {
+        for (int i = ChunkHolder.CHUNK_STATUSES.size() - 1; i >= 0; --i) {
+            ChunkStatus chunkstatus = ChunkHolder.CHUNK_STATUSES.get(i);
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFutureIfPresentUnchecked(chunkstatus);
+
+            if (completablefuture.getNow(Either.left(null)).right().isEmpty()) {
+                // If there's no error, this chunk must be loading
+                return completablefuture;
+            }
+        }
+
+        return ChunkHolder.UNLOADED_CHUNK_FUTURE;
+    }
+    // MultiPaper end
+
     @FunctionalInterface
     public interface LevelChangeListener {
 
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 7e0612d9eb2fc11c92efcc8a03bd1881ee39e77e..1c8046e23786831d50f6477224ffe698e2315fb4 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -110,6 +110,7 @@ import org.bukkit.entity.Player;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
 import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
@@ -1030,6 +1031,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     }
                     this.getPoiManager().queueUnload(holder.pos.longKey, MinecraftServer.currentTickLong + 1); // Paper - unload POI data
                 } // Paper end
+                if (removed) MultiPaperChunkHandler.onChunkUnload(level, holder.pos, ichunkaccess); // MultiPaper
                 } finally { this.unloadingPlayerChunk = unloadingBefore; } // Paper - do not allow ticket level changes while unloading chunks
 
             }
@@ -1204,6 +1206,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         return this.protoChunkToFullChunk(holder);
                     }, list, false);
 
+                    MultiPaper.chunkChangedStatus(level, chunkcoordintpair, requiredStatus); // MultiPaper
+
                     this.progressListener.onStatusChange(chunkcoordintpair, requiredStatus);
                     return completablefuture1;
                 } catch (Exception exception) {
@@ -1644,6 +1648,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
             return ret;
         }
+        if (true) return MultiPaper.readChunk(chunkcoordintpair, level); // MultiPaper
         return super.read(chunkcoordintpair);
     }
 
@@ -1655,6 +1660,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
+        // MultiPaper start
+        if (true) {
+            MultiPaper.writeChunk(chunkcoordintpair, level, nbttagcompound);
+            return;
+        }
+        // MultiPaper end
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
@@ -1698,6 +1709,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             return status;
         }
 
+        if (true) return null; // MultiPaper - Don't load chunk status from the disk
+
         this.readChunk(chunkPos);
 
         return regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index f36972107858637009b8f40c18559a9b61156ae3..b713c40b8b7b073acfd35db368f7f0e7b50fb067 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -50,6 +50,7 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
 import java.util.function.Function; // Paper
+import puregero.multipaper.MultiPaper;
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -1040,6 +1041,8 @@ public class ServerChunkCache extends ChunkSource {
                 // Paper end - optimise chunk tick iteration
                 ChunkPos chunkcoordintpair = chunk1.getPos();
 
+                if (!MultiPaper.isChunkLocal(chunk1)) continue; // MultiPaper - Don't tick this chunk if we don't own it
+
                 if ((true || this.level.isPositionEntityTicking(chunkcoordintpair)) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, false)) { // Paper - optimise anyPlayerCloseEnoughForSpawning & optimise chunk tick iteration
                     chunk1.incrementInhabitedTime(j);
                     if (flag2 && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, true)) { // Spigot // Paper - optimise anyPlayerCloseEnoughForSpawning & optimise chunk tick iteration
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 93471417e8c6e0c67131005e7e0f63339d96e555..f4ab73db8c2c98462722f68350e7036097b9f784 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -161,6 +161,8 @@ import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -1076,6 +1078,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
 
     private void tickFluid(BlockPos pos, Fluid fluid) {
+        if (!MultiPaperChunkHandler.shouldTick(this, pos)) return; // MultiPaper - should tick
+
         FluidState fluid1 = this.getFluidState(pos);
 
         if (fluid1.is(fluid)) {
@@ -1085,6 +1089,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
 
     private void tickBlock(BlockPos pos, Block block) {
+        if (!MultiPaperChunkHandler.shouldTick(this, pos)) return; // MultiPaper - should tick
+
         BlockState iblockdata = this.getBlockState(pos);
 
         if (iblockdata.is(block)) {
@@ -2237,6 +2243,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 return;
             }
             // CraftBukkit end
+            // MultiPaper start - run neighbour updates later if we're handling block changes
+            if (MultiPaperChunkHandler.blockUpdateChunk != null) {
+                MCUtil.ensureMain(() -> this.updateNeighborsAt(pos, block));
+            } else
+            // MultiPaper end - run neighbour updates later if we're handling block changes
             this.updateNeighborsAt(pos, block);
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index bbd9fdaa4b12543307b144da72b0604eae638cbb..9c88f14a6f17bb054887f236f1b2711202dadfa2 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -32,6 +32,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.storage.SectionStorage;
+import puregero.multipaper.MultiPaper;
 
 public class PoiManager extends SectionStorage<PoiSection> {
     public static final int MAX_VILLAGE_DISTANCE = 6;
@@ -447,6 +448,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
             }
             return ret;
         }
+        if (true) return MultiPaper.readRegionFileNBT(world, "poi", chunkcoordintpair); // MultiPaper
         return super.read(chunkcoordintpair);
     }
 
@@ -458,6 +460,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
+        if (true) MultiPaper.writeRegionFileNBT(world, "poi", chunkcoordintpair, nbttagcompound); // MultiPaper
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index ab38b0e0394f53979dc3a32270814bf3cb41a330..c53190203f18e9ae40466454e1a3b76e7b8511d3 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -99,6 +99,7 @@ import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
+import puregero.multipaper.MultiPaperChunkHandler;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -1056,6 +1057,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 toRemove.add(tickingblockentity); // Paper - use removeAll
                 // Spigot end
             } else if (this.shouldTickBlocksAt(ChunkPos.asLong(tickingblockentity.getPos()))) {
+                if (!MultiPaperChunkHandler.shouldTick(this, tickingblockentity.getPos())) continue; // MultiPaper - should tick
                 tickingblockentity.tick();
             }
         }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index 5601d0c2fe635a2a4f073c333531e1a8adf1833c..dd35cc82ce15dd7a76081109a8d29b3df168e0dd 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -24,6 +24,7 @@ import org.bukkit.inventory.InventoryHolder;
 import org.spigotmc.CustomTimingsHandler; // Spigot
 import co.aikar.timings.MinecraftTimings; // Paper
 import co.aikar.timings.Timing; // Paper
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public abstract class BlockEntity implements io.papermc.paper.util.KeyedObject { // Paper
 
@@ -190,6 +191,7 @@ public abstract class BlockEntity implements io.papermc.paper.util.KeyedObject {
     }
 
     protected static void setChanged(Level world, BlockPos pos, BlockState state) {
+        MultiPaperChunkHandler.broadcastBlockEntityChange(world.getBlockEntity(pos)); // MultiPaper
         world.blockEntityChanged(pos);
         if (!state.isAir()) {
             world.updateNeighbourForOutputSignal(pos, state.getBlock());
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 1a6fa27a966fbc8d7f458a0121c9e2f80c0316fd..a1cb320b82d63c22380b725096078fb104dfebbb 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -7,9 +7,10 @@ import com.google.common.collect.UnmodifiableIterator;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
-import java.util.Iterator;
-import java.util.Map;
+
+import java.util.*;
 import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -22,6 +23,7 @@ import net.minecraft.core.BlockPos;
 import net.minecraft.core.Registry;
 import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkPacketData;
 import net.minecraft.server.level.ChunkHolder;
@@ -53,6 +55,7 @@ import net.minecraft.world.ticks.LevelChunkTicks;
 import net.minecraft.world.ticks.TickContainerAccess;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.*;
 
 public class LevelChunk extends ChunkAccess {
 
@@ -80,13 +83,18 @@ public class LevelChunk extends ChunkAccess {
     public boolean loaded;
     private boolean clientLightReady;
     public final ServerLevel level; // CraftBukkit - type
+    @Nullable public ExternalServer externalOwner; // MultiPaper - Chunk owner
+    public Set<ExternalServer> externalSubscribers = ConcurrentHashMap.newKeySet(); // MultiPaper - Chunk subscribers
+    public boolean hasExternalLockRequest = false; // MultiPaper - Have we sent a request to lock this chunk?
     @Nullable
     private Supplier<ChunkHolder.FullChunkStatus> fullStatus;
     @Nullable
     private LevelChunk.PostLoadProcessor postLoad;
+    @Nullable public ListTag entitiesToLoad; // MultiPaper
+    @Nullable public ListTag blockEntitiesToLoad; // MultiPaper
     private final Int2ObjectMap<GameEventDispatcher> gameEventDispatcherSections;
-    private final LevelChunkTicks<Block> blockTicks;
-    private final LevelChunkTicks<Fluid> fluidTicks;
+    public LevelChunkTicks<Block> blockTicks; // MultiPaper - make public and non-final
+    public LevelChunkTicks<Fluid> fluidTicks; // MultiPaper - make public and non-final
     // Paper start - track last save time
     public long lastSaveTime;
     public void setLastSaved(long ticks) {
@@ -813,6 +821,7 @@ public class LevelChunk extends ChunkAccess {
         // Paper end - neighbour cache
         org.bukkit.Server server = this.level.getCraftServer();
         this.level.getChunkSource().addLoadedChunk(this); // Paper
+        MultiPaperChunkHandler.onChunkLoad(this); // MultiPaper
         if (server != null) {
             /*
              * If it's a new world, the first few chunks are generated inside
@@ -874,7 +883,7 @@ public class LevelChunk extends ChunkAccess {
 
     @Override
     public boolean isUnsaved() {
-        return super.isUnsaved() && !this.mustNotSave;
+        return super.isUnsaved() && !this.mustNotSave && !MultiPaper.isChunkExternal(this); // MultiPaper - only save if no one else owns it
     }
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index e947a47dd8c6906bc36eca757c4b9f9f2ab3cedc..bdaa97438993c21997e7aa570d418926fb9d53a4 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -45,8 +45,8 @@ public class ProtoChunk extends ChunkAccess {
     private final Map<GenerationStep.Carving, CarvingMask> carvingMasks = new Object2ObjectArrayMap<>();
     @Nullable
     private BelowZeroRetrogen belowZeroRetrogen;
-    private final ProtoChunkTicks<Block> blockTicks;
-    private final ProtoChunkTicks<Fluid> fluidTicks;
+    public ProtoChunkTicks<Block> blockTicks; // MultiPaper - make public and non-final
+    public ProtoChunkTicks<Fluid> fluidTicks; // MultiPaper - make public and non-final
 
     public ProtoChunk(ChunkPos pos, UpgradeData upgradeData, LevelHeightAccessor world, Registry<Biome> biomeRegistry, @Nullable BlendingData blendingData) {
         this(pos, upgradeData, (LevelChunkSection[])null, new ProtoChunkTicks<>(), new ProtoChunkTicks<>(), world, biomeRegistry, blendingData);
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
index 8246204ce5d8f825c7796f87006e658d7a019876..628c0b7aac06b75682ce0cfb8220e6a84daaf235 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
@@ -277,6 +277,10 @@ public class ChunkSerializer {
             object = new LevelChunk(world.getLevel(), chunkPos, chunkconverter, levelchunkticks, levelchunkticks1, l, achunksection, ChunkSerializer.postLoadChunk(world, nbt), blendingdata);
             ((LevelChunk)object).setBlockNibbles(blockNibbles); // Paper - replace light impl
             ((LevelChunk)object).setSkyNibbles(skyNibbles); // Paper - replace light impl
+            // MultiPaper start - Keep copy of entities and block entities until they're loaded
+            ((LevelChunk)object).entitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "entities");
+            ((LevelChunk)object).blockEntitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "block_entities");
+            // MultiPaper end
         } else {
             ProtoChunkTicks<Block> protochunkticklist = ProtoChunkTicks.load(nbt.getList("block_ticks", 10), (s) -> {
                 return Registry.BLOCK.getOptional(ResourceLocation.tryParse(s));
@@ -745,6 +749,10 @@ public class ChunkSerializer {
                 }
             }
 
+            // MultiPaper start - Keep copy of entities and block entities until they're loaded
+            chunk.entitiesToLoad = null;
+            chunk.blockEntitiesToLoad = null;
+            // MultiPaper end
         };
     }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
index fec7d5c6a7b7a20ac9aecec1d3187f5c61fc430c..6b51ced0a50165c313e9302a2c9d7f47f66b0f4f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -47,7 +47,7 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
     public CompletableFuture<ChunkEntities<Entity>> loadEntities(ChunkPos pos) {
         return this.emptyChunks.contains(pos.toLong()) ? CompletableFuture.completedFuture(emptyChunk(pos)) : this.worker.loadAsync(pos).thenApplyAsync((compound) -> {
             if (compound == null) {
-                this.emptyChunks.add(pos.toLong());
+                // this.emptyChunks.add(pos.toLong()); // MultiPaper - don't cache empty chunks
                 return emptyChunk(pos);
             } else {
                 try {
@@ -87,7 +87,7 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
             if (this.emptyChunks.add(chunkPos.toLong())) {
                 this.worker.store(chunkPos, (CompoundTag)null);
             }
-
+            this.emptyChunks.remove(chunkPos.toLong()); // MultiPaper - don't cache empty chunks
         } else {
             ListTag listTag = new ListTag();
             final java.util.Map<net.minecraft.world.entity.EntityType<?>, Integer> savedEntityCounts = new java.util.HashMap<>(); // Paper
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index 834fa7048e3affb4fcc734d56526b9fba5fa69ca..70a68b0a8bacbc1a527b72f6fba4403f4fbfda1e 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -894,6 +894,7 @@ public class RegionFile implements AutoCloseable {
     }
 
     public boolean hasChunk(ChunkPos pos) {
+        if (true) return true; // MultiPaper - always return true
         return this.getOffset(pos) != 0;
     }
 
@@ -903,6 +904,12 @@ public class RegionFile implements AutoCloseable {
     }
 
     public void close() throws IOException {
+        // MultiPaper start
+        if (this.file == null) {
+            this.closed = true;
+            return;
+        }
+        // MultiPaper end
         // Paper start - Prevent regionfiles from being closed during use
         this.fileLock.lock();
         synchronized (this) {
diff --git a/src/main/java/puregero/multipaper/ChunkKey.java b/src/main/java/puregero/multipaper/ChunkKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..d139536be7ab15293b798af115e71a8dbe4a2f3d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ChunkKey.java
@@ -0,0 +1,34 @@
+package puregero.multipaper;
+
+public class ChunkKey {
+    private final String name;
+    private final int x;
+    private final int z;
+
+    public ChunkKey(String name, int x, int z) {
+        this.name = name;
+        this.x = x;
+        this.z = z;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof ChunkKey) {
+            return ((ChunkKey) other).name.equals(name)
+                    && ((ChunkKey) other).x == x
+                    && ((ChunkKey) other).z == z;
+        }
+
+        return super.equals(other);
+    }
+
+    @Override
+    public int hashCode() {
+        // Taken from ChunkCoordIntPair
+        int i = 1664525 * this.x + 1013904223;
+        int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+
+        return name.hashCode() ^ i ^ j;
+    }
+}
+
diff --git a/src/main/java/puregero/multipaper/ExternalServerConnection.java b/src/main/java/puregero/multipaper/ExternalServerConnection.java
index 9adb38f09481683789d193d7fc4adcf89569afba..67eab8c9e6c41fb0ca104e0ec21d1411343f6822 100644
--- a/src/main/java/puregero/multipaper/ExternalServerConnection.java
+++ b/src/main/java/puregero/multipaper/ExternalServerConnection.java
@@ -4,21 +4,23 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ServerPlayer;
-import puregero.multipaper.externalserverprotocol.ExternalServerPacket;
-import puregero.multipaper.externalserverprotocol.ExternalServerPacketSerializer;
-import puregero.multipaper.externalserverprotocol.HelloPacket;
-import puregero.multipaper.externalserverprotocol.SendPacketPacket;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.externalserverprotocol.*;
 
 import java.io.*;
 import java.net.Socket;
 import java.nio.ByteBuffer;
 import java.util.*;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.function.Consumer;
 
 public class ExternalServerConnection extends Thread implements Closeable {
 
+    private static final Logger LOGGER = LogManager.getLogger(ExternalServerPacket.class.getSimpleName());
     private final Socket socket;
     public ExternalServer externalServer = null;
     private final ExecutorService sendThread = Executors.newSingleThreadExecutor();
@@ -26,6 +28,7 @@ public class ExternalServerConnection extends Thread implements Closeable {
 
     private static final Queue<List<ExternalPlayer>> externalPlayerListPool = new LinkedList<>();
     private final HashMap<Packet<?>, List<ExternalPlayer>> packetsToSend = new LinkedHashMap<>();
+    public final ConcurrentHashMap<ChunkKey, Consumer<byte[]>> chunkCallbacks = new ConcurrentHashMap<>();
 
     public ExternalServerConnection(Socket socket) {
         this.socket = socket;
@@ -137,4 +140,15 @@ public class ExternalServerConnection extends Thread implements Closeable {
             players.add(player);
         }
     }
+
+    public void requestChunk(String world, int cx, int cz, Consumer<byte[]> callback) {
+        if (callback != null) {
+            if (chunkCallbacks.put(new ChunkKey(world, cx, cz), callback) != null) {
+                LOGGER.warn("A chunk callback already existed for " + world + ", " + cx + ", " + cz);
+            }
+        }
+
+        RequestChunkPacket.blocker = externalServer;
+        send(new RequestChunkPacket(world, cx, cz));
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index 0cecbaf69f193011860c03e3fe0787d269819a60..1e76a47314e31f37283dfca0f61c16daea9a5bf7 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -3,25 +3,48 @@ package puregero.multipaper;
 import net.minecraft.server.level.ServerPlayer;
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Registry;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftEntity;
-import puregero.multipaper.externalserverprotocol.ExternalServerPacket;
-import puregero.multipaper.externalserverprotocol.PlayerCreatePacket;
-import puregero.multipaper.externalserverprotocol.PlayerRemovePacket;
+import puregero.multipaper.externalserverprotocol.*;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
+import java.io.*;
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
 
 public class MultiPaper {
 
+    public final static ConcurrentHashMap<ChunkKey, ExternalServer> chunkOwnerToSet = new ConcurrentHashMap<>();
+    public final static ConcurrentHashMap<ChunkKey, HashSet<ExternalServer>> chunkSubscribersToSet = new ConcurrentHashMap<>();
+    public final static ConcurrentHashMap<ChunkKey, Runnable> reloadChunks = new ConcurrentHashMap<>();
     private static MultiPaperConnection multiPaperConnection = null;
     private static ExternalServerSocket externalServerSocket = null;
+    private final static List<ChunkHolder> visibleChunksToCheck = new ArrayList<>();
 
     public static MultiPaperConnection getConnection() {
         if (multiPaperConnection == null) {
@@ -105,6 +128,25 @@ public class MultiPaper {
                 server.getConnection().tick();
             }
         }
+
+        reloadChunks.entrySet().removeIf(entry -> {
+            entry.getValue().run();
+            return true;
+        });
+
+        if (visibleChunksToCheck.isEmpty()) {
+            for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
+                visibleChunksToCheck.addAll(level.chunkSource.chunkMap.updatingChunks.getVisibleValues());
+            }
+        }
+
+        while (!visibleChunksToCheck.isEmpty()) {
+            ChunkHolder holder = visibleChunksToCheck.remove(visibleChunksToCheck.size() - 1);
+            if (holder.getAvailableChunkNow() != null && holder.getWorld().chunkSource.chunkMap.getVisibleChunkIfPresent(holder.pos.longKey) == holder) {
+                getConnection().syncChunkSubscribers(holder.getWorld().getWorld().getName(), holder.pos.x, holder.pos.z);
+                break;
+            }
+        }
     }
 
     public static void sendTickTime(long time, double tps) {
@@ -194,4 +236,168 @@ public class MultiPaper {
     public static boolean isExternalPlayer(org.bukkit.entity.Entity bukkitEntity) {
         return isExternalPlayer(((CraftEntity) bukkitEntity).getHandle());
     }
+
+    public static boolean isChunkExternal(Chunk chunk) {
+        return chunk != null && isChunkExternal(((CraftChunk) chunk).getHandle());
+    }
+
+    public static boolean isChunkExternal(ChunkAccess chunk) {
+        return chunk instanceof LevelChunk && ((LevelChunk) chunk).externalOwner != null && !((LevelChunk) chunk).externalOwner.isMe();
+    }
+
+    public static boolean isChunkLocal(Chunk chunk) {
+        return chunk != null && isChunkLocal(((CraftChunk) chunk).getHandle());
+    }
+
+    public static boolean isChunkLocal(ChunkAccess chunk) {
+        return chunk instanceof LevelChunk && ((LevelChunk) chunk).externalOwner != null && ((LevelChunk) chunk).externalOwner.isMe();
+    }
+
+    public static CompoundTag readChunk(ChunkPos chunkPos, ServerLevel serverLevel) throws IOException {
+        return readRegionFileNBT(serverLevel, "region", chunkPos);
+    }
+
+    public static void writeChunk(ChunkPos chunkPos, ServerLevel serverLevel, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel, "region", chunkPos, compoundTag);
+    }
+
+    public static DataInput readRegionFile(String world, String path, int cx, int cz) throws IOException {
+        try {
+            return getConnection().readChunk(world, path, cx, cz).get(15, TimeUnit.SECONDS);
+        } catch (TimeoutException timeoutException) {
+            LOGGER.warn("Timed out reading " + world + "," + path + "," + cx + "," + cz + ", retrying...");
+            return readRegionFile(world, path, cx, cz);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void writeRegionFile(String world, String path, int cx, int cz, byte[] bytes) throws IOException {
+        getConnection().writeChunk(world, path, cx, cz, bytes);
+    }
+ 
+    public static CompoundTag readRegionFileNBT(File path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(serverLevel.convertable.getLevelId(), path, chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(String world, String path, int cx, int cz) throws IOException {
+        DataInput in = readRegionFile(world, path, cx, cz);
+
+        return in == null ? null : NbtIo.read(in);
+    }
+ 
+    public static void writeRegionFileNBT(File path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel.convertable.getLevelId(), path, chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(String world, String path, int cx, int cz, CompoundTag compoundTag) throws IOException {
+        writeRegionFile(world, path, cx, cz, nbtToBytes(compoundTag));
+    }
+
+    private static String getWorld(File path) {
+        do {
+            path = path.getParentFile();
+        } while (path.getName().startsWith("DIM"));
+        return path.getName();
+    }
+
+    public static void lockChunk(LevelChunk chunk) {
+        try {
+            getConnection().lockChunk(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ);
+            chunk.hasExternalLockRequest = true;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void unlockChunk(LevelChunk chunk) {
+        try {
+            if (MultiPaper.isChunkLocal(chunk)) {
+                broadcastPacketToExternalServers(chunk.externalSubscribers, () -> new SendTickListPacket(chunk));
+            }
+            getConnection().unlockChunk(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ);
+            chunk.externalOwner = null;
+            chunk.hasExternalLockRequest = false;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+    
+    public static byte[] nbtToBytes(CompoundTag compoundTag) throws IOException {
+        if (compoundTag == null) {
+            return new byte[0];
+        }
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        NbtIo.write(compoundTag, new DataOutputStream(buffer));
+        return buffer.toByteArray();
+    }
+
+    public static CompoundTag nbtFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new ByteArrayInputStream(data)));
+    }
+
+    public static byte[] nbtCompressToBytes(CompoundTag compoundTag) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(buffer);
+        NbtIo.write(compoundTag, new DataOutputStream(deflaterOutputStream));
+        deflaterOutputStream.close();
+        return buffer.toByteArray();
+    }
+
+    public static CompoundTag nbtDecompressFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+    }
+
+    public static ChunkAccess getChunkAccess(String world, int cx, int cz) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkAccess chunkAccess = level.getChunkIfLoaded(cx, cz);
+
+        if (chunkAccess == null) {
+            ChunkHolder holder = level.chunkSource.chunkMap.getUpdatingChunkIfPresent(ChunkPos.asLong(cx, cz));
+            if (holder != null) {
+                chunkAccess = holder.getAvailableChunkNow();
+
+                if (chunkAccess instanceof ImposterProtoChunk) {
+                    chunkAccess = ((ImposterProtoChunk) chunkAccess).getWrapped();
+                }
+            }
+        }
+
+        return chunkAccess;
+    }
+
+    public static ChunkAccess getChunkAccess(String world, BlockPos pos) {
+        return getChunkAccess(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static ChunkHolder getChunkHolder(String world, BlockPos pos) {
+        return getChunkHolder(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static ChunkHolder getChunkHolder(String world, int x, int z) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkHolder holder = level.chunkSource.chunkMap.getVisibleChunkIfPresent(ChunkPos.asLong(x, z));
+
+        if (holder == null) {
+            holder = level.chunkSource.chunkMap.getUpdatingChunkIfPresent(ChunkPos.asLong(x, z));
+        }
+
+        return holder;
+    }
+
+    public static void chunkChangedStatus(ServerLevel level, ChunkPos pos, ChunkStatus status) {
+        try {
+            getConnection().sendChunkChangedStatus(level.convertable.getLevelId(), pos.x, pos.z, Registry.CHUNK_STATUS.getKey(status).toString());
+        } catch (IOException e) {
+            e.printStackTrace();
+        };
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..9989877d7e79c9b7e92f43007b538a6516d87d6f
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
@@ -0,0 +1,219 @@
+package puregero.multipaper;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.DataLayer;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.lighting.LevelLightEngine;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.externalserverprotocol.SendUpdatePacket;
+
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.Iterator;
+
+public class MultiPaperChunkHandler {
+
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperChunkHandler.class.getSimpleName());
+
+    public static boolean shouldTick(Level level, BlockPos pos) {
+        LevelChunk chunk = level.getChunkIfLoaded(pos);
+        return !MultiPaper.isChunkExternal(chunk);
+    }
+
+    public static void onChunkLoad(LevelChunk chunk) {
+        ExternalServer owner = MultiPaper.chunkOwnerToSet.remove(new ChunkKey(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ));
+        if (owner != null) {
+            chunk.externalOwner = owner;
+        }
+
+        HashSet<ExternalServer> externalSubscribers = MultiPaper.chunkSubscribersToSet.remove(new ChunkKey(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ));
+        if (externalSubscribers != null) {
+            chunk.externalSubscribers.addAll(externalSubscribers);
+        }
+    }
+
+    public static void onChunkUnload(ServerLevel level, ChunkPos pos, @Nullable ChunkAccess chunk) {
+        if (chunk instanceof LevelChunk levelChunk && levelChunk.hasExternalLockRequest) {
+            MultiPaper.unlockChunk(levelChunk);
+        }
+        try {
+            MultiPaper.getConnection().unsubscribeChunk(level.convertable.getLevelId(), pos.x, pos.z);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static final HashSet<BlockEntity> blockEntitiesToBroadcast = new HashSet<>();
+    public static void broadcastBlockEntityChange(BlockEntity entity) {
+        if (blockUpdateChunk != null) return; // Don't broadcast the update to other servers if we're handling an update
+        blockEntitiesToBroadcast.add(entity);
+        // Wait a bit as the block entity may get changed multiple times in 1 tick
+        MultiPaper.runSync(() -> {
+            for (BlockEntity blockEntity : blockEntitiesToBroadcast) {
+                if (blockEntity != null) {
+                    MultiPaperChunkHandler.onBlockUpdate(MultiPaper.getChunkHolder(blockEntity.getLevel().getWorld().getName(), blockEntity.getBlockPos()), ClientboundBlockEntityDataPacket.create(blockEntity, BlockEntity::saveWithFullMetadata));
+                }
+            }
+            blockEntitiesToBroadcast.clear();
+        });
+    }
+
+    public static void onBlockUpdate(ChunkHolder chunkHolder, Packet<?> packet) {
+        if (chunkHolder == null) {
+            // Chunk is still loading
+            return;
+        }
+
+        LevelChunk chunk = chunkHolder.getFullChunk();
+        if (chunk == null) {
+            if (chunkHolder.getAvailableChunkNow() instanceof LevelChunk) {
+                chunk = (LevelChunk) chunkHolder.getAvailableChunkNow();
+            } else {
+                LOGGER.warn("A " + packet.getClass().getSimpleName() + " occurred on an unloaded chunk " + chunkHolder.getAvailableChunkNow());
+                return;
+            }
+        }
+        if (blockUpdateChunk == null) { // Don't broadcast the update to other servers if we're handling an update
+            for (ExternalServer externalServer : chunk.externalSubscribers) {
+                if (!externalServer.isMe()) {
+                    externalServer.getConnection().send(new SendUpdatePacket(chunkHolder.getWorld().convertable.getLevelId(), packet));
+                }
+            }
+        }
+    }
+
+    public static ChunkAccess blockUpdateChunk = null;
+    private static ChunkHolder holder = null;
+    public static void handleBlockUpdate(String world, Packet<?> packet) {
+        holder = null;
+        blockUpdateChunk = null;
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        if (packet instanceof ClientboundBlockUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+            update.runUpdates((pos, state) -> {
+                if (holder == null) holder = MultiPaper.getChunkHolder(world, pos);
+            });
+        } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundLightUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getX(), update.getZ());
+        }
+
+        if (holder != null) {
+            blockUpdateChunk = holder.getAvailableChunkNow();
+
+            if (blockUpdateChunk instanceof ImposterProtoChunk imposterProtoChunk) {
+                blockUpdateChunk = imposterProtoChunk.getWrapped();
+            }
+        }
+
+        if (holder != null && blockUpdateChunk instanceof LevelChunk levelChunk) {
+            // Clear pre-existing block changes
+            holder.broadcastChanges(levelChunk);
+        }
+
+        boolean unsaved = false;
+        if (blockUpdateChunk != null) {
+            unsaved = blockUpdateChunk.isUnsaved();
+        }
+
+        if (holder != null && level.getChunkIfLoaded(holder.pos.x, holder.pos.z) != null) {
+            // Chunk is loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                level.setBlockAndUpdate(update.getPos(), update.getBlockState());
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    level.setBlockAndUpdate(pos, state);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                if (!update.getTag().getString("id").equals("minecraft:piston")) {
+                    blockUpdateChunk.removeBlockEntity(update.getPos());
+                    blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                    blockUpdateChunk.getBlockEntity(update.getPos());
+
+                    if (((LevelChunk) blockUpdateChunk).playerChunk != null) {
+                        ((LevelChunk) blockUpdateChunk).playerChunk.blockChanged(update.getPos());
+                    }
+                }
+            }
+        } else if (blockUpdateChunk != null) {
+            // Chunk is not loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                blockUpdateChunk.setBlockState(update.getPos(), update.getBlockState(), false);
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    blockUpdateChunk.setBlockState(pos, state, false);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                BlockEntity entity = blockUpdateChunk.getBlockEntity(update.getPos());
+                if (entity != null) {
+                    entity.load(update.getTag());
+                } else {
+                    blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                }
+            } else if (packet instanceof ClientboundLightUpdatePacket update) {
+                // TODO: Doesn't work
+                handleLightUpdatePacket(level, blockUpdateChunk, update);
+            }
+        }
+
+        if (holder != null && blockUpdateChunk instanceof LevelChunk levelChunk) {
+            // Send block changes
+            holder.broadcastChanges(levelChunk);
+        }
+
+        if (blockUpdateChunk != null) {
+            // Don't save changes that another server has made
+            blockUpdateChunk.setUnsaved(unsaved);
+        }
+
+        blockUpdateChunk = null;
+    }
+
+    // From the client
+    private static void handleLightUpdatePacket(ServerLevel level, ChunkAccess chunk, ClientboundLightUpdatePacket packet) {
+        int i = packet.getX();
+        int j = packet.getZ();
+        LevelLightEngine levellightengine = level.getChunkSource().getLightEngine();
+        BitSet bitset = packet.getLightData().getSkyYMask();
+        BitSet bitset1 = packet.getLightData().getEmptySkyYMask();
+        Iterator<byte[]> iterator = packet.getLightData().getSkyUpdates().iterator();
+        readSectionList(i, j, levellightengine, LightLayer.SKY, bitset, bitset1, iterator, packet.getLightData().getTrustEdges());
+        BitSet bitset2 = packet.getLightData().getBlockYMask();
+        BitSet bitset3 = packet.getLightData().getEmptyBlockYMask();
+        Iterator<byte[]> iterator1 = packet.getLightData().getBlockUpdates().iterator();
+        readSectionList(i, j, levellightengine, LightLayer.BLOCK, bitset2, bitset3, iterator1, packet.getLightData().getTrustEdges());
+    }
+
+    // From the client
+    private static void readSectionList(int i, int j, LevelLightEngine levelLightEngine, LightLayer lightLayer, BitSet bitset2, BitSet bitset3, Iterator<byte[]> iterator1, boolean trustEdges) {
+        for(int k = 0; k < levelLightEngine.getLightSectionCount(); ++k) {
+            int l = levelLightEngine.getMinLightSection() + k;
+            boolean flag = bitset2.get(k);
+            boolean flag1 = bitset3.get(k);
+            if (flag || flag1) {
+                levelLightEngine.queueSectionData(lightLayer, SectionPos.of(i, l, j), flag ? new DataLayer((byte[])iterator1.next().clone()) : new DataLayer(), trustEdges);
+            }
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index a07fee59d0907e2263426ec0ba47fb7bec6b9aee..3287ce488700ce67038dcb25e7ae7ff2ada1b505 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -1,16 +1,28 @@
 package puregero.multipaper;
 
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.externalserverprotocol.RequestChunkPacket;
 
 import javax.annotation.Nullable;
 import java.io.*;
 import java.net.Socket;
 import java.net.SocketException;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
 
 public class MultiPaperConnection extends Thread {
 
@@ -79,6 +91,17 @@ public class MultiPaperConnection extends Thread {
                     }
                 }
 
+                if (MinecraftServer.getServer() != null) {
+                    for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
+                        level.chunkSource.chunkMap.updatingChunks.getVisibleValuesCopy().forEach(chunkHolder -> {
+                            subscribeChunk(level.convertable.getLevelId(), chunkHolder.pos.x, chunkHolder.pos.z);
+                        });
+                        level.chunkSource.chunkMap.updatingChunks.getUpdatingValuesCopy().forEach(chunkHolder -> {
+                            subscribeChunk(level.convertable.getLevelId(), chunkHolder.pos.x, chunkHolder.pos.z);
+                        });
+                    }
+                }
+
                 DataInputStream in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
                 while (!socket.isClosed()) {
                     int id = in.readInt();
@@ -119,6 +142,95 @@ public class MultiPaperConnection extends Thread {
         server.setLastAlive(System.currentTimeMillis());
     }
 
+    public void chunkOwner(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        String owner = in.readUTF();
+        ExternalServer server = owner.isEmpty() ? null : getOrCreateServer(owner);
+
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk != null) {
+            if (chunk instanceof LevelChunk) {
+                ((LevelChunk) chunk).externalOwner = server;
+            }
+            if (server != null && chunk.getStatus() != ChunkStatus.FULL) {
+                // A server has locked the chunk, which means their chunk must be full.
+                // Let's redownload their full copy
+                MultiPaper.reloadChunks.put(new ChunkKey(world, cx, cz), () -> server.getConnection().send(new RequestChunkPacket(world, cx, cz)));
+            }
+        }
+    }
+
+    public void chunkSubscribe(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        ExternalServer server = getOrCreateServer(in.readUTF());
+
+        MultiPaper.runSync(() -> {
+            ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+            if (chunk instanceof LevelChunk levelChunk) {
+                levelChunk.externalSubscribers.add(server);
+            } else {
+                MultiPaper.chunkSubscribersToSet.computeIfAbsent(new ChunkKey(world, cx, cz), key -> new HashSet<>()).add(server);
+            }
+        });
+    }
+
+    public void chunkUnsubscribe(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        ExternalServer server = getOrCreateServer(in.readUTF());
+
+        MultiPaper.runSync(() -> {
+            ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+            if (chunk instanceof LevelChunk levelChunk) {
+                levelChunk.externalSubscribers.remove(server);
+            }
+
+            HashSet<ExternalServer> subscribers = MultiPaper.chunkSubscribersToSet.get(new ChunkKey(world, cx, cz));
+            if (subscribers != null) {
+                subscribers.remove(server);
+            }
+        });
+    }
+
+    public void chunkSubscribeSync(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        String owner = in.readUTF();
+        ExternalServer ownerServer = owner.isEmpty() ? null : getOrCreateServer(owner);
+        int length = in.readInt();
+        HashSet<ExternalServer> servers = new HashSet<>();
+        for (int i = 0; i < length; i++) {
+            servers.add(getOrCreateServer(in.readUTF()));
+        }
+
+        MultiPaper.runSync(() -> {
+            ChunkKey key = new ChunkKey(world, cx, cz);
+
+            MultiPaper.chunkSubscribersToSet.remove(key);
+
+            ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+            if (chunk instanceof LevelChunk levelChunk) {
+                levelChunk.externalOwner = ownerServer;
+                levelChunk.externalSubscribers.clear();
+                levelChunk.externalSubscribers.addAll(servers);
+            } else {
+                MultiPaper.chunkSubscribersToSet.put(key, servers);
+
+                if (ownerServer == null) {
+                    MultiPaper.chunkOwnerToSet.remove(key);
+                } else {
+                    MultiPaper.chunkOwnerToSet.put(key, ownerServer);
+                }
+            }
+        });
+    }
+
     public void start(DataInputStream in, DataOutputSender out) throws IOException {
         String address = in.readUTF();
         int port = in.readInt();
@@ -133,6 +245,24 @@ public class MultiPaperConnection extends Thread {
         });
     }
 
+    public void chunkChangedStatus(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        String statusString = in.readUTF();
+        ExternalServer server = getOrCreateServer(in.readUTF());
+        ChunkStatus status = Registry.CHUNK_STATUS.get(new ResourceLocation(statusString));
+
+        if (!server.isMe()) {
+            ChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+            if (holder == null) {
+                LOGGER.warn("Received a chunk change status notification for an unloaded chunk " + world + ";" + cx + ";" + cz + " from " + server.getName());
+            } else if (holder.getAvailableChunkNow() != null && !holder.getAvailableChunkNow().getStatus().isOrAfter(status)) {
+                MultiPaper.reloadChunks.put(new ChunkKey(world, cx, cz), () -> server.getConnection().send(new RequestChunkPacket(world, cx, cz)));
+            }
+        }
+    }
+
     public void writeTickTime(long time, double tps) throws IOException {
         DataOutputSender out = new DataOutputSender(this);
         out.writeUTF("writeTickTime");
@@ -147,4 +277,159 @@ public class MultiPaperConnection extends Thread {
         out.writeInt(port);
         out.send(null);
     }
+
+    public CompletableFuture<Integer> getEntityCounterStartValue() throws IOException {
+        CompletableFuture<Integer> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("getEntityCounterStartValue");
+        out.send(in -> {
+            try {
+                future.complete(in.readInt());
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public CompletableFuture<byte[]> forceReadChunk(String world, String path, int cx, int cz) throws IOException {
+        CompletableFuture<byte[]> future = new CompletableFuture<>();
+
+        Consumer<DataInputStream> callback = in -> {
+            try {
+                String owner = in.readUTF();
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+                future.complete(data);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        };
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("forceReadChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(callback);
+
+        return future;
+    }
+
+    public CompletableFuture<DataInputStream> readChunk(String world, String path, int cx, int cz) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        Consumer<DataInputStream> callback = in -> {
+            try {
+                String owner = in.readUTF();
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                if (!owner.isEmpty() && path.equals("region")) {
+                    ExternalServer server = serversMap.get(owner);
+                    server.getConnection().requestChunk(world, cx, cz, data2 -> {
+                        RequestChunkPacket.blocker = null;
+                        future.complete(data2.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data2))));
+                    });
+                } else {
+                    future.complete(data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        };
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(callback);
+
+        return future;
+    }
+
+    public void writeChunk(String world, String path, int cx, int cz, byte[] data) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        DeflaterOutputStream deflateOut = new DeflaterOutputStream(baos);
+        deflateOut.write(data);
+        deflateOut.close();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeInt(baos.size());
+        out.write(baos.toByteArray());
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void unlockChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("unlockChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void subscribeChunk(String world, int cx, int cz) {
+        try {
+            DataOutputSender out = new DataOutputSender(this);
+            out.writeUTF("subscribeChunk");
+            out.writeUTF(world);
+            out.writeInt(cx);
+            out.writeInt(cz);
+            out.send(null);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void unsubscribeChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("unsubscribeChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void syncChunkSubscribers(String world, int cx, int cz) {
+        try {
+            DataOutputSender out = new DataOutputSender(this);
+            out.writeUTF("syncChunkSubscribers");
+            out.writeUTF(world);
+            out.writeInt(cx);
+            out.writeInt(cz);
+            out.send(null);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void sendChunkChangedStatus(String world, int cx, int cz, String resource) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("chunkChangedStatus");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeUTF(resource);
+        out.send(null);
+    }
 }
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index c1bac1bf5148126a0fcad517bf499833d31cf050..934b75c68cc94cf39d09f086d97b88d0fe50c23c 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -20,6 +20,10 @@ public class ExternalServerPacketSerializer {
         addPacket(PlayerRespawnPacket.class, PlayerRespawnPacket::new);
         addPacket(PlayerChangeDimensionPacket.class, PlayerChangeDimensionPacket::new);
         addPacket(SendPacketPacket.class, SendPacketPacket::new);
+        addPacket(SendUpdatePacket.class, SendUpdatePacket::new);
+        addPacket(RequestChunkPacket.class, RequestChunkPacket::new);
+        addPacket(SendChunkPacket.class, SendChunkPacket::new);
+        addPacket(SendTickListPacket.class, SendTickListPacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, IOExceptionFunction<DataInputStream, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..0bf479e9476128af2ae61d07d1fb51a6c20d392c
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
@@ -0,0 +1,122 @@
+package puregero.multipaper.externalserverprotocol;
+
+import com.mojang.datafixers.util.Either;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServer;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.ConcurrentModificationException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+public class RequestChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(RequestChunkPacket.class.getSimpleName());
+    public static ExternalServer blocker = null;
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+
+    public RequestChunkPacket(String world, int cx, int cz) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+    }
+
+    public RequestChunkPacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+        cx = in.readInt();
+        cz = in.readInt();
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+
+        if (holder == null) {
+            LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we aren't trying to load it.");
+            connection.send(new SendChunkPacket(world, cx, cz, null));
+            return;
+        }
+
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = holder.getLastAvailableChunkFuture();
+
+        if (blocker == connection.externalServer) {
+            ChunkAccess access = holder.getAvailableChunkNow();
+            if (access != null) {
+                future = CompletableFuture.completedFuture(Either.left(holder.getAvailableChunkNow()));
+            } else {
+                connection.send(new SendChunkPacket(world, cx, cz, null));
+                return;
+            }
+        }
+
+        future.thenAccept(either -> {
+            if (either.left().isEmpty()) {
+                LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we don't have it loaded.");
+                connection.send(new SendChunkPacket(world, cx, cz, null));
+                return;
+            }
+
+            ChunkAccess chunk = either.left().get();
+
+            try {
+                CompoundTag tag = ChunkSerializer.write(level, chunk);
+
+                if (chunk instanceof ImposterProtoChunk imposterProtoChunk) {
+                    chunk = imposterProtoChunk.getWrapped();
+                }
+
+                if (chunk instanceof LevelChunk levelChunk) {
+                    if (levelChunk.entitiesToLoad != null) {
+                        tag.put("entities", levelChunk.entitiesToLoad);
+                    }
+                    if (levelChunk.blockEntitiesToLoad != null) {
+                        tag.put("block_entities", levelChunk.blockEntitiesToLoad);
+                    }
+                }
+
+                connection.send(new SendChunkPacket(world, cx, cz, tag));
+            } catch (ConcurrentModificationException e) {
+                LOGGER.warn("Got ConcurrentModificationException while sending chunk, sending it in main thread instead");
+                e.printStackTrace();
+                MultiPaper.runSync(() -> handle(connection));
+            }
+        })
+        // Timeout instantly if this server is blocking our chunk loading, as this is probably also blocking their chunk loading
+        .orTimeout(15, TimeUnit.SECONDS).exceptionally(throwable -> {
+            if (throwable instanceof TimeoutException) {
+                LOGGER.warn("Timed out while sending chunk " + world + "," + cx + "," + cz);
+            } else {
+                LOGGER.warn("Error while sending chunk " + world + "," + cx + "," + cz, throwable);
+            }
+
+            connection.send(new SendChunkPacket(world, cx, cz, null));
+            return null;
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..dd3826160ebd266a829c91bb9ca2c535d6b6b3b8
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
@@ -0,0 +1,107 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ChunkKey;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.function.Consumer;
+import java.util.zip.InflaterInputStream;
+
+public class SendChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendChunkPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final byte[] data;
+
+    public SendChunkPacket(String world, int cx, int cz, CompoundTag tag) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+
+        try {
+            if (tag == null) {
+                data = new byte[0];
+            } else {
+                data = MultiPaper.nbtCompressToBytes(tag);
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public SendChunkPacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+        cx = in.readInt();
+        cz = in.readInt();
+        int byteLength = in.readInt();
+        data = new byte[byteLength];
+        in.readFully(data);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeInt(data.length);
+        out.write(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        try {
+            Consumer<byte[]> callback = connection.chunkCallbacks.remove(new ChunkKey(world, cx, cz));
+            if (callback != null) {
+                if (data.length == 0) {
+                    LOGGER.warn(connection.externalServer.getName() + " sent us an empty chunk for " + world + "," + cx + "," + cz + ", force loading it from disk");
+                    MultiPaper.getConnection().forceReadChunk(world, "region", cx, cz).thenAccept(callback);
+                } else {
+                    callback.accept(data);
+                }
+            } else {
+                if (data.length == 0) {
+                    return;
+                }
+
+                CompoundTag tag = NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+                ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+                ChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+                if (holder == null) {
+                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " but no chunk is loaded here");
+                } else if (holder.getAvailableChunkNow() instanceof LevelChunk) {
+//                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " but it is a level chunk (" + holder.getChunkHolderStatus() + ")");
+                } else {
+                    ChunkSerializer.InProgressChunkHolder newChunk = ChunkSerializer.loadChunk(level, level.getPoiManager(), new ChunkPos(cx, cz), tag, true);
+                    MultiPaper.runSync(() -> newChunk.tasks.forEach(Runnable::run));
+
+                    if (newChunk.protoChunk instanceof ImposterProtoChunk imposterProtoChunk) {
+                        holder.replaceProtoChunk(imposterProtoChunk);
+                    } else {
+                        holder.replaceProtoChunk(newChunk.protoChunk);
+                    }
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..cdca8cca8581c4d6146f98fca4d47eff103e898a
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
@@ -0,0 +1,83 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.core.Registry;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.ticks.LevelChunkTicks;
+import net.minecraft.world.ticks.ProtoChunkTicks;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class SendTickListPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendTickListPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final CompoundTag tag;
+
+    public SendTickListPacket(LevelChunk chunk) {
+        this.world = chunk.level.convertable.getLevelId();
+        this.cx = chunk.locX;
+        this.cz = chunk.locZ;
+
+        tag = new CompoundTag();
+        tag.put("block_ticks", chunk.blockTicks.save(chunk.level.getLevelData().getGameTime(), (block) -> Registry.BLOCK.getKey(block).toString()));
+        tag.put("fluid_ticks", chunk.fluidTicks.save(chunk.level.getLevelData().getGameTime(), (fluidtype) -> Registry.FLUID.getKey(fluidtype).toString()));
+    }
+
+    public SendTickListPacket(DataInputStream in) throws IOException {
+        this.world = in.readUTF();
+        this.cx = in.readInt();
+        this.cz = in.readInt();
+
+        int byteLength = in.readInt();
+        byte[] data = new byte[byteLength];
+        in.readFully(data);
+        tag = MultiPaper.nbtDecompressFromBytes(data);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+
+        byte[] data = MultiPaper.nbtCompressToBytes(tag);
+
+        out.writeInt(data.length);
+        out.write(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk instanceof LevelChunk levelChunk) {
+            levelChunk.unregisterTickContainerFromLevel(level);
+            levelChunk.blockTicks = LevelChunkTicks.load(tag.getList("block_ticks", Tag.TAG_COMPOUND), s -> Registry.BLOCK.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+            levelChunk.fluidTicks = LevelChunkTicks.load(tag.getList("fluid_ticks", Tag.TAG_COMPOUND), s -> Registry.FLUID.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+            levelChunk.unpackTicks(level.getLevelData().getGameTime());
+            if (levelChunk.loaded) levelChunk.registerTickContainerInLevel(level);
+        } else if (chunk instanceof ProtoChunk protoChunk) {
+            protoChunk.blockTicks = ProtoChunkTicks.load(tag.getList("block_ticks", Tag.TAG_COMPOUND), s -> Registry.BLOCK.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+            protoChunk.fluidTicks = ProtoChunkTicks.load(tag.getList("fluid_ticks", Tag.TAG_COMPOUND), s -> Registry.FLUID.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+        } else {
+            LOGGER.warn("Received tick lists for an unloaded chunk " + world + "," + cx + "," + cz);
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..b2bcaa3fbb1f9640faf3d7c61ba1a7087d46db12
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
@@ -0,0 +1,70 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class SendUpdatePacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendUpdatePacket.class.getSimpleName());
+
+    private final String world;
+    private final Packet<?> packet;
+
+    public SendUpdatePacket(String world, Packet<?> packet) {
+        this.world = world;
+        this.packet = packet;
+    }
+
+    public SendUpdatePacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+
+        int length = in.readInt();
+        byte[] bytes = new byte[length];
+        in.readFully(bytes);
+        ByteBuf buf = Unpooled.wrappedBuffer(bytes);
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        int packetId = friendlyByteBuf.readVarInt();
+        packet = ConnectionProtocol.PLAY.createPacket(PacketFlow.CLIENTBOUND, packetId, friendlyByteBuf);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(packet);
+        Integer id = protocol.getPacketId(PacketFlow.CLIENTBOUND, packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        packet.write(friendlyByteBuf);
+        byte[] bytes = buf.array();
+        out.writeInt(bytes.length);
+        out.write(bytes);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        if (packet instanceof ClientboundBlockUpdatePacket || packet instanceof ClientboundSectionBlocksUpdatePacket || packet instanceof ClientboundLightUpdatePacket || packet instanceof ClientboundBlockEntityDataPacket) {
+            MultiPaper.runSync(() -> MultiPaperChunkHandler.handleBlockUpdate(world, packet));
+        } else {
+            LOGGER.warn("Unhandled update packet of type " + packet.getClass().getSimpleName());
+        }
+    }
+}
